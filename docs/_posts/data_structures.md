---
title: 'data_structures'
date: 2022-01-21 18:36:45
tags: [data_structures]
categories: [CodeForces2100-2300]
mathjax: true
---

#### 52C
- 如果 $l\leq r$ 就直接线段树操作 $[l,r]$
- 否则操作 $[l,n],[1,r]$。

#### 617E
- 虽然询问一个区间不太好做，但是加入一个数是好做的，拿个桶记录一下每个数字个数就能计算了。
- 所以可以改为莫队来离线处理询问。


#### 1418D
- 显而易见的，一定是前面一段合并成了一个，后面一段合并成了一个。
- 分成两部分后，一定需要两部分各自的长度才能把它们合并，也就是省了交界处的那一段。
- 用 multiset 维护相邻两个数的差值，每次输出最大的，修改的时候更新 multiset 即可。


#### 1207F
- 500000，4s，根号算法是可以跑过的！！！
- $x\leq \sqrt n$ 的维护答案，$x\gt \sqrt n$ 的暴力计算答案。
- 维护答案就是修改后对 $x\bmod v,\forall v\in [1,\sqrt n]$ 给 $v$ 更新，暴力计算就是每次暴力往后跳 $x$ 求和。


#### 703D
- 出现奇数次的好算，就是区间异或和。
- 出现偶数次的就是所有的不同数字的异或和再异或上区间异或和。
- 离线下来，枚举 $r$，让 $r$ 及之前的相同的数字只有最后一个有贡献，就可以树状数组求了。$r$ 增大时把上一个和当前数相同的位置改为 $0$。


#### 1195E
- 先横向考虑，求出每个数之前 $b$ 个的最小值。再纵向考虑，求出每个数之前 $a$ 个数（刚才横向求出的）的最小值。
- 具体求前 $k$ 个数最小值的方法就是直接单调队列维护。


#### 915E
- 区间赋0/1区间求和。
- 线段树，可以离散化也可以动态开点。


#### 1265E
- 字母对括号序列没有影响，把它当成0。根据一般做法，`(`当1，`)`当-1。
- 还是一样，要求前缀和 $\geq 0$ 且总和为 $0$。
- 维护前缀和序列，修改的时候就对一个后缀做加减操作。询问就判断总和与最小值即可。


##### 707D
- 它是在某步操作后加，所以可以使用经典维护操作序列树的方法，对状态之间的关系连边，从 $k$ 操作过来的就把 $k$ 和当前连边。
- 那么，操作时可以轻易回退的，所以可以直接在操作序列树上递归，维护每行反转 tag 和矩阵即可，注意单点操作时如果有 tag 要变成和 tag 相反的。


#### 429D
- 变成前缀和 $f(i,j)=(i-j)^2+(pre_i-pre_j)^2$。
- 这个就是 $(i,pre_i)$ 的平面最近点对。
- 回忆一下，是一个分治算法，假设两边的最近距离为 $d$，选出 x 离中心轴不超过 $d$ 的点，然后在 y 离它不超过 $d$ 的且比它小的点（最多只有7个，因为 $d\times d$ 矩形两两距离 $\geq d$ 最多四个点）。


#### 1092D2
- 容易想到，要先把最小值的段都填高，那么得满足最小值的段的长度都是偶数。
- 其次为最小值的数都变大了 1，此时又要求原先最小值 +1 的段长度都是偶数。
- 依次类推，所以只需要判断任意 $x$ 是否满足 $\geq x$ 的形成若干个连续段，并查集合并即可。


#### 1156E
- 分治，从 $mid$ 分成两半，分别求后/前缀最大值。
- 然后枚举一个数，看满足条件另一个数的位置，然后判断最大值是否合法。


#### 1295E
- 最后是第一个序列都 $\leq x$，第二个序列都 $\gt x$。
- 那第一个序列中 $\gt x$ 的，第二个序列中 $\leq x$ 的都会需要花费对应 $a$ 的贡献。
- 维护两序列分界点固定时，每个 $x$ 的答案。用线段树维护区间操作即可。


#### 555C
- 发现无论怎么拆，都是三角形去掉最下面若干行和最右边若干列的形式。
- 拿 set 维护一下这些形状，每次操作就是一分为二，维护一下即可。


#### 1108E2
- 因为 $m$ 很小，把区间变成左闭右开的后离散化，只有剩下的两点间的最小最大值才有用。
- 枚举最小值所在的段，最大值所在的段（有个很好的性质是如果你枚举的不是真正的最小最大值答案只会更加劣）。然后尽量让最小值所在的段尽量小，若既包含最小值也包含最大值这个段选不选都一样。
- 所以可以发现只需要枚举最小值，然后选所有包含它的段，最后看剩下的最大值，更新一下答案即可。


#### 1208E
- 设总长为 $n$，这一行长度为 $m$，那么这一行对 $i$ 位置的贡献是 $[\max(1,m-n+i),\min(m,i)]$ 区间内的最大值。
- 在 $i$ 增大时两端点向右移动，且虽然 $i$ 取值为 $[1,n]$，但总共不同区间数量不超过 $2m$，即刚开始右端点在变化，之后不动，最后左端点在变化。只需要处理前后，中间的区间加即可。


#### 301D
- 比较经典，因为对数很少（$O(n\log n)$），可以直接把每一对处理出来。
- 现在就是求第一个数 $\geq l$，第二个数 $\leq r$ 的对数。
- 询问离线，排序，一个一个加入对，遇到询问树状数组查询即可。


#### 515E
- 去掉小孩子在的树之后就变成了一条链。
- 倍长原序列，从右到左移动左端点，每个位置维护 $2*h+i$，维护一个单调栈，询问的时候二分即可。


#### 1194E
- 枚举矩形上下边界，就要求竖着的满足能覆盖住的拿出来求一下。
- 枚举下边界的时候加入 y 坐标在下边界以下的竖着的，那么枚举完上边界就可以树状数组询问方案数。


#### 103D
- 一眼根号分治，小于根号的维护前缀和，大于根号的暴力做。


#### 1093G
- 曼哈顿距离最大，意味着只要每个维度两个数字的系数（1/-1）不同，求最大值就是答案。
- 枚举系数（2^k），求这种系数和另一种系数分别的最大值加起来即可。


#### 785E
- 单点修改，求区间比某个数大（小）的数字个数，应该用树套树（如树状数组套权值线段树）解决。
- （其实有一种经典的 $O(n\sqrt{n\log n})$ 的做法是分块，每块从小到大维护值，修改直接类似插入排序，询问就每块二分）。


#### 797D
- dfs一遍，求出如果到当前的点，那么可能的权值区间是什么。
- 那么当前点的权值能被搜到当且仅当在权值区间内，map标记一下。
- 最后输出有多少个点的权值没被标记。


#### 853C
- 和它不相交当且仅当至少完全在上下左右四个方向之一。
- 直接算在上下左右的方案会算重完全在左上左下右上右下的，要减去。
- 这个方案数类似于二维数点，离散化后一维枚举一维树状数组即可。


#### 1627E
- 从下到上，爬梯子可以直接转移过来。
- 同层之间的转移，可以从左往右先转移一次，从右往左再转移一次（要么往左要么往右）。
- 每层有往上/往下的梯子的格子才有用。


#### 461C
- 如果折过来没有覆盖掉全部，那么直接暴力折（维护当前还存在的左右端点）；如果覆盖了全部，那么暴力复杂度就错了，反过来让短的折过来，再记录一下现在翻转了。
- 查询区间和可以用树状数组。


#### 1625D
- 明显先要建 trie 树。
- 建完后递归，如果当前填 1 没有压下界那么左右子树可以分别递归，如果压了下界那么两个子树里分别最多选一个数，至于能不能选可以直接递归，原因是如果某个点有两个儿子如果都能走那么说明一个一定不压下界；如果只有一个能走那么直接继续递归。


#### 756C
- 可以认为开始所有位置都是空的，然后每次钦定某个位置是左括号或右括号（左括号有权值），问最后一个没匹配的左括号的权值。
- 由于括号序列一定合法，那么可以找最后一个位置使得后缀和 $\gt 0$，把单点操作变成前缀操作就可以求最后一个 $\gt 0$ 的数字了。


#### 1580C
- 直觉就是根号分治，时间短的暴力记录（有多少辆车在 $mod x=y$ 的天维修），时间长的可以直接在需要维修的位置上加（在 $mod x=y$ 的天加）。
- 删除的时候，时间短的直接在位置上减，时间长的在维修的位置上减。


#### 1250C
- 枚举 $l$，维护每个 $r$ 的获利加上 $kr$（最后再减去 $k(l-1)$）。
- $l$ 往右移动的时候把那些左端点在原先 $l$ 的区间删去即可。


#### 1252G
- 需要发现的一点是，这个和经典 $\geq x$ 一样，你只要记录有多少人能力值比你小，到某一年不够了那么就 got fired 了。
- 你知道每一年加入的人中比你小的个数，维护每一年结束前比你小的人数 $-r$，要求每一年都 $\geq 0$。
- 第一年就是初始比你小的人数 $-r$，之后每一年就是前一年加前一年新增比你小的人数 $-r$。
- 发现每一年都 $\geq 0$ 的条件等价于最后一年 $\geq 0$。
- 那么你就知道只需要求比你小的人数，拿个树状数组维护所有人即可。


#### 1045G
- 强制钦定以 $(r_i,i)$ 排序，然后变成一个静态二维偏序的形式，CDQ分治套树状数组即可。


#### 558D
- 求出询问区间对应的叶子节点，如果是yes就求个交，是no就和补集求个交（具体区间可以简单讨论一下）。
- 最后看点数，>1 就多解，=1 就输出，=0 就说明被修改了。


#### 877F
- 关键点是 $k$ 固定，那么对于每个 $r$ 可以求出满足条件的最近的 $l$。
- 维护之前的前缀和为 $x$ 的最后一个位置，枚举 $r$ 就能知道 $l$。询问的时候就是问有没有二元组被包含。
- 相当于 $l\leq x,r\geq y$，二维偏序即可。


#### 878B
- 段内你先消（$\bmod k$），然后中间的就没用了，只有两端的有用。
- 特判掉只有一种数的情况，此外两段接到一起可能可以合并（但也只限于前一段的右边和后一段的左边），更多的段也是一样，可以求出每加一个段可以合并多少。


#### 220C
- 这题的关键是它是一个排列。
- 每个数从距离每次+1到-1（或-1到+1）的变化只有一次，而每个数移动到最后也最多只有一次，可以拿set维护+1和-1的集合，要变化的暴力移动。


#### 803G
- 转换成左闭右开后离散化，相邻的之间如果包含了全部就是全体最大值，否则可以ST表查询。
- 操作就可以暴力线段树。


#### 895E
- 期望有线性性，可以直接维护每个数字的期望。
- 区间里的每个数字有 $\frac{1}{len}$ 的概率选到，然后另外一边选的值也是随机的，可以算另外一遍选过来的期望。
- 那么就是区间赋值。


#### 628E
- 考虑 Z 形第一个转折点，两边一个往左，一个往左下。
- 你求出能往左多少，往左的长度可以为 $i$，往左下的长度可以为 $i$ 且左下往右的长度可以为 $i$ 则合法。
- 往左往右可以的长度可以预处理，按对角线顺序处理往左下的，每次往右上走一个，一些就不行了（向右长度不够的），剩下的就求出不超过往左能走的长度里有多少个即可，可以维护树状数组。


#### 35E
- 这个题很诈骗，维护每一**段**的最大值，如果相邻两段的值不同就会新增两个端点。
- 离线区间覆盖可以直接离散化后 set 维护。


#### 420D
- 被移到最前面和最后面的数，你是知道它们的值的。
- 移动被移动到前面的数，如果值不一样，就无解。后面同理。
- 移动一个中间的数，相当于你确定了一个值。中间的可以使用树状数组维护还存在的下标然后二分（第一反应是平衡树，但是值域小可以用树状数组代替）。
- 然后你发现其实可以全部都用树状数组维护，每次把一个数移到开头/结尾就给一个最小/最大的坐标放着，记录一下它的权值，如果权值冲突就无解，否则最后位置还在初始位置的随便填即可。


#### 219E
- 一眼 set 维护每段左右端点。
- 注意存一下每一段到最近两点的距离最大值是多少（中间的段是长度/2下取整，两边的段是长度-1）.
- 加入点的时候找到所在段，删掉点的时候找到相邻段即可。


#### 38G
- 建立splay（维护正确的下标顺序）。
- 每次把当前 $>i-c[i]-1$ 的这一段（也就是顺序中最后这么多个数）拿出来，在里面插入当前的值（看右子树权值的最大值和当前的关系）。

#### 89C
- $nm\leq 5000$，意思是可以暴力模拟，只要能 $O(1)$ 找到下一个标记的位置。
- 这个可以把每行每列维护一个双向链表，求出下一个标记点就把当前点删除。


#### 1184C2
- **曼哈顿距离不超过某个值，先转切比雪夫距离**。
- 枚举一维 $x$，用数据结构维护另一维 $y$，$x$ 移动的时候把超过范围的那些点的贡献去掉，加入新的点的贡献。


#### 413E
- 没有修改，可以不用线段树，倍增可以代替。
- 设 $f[i][j]$ 表示 $i$ 往右走 $2^j$ 走到的两个位置分别需要的步数。
- 应该也可以分治，考虑经过中心的，分别求出两边到中心的，更新答案，再递归在两边的。


#### 228D
- $z$ 只有 $6$，可以对每个 $z$ 都维护答案。问哪个 $z$ 我就从那个数据结构找即可。
- 单点修改对所有 $z$ 都暴力修改即可。


#### 926J
- 在 set 里维护线段。
- 每次新加入线段的时候，不停的找和它有交的线段，与它合并，直到没有和它有交的线段。
- 找与它有交的先找 set 里二元组大小比它大的，如果没有交再看这个二元组的前一个。


#### 257E
- 如果没有“事件”（指有人上下电梯）发生，那么电梯的运行状态（向上/向下/停止）不变。
- 拿个 set 维护电梯里往上/往下的人，外面在上面/下面等候的人，当前的事件。
- 就看当前是哪个最早，是上电梯的事件早还是下电梯的事件早还是有人开始等候早。
- 由于每个人只会开始等候/上/下电梯各一次，所以复杂度是一个 $\log$ 的。


