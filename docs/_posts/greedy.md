---
title: '贪心'
date: 2022-01-04 19:32:11
tags: [贪心]
categories: [CodeForces2100-2300]
mathjax: true
---

1372D,1370E（#）,1299C,1621D（#）,1399E2,1266E
351E,1621E,645E（#）,362D（#）,730E
852C,819A,203E,1431G（严谨正确性证明？）


#### 1472F
- 从左到右考虑每一列， 确定了前 $i-1$ 列，那么现在的第 $i$ 列哪些被覆盖就确定了。
- 可以求出第 $i$ 列覆盖的方案：如果没有空格/只有一个空格，则只能放横的；否则两个都是空格，一种是放两个横的，一种是放一个竖的，可以发现放两个横的和放两个竖的等价，不如变成放竖的，其它的之后再决策。
- 所以就变成，只要这一列没满，就横着放，否则竖着放。
- 有一种离谱情况，它是第一行放(1,2),(3,4),...，第二行放的是(2,3),(4,5),...，类似于这种就必须横着放。
- 那么你就可以O(m)模拟，你这一列覆盖完之后就知道后面的是上下两行差1的情况还是可以直接竖着放。
- 从有障碍的一列到后一个有障碍的一列，中间快速跳。

#### 1367F
- 我们直接来做F2。首先可以离散化，然后发现每个数最多操作一次，不然你可以只操作最后的那一次。
- 根据经典套路，你把不动的拿出来，一定是个递增序列，剩下的也得能归位（比最小值小或比最大值大，也就是>最小<最大的必须本身在序列内）。
- 直接设 $dp[i]$ 表示 $i$ 选了且是最大的最长长度，$a[i]=x$。一种从之前的最后一个 $x$ 转移过来；一种是选所有的 $x-1$（必须在 $i$ 前面），再从第一个 $x-1$ 转移过来；还有一种是选*之前*所有的 $x-1$。
- 分别求出来转移即可。

#### 1373E（#）
- 考虑 $x+k$ 进没进位。
- 如果没进位，枚举最后一位，之前的位贪心（尽量填9）。
- 如果进位了，枚举最后一位和之前连续的9的长度，计算一下，再贪心（先填一个8，再尽量填9）。

#### 1530E（#）
- 如果只有一种字符，那只有一种方法，直接结束。
- f为0：如果有某种字符只出现一次，那么拿最小的只出现一次的字符当开头，其它的从小到大往后排（不可能拿出现果不止一次的字符，那会使得f至少为1；也不可能取更大的字符，那字典序更大）。
- f为1：现在所有字符都出现至少两次（这种情况答案一定不为0，不妨假设a出现了），想让字典序尽量小，先考虑有没有可能是以aa开头，那么之后就不能有两个相邻的a（否则f至少为2），只能形如aababa…ca…。可以发现a的个数最多为其它数字个数+2，即cnt>=n-cnt+2，cnt>=n/2+1。
  如果不满足条件（不妨假设b出现了），考虑开头为ab，那么之后就不能再出现ab，如果只有两种字符，那么b一定要出现在a前面，即abbb…baa…a；如果有更多字符（不妨假设c出现了），那么可以为abaaa…acbbb...bccc…c…，即ab之后填所有的a，再填c，剩下的从小到大填。

#### 1254B2（#）
- 只需要考虑 $k$ 是质数的情况。
- 其实 $a_i$ 和 $a_i \bmod k$ 是完全等价的（不会出现负数啥的情况），那么前面往后移和后面往前移也是等价的，计算一下答案即可。

#### 576C（#）
- 按照莫队的方法奇偶排序即可。

#### 547A（#）
- 你先暴力跳，把第一个跳满足，如果跳了 $m$ 次还不满足就无解。
- 如果此时第二个也满足就直接结束。
- 否则你让第一个就再跳一个环回，跳回来，记录此时第二个乘的x和加的y。
- 之后再跳第一个就不变了，依旧暴力跳，不超过m次。

#### 1253E
- 对于原问题，可以加入一个 [0,0] 的区间，这样不会影响答案（可以把第二个区间多扩展这个区间的范围）。
- 设 $dp_i$ 表示只用中心不超过 $i$，覆盖 $1..i$ 的最小代价。有了 $[0,0]$ 就不存在不能覆盖的问题了。
- 如果原先覆盖了 $i
  $ 那么从之前没覆盖的第一个位置转移，否则直接考虑之前的某一个扩展到 $i$，再从左端点之前转移过来。
- 但是你可以扩展得更长，多覆盖左边的一点，这样就很麻烦了。但是 $dp_{i+1}\leq dp_i+1$，你可以把之前的区间增加 $1$。

#### 1316E
- 排序，变成 $a_i$ 从大到小排序。
- 范围很小，直接状压 $dp$ 记录到哪一个，之前队伍有了哪几个位置（状态），有多少名观众。
- 如果当前放进队伍就枚举放哪个位置，不放进队伍如果观众不够就当观众，否则就不参加。

#### 1296F（#）
- 显然要满足 $u,v$ 路径上的边权都 $\geq w$。
- 路径取 $\max$ 后判断是否合法即可。

#### 1334E（#）
- 考虑路径会长成什么样，直观的想法是先除后乘一定严格比先乘后除优，不妨反证。考虑从x到x*p/q。
- 设p,q为两个不等质数，先乘后除：-d(x)+d(xp)+d(xp)-d(xp/q)，先除后乘：d(x)-d(x/q)-d(x/q)+d(xp/q)
- 要求-d(x)+d(xp)+d(xp)-d(xp/q)<=d(x)-d(x/q)-d(x/q)+d(xp/q)，整理得2d(x)-2d(xp)+2d(xp/q)-2d(x/q)>0.
- 都除以2，移项变成d((x/q)p)-d(x/q)>=d(xp)-d(x)，可以知道，*p之后增加量应该数字除去所有p之后，剩下的因子数，(x/q)|x，这个式子一定不成立。（为啥不考虑p=q呢，因为边权一定为正，没必要从x到x）。
- 所以一定会先除后乘，否则可以交换顺序。那么可以变成x一直除，y一直除，到达同一个点。
- 由于你只是除，那么路径上的中间点的权值都会删去，所以路径长度一定是d(x)-d(目标点)。
- 那么答案是d(x)+d(y)-2d(目标点)，x,y都能到达的点只能是g=gcd(x,y)的约数，可以发现g的约数中，g本身的d(g)是严格最大的，所以目标点也固定为g。答案就是x到g的方案数*y到g的方案数。
- 相当于要求一个数x，每次除一个质因数，有多少种不同的方法，那么就用tot!/(p1!p2!...pk!)算算多重组合。
- 由于题目说了给的都是D的约数，先求出D的所有质因子，询问的时候就可以O(log V)解决。

#### 1384B2（#）
- 称无论什么时候在当前位置都是安全的点为安全点，否则为不安全点。显然不安全点能走的时间是一些区间。
- 若当前点为安全点且下一个点也是安全点，直接走过去即可；
- 若当前点为安全点且下一个点不是安全点，则在最优的时间走过去（递减且正好能走过去）。
- 若当前点不为安全点且下一个点是安全点，直接走过去即可；
- 若当前点不为安全点且下一个点不是安全点，则只要能走过去且不死就走过去，一直不走必定会死，能跑路就赶紧跑路。

#### 549G（#）
- 继续寻找不变量，$a_i+i$ 总是不变的。
- 初始的 $a_i+=i$，条件变为：$a_{i-1}\geq a_i$ 的话交换 $a_{i-1},a_i$。
- 如果有相等的显然最后会一直交换，否则最后会排序，再 $-i$ 输出即可。

#### 825E（#）
- 你直接按照顺序拓扑排序，把小的给编号小的，求出的是答案对应的逆排列最小。（编号小的其实是越早经过越优）。
- 非常有意思的一点是，你如果建反图，尽量把大的给编号大的，这样求出的就是答案最小。（现在越早经过反而变成越劣，反过来了）。

#### 1411D（#）
- 把贡献分成几种情况，0和1，?和1，0和?，?和?。
- 可以知道，把序列分成若干部分，它们之间形成的01/10子序列和内部顺序无关。
- 考虑?...?，它们和外部的贡献和顺序无关，和0,1出现次数有关。如果?替换从0,0或1,1的出现次数不同。
- 替换成0,1和1,0出现次数相同，内部的贡献比较变为0...1和1...0哪个大，设中间的...有a个0，b个1，那么0,1的贡献是(a+b+1)x，1,0的贡献是(a+b+1)y，看x,y哪个大变成哪个即可。
- 不妨设x比较大，所以?填的一定是前面若干个0，后面若干个1，枚举前面多少个填0，可以计算出?和?，而其它三种预处理即可。

#### 1154F
- 可以发现一定选最便宜的 $k$ 双，因为如果选了 $x$ 有一个更小的 $y$ 没选，那么如果本身 $x$ 被免费，那么换成 $y$ 之后一定也免费；如果 $x$ 不免费，一种是换成 $y$ 之后也不免费，一种是换了变免费了，那么有一个变收费了，变收费的一定比 $x$ 小，总代价也变小。
- 排序。总和固定，你希望免费的鞋的钱的价格尽量高，所以你会成段成段的买。
- 然后dp，枚举最后一次买了多少双鞋，计算一下代价。

#### 1535E
- 这题关键在于：
  1. 保证 $c_i>c_{p_{i}}$，所以删的一定是到根路径上的前缀；
  2. 操作是有后效性的（永久的）。
- 删的一定是到根路径上的一个前缀，删除的时间可以均摊。
- 怎么找最上面的点？考虑倍增（主要是方便在线加点），找到最上面没被删的点即可。

#### 1154G（#）
- 拿个桶记录每个数有没有出现过。
- lcm可能很大，但lcm(a,b)=ab/gcd(a,b)，考虑枚举gcd和它的倍数，求两个最小的出现过的更新答案即可。

#### 1556E
- 可以发现，设 $c_i=b_i-a_i$，那么就变成选出下标递增的 $k$ 个位置 
  $-1,+1,-1,+1,...,-1,+1$，要求所有数都是 $0$。
- 显然和不变，所以和必为 $0$ 才有解。根据经典套路，做个前缀和还是要求所有数都是 $0$，就变成区间 $-1$（最后一个数不能动，也说明和必须为 $0$），如果原先有负数显然无解。
- 由于每次可以任意选区间，所以答案就是最大值。
- 先全局做一次，维护一下区间最大最小值，再都减去 $l-1$ 的前缀和，如果最小值 $<0$ 则无解，再判断 $r$，如果是 $0$ 也无解，最后再输出最大值。

#### 1494D（#）
- LCA 的权值为最大值的，说明它们 LCA 为根。
- LCA 的权值不为最大值的，说明它们在根节点同一子树。
- 递归下去即可。

#### 1557D
- 设 $f_i$ 表示 $1..i$ 行能选出多少行使得选出的数量最多（第 $i$ 行必选）。
- 如果第 $i$ 行和第 $j(j<i)$ 行能相邻，$f_i$ 就可以从 $f_j+1$ 转移。
- 判相邻就看是否有一列相交，不妨转变思路，直接把有第 $x$ 列的放到线段树上取最大值，求 $f_i$ 就在 $i$ 有的区间上取最大值即可。
- 答案是 $n-\max f_i$。

#### 1605D
- 首先看条件 $u \oplus v\leq min(u,v)$，不妨设 $u<v$，如果 $u,v$ 最高位不同，那么 $u\oplus v$ 的最高位就是 $v$ 的最高位，比 $u$ 大，矛盾。如果最高位相同，直接异或掉了，一定满足。
- 所以条件就变为 $u,v$ 最高位相同。由于是轮流操作，你还可以把树黑白染色。
- 显然所有点都不能动的构造最大。看黑白两边的节点个数 $x,y$，不妨设 $x\leq y$。
- 最高位不同的数之间相互独立，把 $x$ 二进制分解，最高位是那些的都放到 $x$，剩下的都放到 $y$。
- 那么所有点相邻的都没有同最高位的，所以都不能走。

#### 1175E
- 用一个区间覆盖第 $i$ 个点，假设之前都覆盖了，那么右端点一定越靠右越好。
- 求出覆盖第 $i$ 个点的右端点最右的区间，扫一遍取 $\max$，建边指向右端点右边那个点。
- 现在变成一个森林， 从 $l$ 开始跳几步才能 $\geq r$，倍增即可。

#### 1271D
- 对于一个城堡，你一定尽量晚的放士兵，因为如果你之前不放后来放， 影响是中间那一段时间军中的人数增加 $1$，不会更劣。
- 由于你会走过每一个城堡，记录哪些是在这个城堡才会选的驻守方案，如果不往那些驻守之后就守不了了。
- 直接二维 $dp$ 记到哪一个还有多少人是一定可以的。不这么做，考虑带悔贪心。
- 因为你必须走到底，所以你可以先在最后能驻守的时候先驻守，行军人数不够就反悔把之前的抽出来，但是你走过去之后，就不能把这些人放回去了（他们必须跟过来），所以复杂度是对的。

#### 1220E（#）
- 因为保证了图连通，考虑拓扑排序。
- 排序完之后剩下的还在图中的，它们一定可以一次走完并且停在任何一个点。
- 就分进入环还是不进入环的情况，可以（对被删去的点）处理一个f数组表示从度数为0的点开始到这个点的最大权值，同时更新不经过环的答案，最后把不删的点之和+f的最大权值。

#### 1404C（#）
- 如果询问的是整个序列，那么每次删除最后一个满足 $a_i=i$ 的位置即可，把删除顺序记作 $b_i$。
- 询问的不是整个序列，找第一个 $b_i<x$，在之前的 $b_i\leq y$ 的都对答案产生了 $1$ 的贡献，计算即可。

#### 1511E
- 横着的和竖着的是独立的，横/竖的极长连续段之间也是独立的。
- 如果有一段长度为 $x$ 的横/竖的极长连续段，设它的答案为 $f[x]$，那么对应的贡献为 $f[x]*2^{tot-x}$（$tot$ 是总白色格子数量，即剩下可以任意选）。
- 考虑 $f[i]$ 的转移：
  
  1.  $i$ 位置是另一种颜色，从 $f[i-1]$ 转移过来；
  
  2.  $i$ 位置是这种颜色，$i-1$ 不是这种颜色，从 $f[i-2]$ 转移过来；
  
  3.  $i$ 位置是这种颜色，$i-1$ 也是这种颜色，从 $f[i-2]+2^{i-2}$ 转移过来（后面加的是之前的方案数）。
- 横竖都算一边加起来即可。

#### 1029E（#）
- 看上去比较像贪心，首先新的边一定一端是1，否则不优（你是要减小最短路，看减小的是哪边，不妨把另一边换成1）。考虑哪些点的策略一定是固定的。
- 考虑一个还不满足条件的叶子节点，那么一定要把它或它的父亲和1连边，连谁比较优呢。
- 发现一定会连它的父亲，它父亲会使得满足条件的更多，且除了它本身以外其它点的最短路更小。
- 对于满足条件的叶子节点，可以发现能把其删掉，选它也不如选它的父亲。
- 所以你每次选一个深度最深的叶子节点做，然后删去，更新它父亲的深度。

#### 767B
- 你考虑，如果你要在前面一些老哥之后，这个老哥之前， 那么你在之前的任何时间点来和后面这个老哥来的前一秒来是没区别的。
- 所以你就对于每个老哥，看在这个老哥前一秒来要等多少时间（等不等得到，$now+m>T_e$ 就等不到了）。之前要占多少时间可以直接拿个数字记录，即之前的人都走完需要多久，减一下更新答案。

#### 1415E（#）
- 相当于分成最多k+1个序列，每个序列再按照顺序计算。
- 可以贪心考虑，显然分出的每个序列都是从大到小排序最好。
- 用堆维护每个序列当前的和，找到最大的序列加上当前的数。

#### 679B
- 考虑能不能变成规模更小的子问题。
- 求出最大的 $x$ 满足 $x^3\leq n$，那么最后答案中，第一步取的一定不超过 $x$。
- 如果第一步取 $x$，那么剩下的可以是 $[0,n-x^3]$ 中的任何数（初始在 $[x^3,n]$）。
- 如果第一步取 $x-1$，那么剩下的可以是 $[0,x^3-1-(x-1)^3]$ 中的任何数（初始在 $[(x-1)^3,x^3-1]$）。
- 初始取比 $x-1$ 更小的一定不如取 $x-1$，剩下的范围更大。
- 那么也就是说能递归到 $\max(n-x^3,x^3-1-(x-1)^3)$ 的子问题，$n$ 的答案是它的答案 $+1$。
- 不过比较低素质的是相同的情况下让体积最大，所以你求出答案之后还得看到底取哪边可以，都可以就尽量取大的。
- 这个递归复杂度是 $O(n^{\frac 13})$。

#### 1528C
- 可以发现，第一棵树取得一定是祖孙链。
- 在两棵树上都保证了 $fa_i<i$，所以你枚举第一棵树的祖孙链的时候，如果第二棵树的这个点和之前的点（最多只有一个）有祖孙关系，一定用这个点替代之前的点（$dfs$ 序的区间严格被之前的包含）。

#### 1396C
- 由于 $r_1\leq r_2\leq r_3$，而手枪和AWP都只能打一只怪物，所以AWP只可能用来打BOSS。
- 如果用手枪一只一只打小怪，最后一定是一起把BOSS一起解决了（不解决放着之后需要的时间不会更少）。
- 如果用激光枪，那么打完一定要走，如果之前 $i-1$ BOSS也没死，就去打 $i-1$，否则打 $i+1$（你之后还得打 $i-1$ 的BOSS，不如现在先去了）。
- 不过即使你用手枪打， 如果 $i-1$ 的BOSS没死，你打完后一定也是先去 $i-1$，之后再折返一定不优。
- 所以说，假设 $i$ 之前的怪全都死了，一种是你用手枪+AWP解决，到 $i+1$；另一种是用激光枪/手枪给每个打一枪，然后到 $i+1$，再用任意方法（都打一枪或直接解决），再回到 $i$，手枪一枪打死BOSS，又到 $i+1$，如果BOSS没死也一枪打死，最后到 $i+2$。
- 所以一种是新增 $a_i\times r_1+r_3+d$ 的代价走到 $i+1$，一种是新增 $\min((a_i+1)\times r_1,r_3)+r_1+\min(\min((a_{i+1}+1)\times r_1,r_3)+r_1,a_{i+1}\times r_1+r_3)+4d$走到 $i+2$。
- dp即可。

#### 675E
- 从后往前维护后缀最大值（是指 $i..j-1$ 中的所有值都比 $a[j]$ 小）。
- 那么你从这个点开始， 走到的点一定在这个点开始的后缀最大值的集合内。
- 而且，后缀最大值也不一定会出现，如果这个点能直接走到下下个点，那么下一个点也没用了。
- 用单调栈维护这个集合，同时维护这个集合中的位置之和来计算答案。

#### 1202C
- **行列独立**，分别处理，以行为例：先求不操作得到的最小/最大值。
- 现在要让最大值-1（或最小值+1）,显然当当前值第一次等于最大值（最小值）的时候必须是有-1（+1）。
- 然后更新操作后的最小最大值，列同理。再计算一下。

#### 1203F2
- 同F1，加血的没区别（按照 $a_i$），扣血的你利用调整法，发现也差不多，按照 $a_i+b_i$ 的顺序从大到小。
- 加血显然能加就加，扣血的现在可以选择扣不扣，跑个背包即可。

#### 1108F（#）
- 和MST有关的，很多贪心都是对的。。。
- 随便取一棵生成树，不妨假设最后留下的就是这棵生成树。
- 那么你对于剩下的非树边，和树边一定形成了一个环，它不能替换环上的其它边，即要比其它边都严格大。
- 考虑边kruskal边计算答案，发现后面加入的边如果需要增加当且仅当在加入同权值的边之前是不连通的，加了同权值的边后连通，为了不让自己替换那条边所以要+1。
- 同权值的一起计算即可。

#### 754D
- 按照左端点从小到大排序。
- 把右端点加入小根堆，每次弹堆顶保证不超过 k 个数。
- 如果有 k 个那么用最小值-当前左端点+1更新答案。

#### 1152D
- 你考虑类似二分图匹配，左部是深度为奇数的点，右部为深度为偶数的点。
- 答案不超过两部大小较小值。容易构造出答案为左部大小的答案， 即每个深度为奇数的点选一个儿子（一定能选出）。
- 按照左端点从小到大排序。
- 把右端点加入小根堆，每次弹堆顶保证不超过 k 个数。
- 如果有 k 个那么用最小值-当前左端点+1更新答案。

#### 976E
- 明显*2只给同一个人最优。
- 剩下的一定是选替换掉新增的贡献最大的若干个。
- 排序求一下即可。

#### 1398E（#）
- 设电的数量为x。可以发现，理想的情况是你给最大的x个翻倍。
- 但是有可能不行，因为可能最大的x个都是电，这样一定有一个翻不了，可以发现一定不翻最小的。
- 而且，如果最大的x个中有火，你就从一个不用翻的电开始就可以了，此时一定没有最小的电。
- 所以无论什么情况，都不会翻最小的电。你要求的是答案尽量大。
- 如果x大有火则为S+S1，否则为S+S2-M（S为所有和，S1为前x大和，S2为前x+1大和，M为最小的电）。
- 可以用set维护前x+1大，相同的认为火更大。

#### 708C（#）
- 以你要的点为根，你要让所有子树都<=n/2，如果本身满足就不用操作，否则你需要在>n/2的子树里找到一个<=n/2的最大子树拿出来直接接到根上，如果拿出了这个子树之后就<=n/2了的话就OK。
- 考虑固定了根怎么求，可以dp，设dp[u]表示u子树里最大的<=n/2的子树，转移就是看所有儿子，如果size不超过n/2就用size转移，否则用dp转移，取个最大值。
- 只记最大的其实也不行，因为你要换根，换根了之后就要把某个儿子的贡献去掉，所以记最大的和次大的，如果往最大的子树换根则这个点的值变为次大的，否则就是最大的。

#### 767D
- 一组牛奶可以当且仅当 $i$ 天内过期的牛奶不超过 $k\times i$ 瓶。
- 一定会买保质期最长的若干瓶， 把商店里的牛奶按保质期从大到小排序。
- 现在考虑到第 $x$ 瓶牛奶，维护后面前缀和-$k\times i$ 的最小值，就能知道这瓶牛奶放不放的下，放不下就结束，否则就放，最小值-1，到下一瓶牛奶更新中间的最小值。

#### 1537F（#）
- 这种就考虑生成树或二分图。按照经典套路，每次加或减的都是一个偶数，所以如果和的奇偶性不对显然无解。
- 可以发现，能把两个距离为奇数的位置一个+1一个-1，能把两个距离为偶数的位置都+1/-1。
- 如果有奇环，因为原图连通，故任意两点都存在长度为奇数/偶数的路径，故一定有解。
- 如果没有奇环，那么是二分图，那么左部之和减右部之和不变，判断一下即可。

#### 1213F（#）
- 如果 $p_{l..r}$ 形成的可重集= $q_{l..r}$ 形成的可重集，那么可以使用同一种字符来填。
- 固定了 $l$，那么尽量选最小的 $r$，直接贪心往后选，如果相同就分段。
- 这样可能使得字母不够用，那么把字母比较大的都变成 $z$ 即可。

#### 1461E（#）
- 开始的时候k在[l,r]内。分类讨论。
- 如果x>=y，一天过后水不会变多，第一天特殊考虑，剩下每一天一定会加水（尽量大，一定不会超过r）。
- 如果x<y，那么就是一直倒水直到再倒要   <l了，就加水。看上去这种复杂度很高，不过可以发现，再倒要<l的状态只有x种，即l,l+1,…,l+x-1，如果出现环（即状态重复出现）那么就一定能无限进行下去，否则每个状态最多遍历一次，复杂度O(x)。

#### 1477C（#）
- 如果构造的方案存在钝角∠ABC，那么根据大边对大角，AC一定严格比AB和BC长。
- 所以如果AB比AC长就不存在这个问题，每次取离A最远的B即可。

#### 1201D
- 可以发现，最后一定是在一行了里面走，然后向上，再走，再向上。
- 可以发现一行里停的一定是当前行最左/最右的障碍，你没有必要取完最后一个障碍后还移动，这不如走上去后再移动。
- 把中间空余的行删去， 然后从下一行到上一行，一种是先往左后往右，一种是先往右后往左， 都计算一下即可。
- 方便起见在第一行加 $(1,1)$ 当宝藏。 

#### 990E
- 枚举第 $i$ 种用来power。
- 那么你每次为了尽量不重复，一定会选择不超过 $now+i$ 的尽量靠后的非障碍位置。
- 先判断最长的连续障碍段长度，否则你每个障碍最多回退一步，相当于每次不超过 $(n+m)/i$，可以通过。

#### 1216F
- 设 $dp_i$ 表示恰好覆盖了不超过 $i$ 的最小代价。
- 那么覆盖 $i$ 应该从 $i-k$，求 $[i-2k-1,i-1]$ 的 $dp$ 最小值转移过来即可（单调队列）。
- 注意需要 $dp$ 到 $n+k$。

#### 1385F
- 你找到深度最深的（叶子）节点，看它的父亲，如果为叶子的儿子个数 $\geq k$，就删。
- 如果没有 $k$ 个，那么它的父亲就没救了，包括所有儿子无论如何都不行。

#### 1166D（#）
- 你考虑前缀和，$x_i=S_{i-1}+r_i$，那么 $S_i=2S_{i-1}+r_i$。
- 那么你要 $S_{n-1}+1<=b<=S_{n-1}+m$。
- 你先让 $S$ 尽量小，然后再反过来加大，先给 $S_{n-1}$ 加大同时满足条件，把剩下的给 $S_{n-2}$，再不停的往前推。

#### 1583E（#）
- 根据经典套路先求一棵生成树。询问给路径上的边都+1，这个和路径具体是什么有关系。
- 考虑设f[u]表示u相邻的边之和的奇偶性，这个和路径具体使什么没关系，一次操作给两端点都异或1。
- 如果最后存在f是奇数显然无解，否则叶子节点的那些边已经合法，那么推到他们父亲连到父亲的边也合法，一直推可以说明所有的边都合法，即只需要取一棵生成树，合法的依旧合法。

#### 1335F（#）
- 如果两个机器人走到某一步在同一个格子，那么继续走下去还会在同一个格子。
- 它要求一直走下去，而走nm步后一定会进入环，所以只需要要求走nm步之后不在同一个格子即可。
- 现在要求走nm后到哪个位置，这个可以用倍增（也可以对于每个环倒着处理到这个环的点，不带log）。
- 能到达某个格子的多个位置，如果有黑色尽量选黑色，否则任意选。

#### 1453E
- 观察一下它走的路径，容易发现进了一棵子树一定是走完了再出来，这个容易归纳证明。
- 你最后退出时走的那个子树，要增加一些从当前根出去的距离，所以一定是 $dp$ 最小的子树，子树之间走的一定是最大的。而根节点需要特判，你可以只走次大的，最大的走完直接结束。

#### 650C（#）
- 同行/同列值相同的位置最终值也会相同，先用并查集并起来形成一个等价类。
- 现在一行里等价类按照权值小向大连单向边，代表大小关系，可以发现只需要连大小顺序相邻的。
- 最后需要的步数至少是DAG最长链长度，可以构造每个点的权值为0度点到当前点的最长链的长度达到下界。

#### 623B（#）
- 还是一样，考虑最后的素因子（每个数都是它的倍数）。
- 如果一个数不变,+1或-1都不是它的倍数，那么就必须在区间内。
- 如果有必须在区间内的数，求它们最小和最大的位置，它们之前的一个后缀，之后的一个前缀也可以在区间内，计算一下。否则任意一个数都能在区间内，一个前缀和一个后缀不在区间内，计算一下前缀后缀。
- 对于原问题，由于不能删完，所以第一个数或最后一个数一定保留，它必须是它们不变,+1,-1中某个的素因子，这样只有两位数种方案，分别判断即可。

#### 1413E（#）
- 发现如果a>bc，那么他无论怎么恢复都不如减的多，答案是无穷大。
- 否则a<=bc，不妨假设0时刻你就攻击，到a/b上取整时刻，减的就比加的多了，不如第一个不做。
- 所以只需要考虑到[(a-1)/b]时刻，那么你一定是能攻击就攻击，在[[(a-1)/b]/d]次操作后达到最大值。
- 计算一下答案即可。

#### 748D（#）
- 一定是中间一个回文串（或者没有），然后左边是若干个s，右边是若干个rev(s)。
- 对于代价和为正的非回文原串和反串一定选，代价和为正的回文原串和反串先选。
- 最后看看要不要拿掉选的回文串对中的较小值或加入未选回文串的最大值。

#### 912D（#）
- 显然期望可以拆开，变成期望最大的k个位置的和。
- 对于(x,y)，能覆盖它的渔网数量=(min(x+r-1,m)-max(x,r)+1)*(min(y+r-1,m)-max(y,r)+1)。
- 那么两维相对独立，求出(min(x+r-1,m)-max(x,r)+1)的所有x的取值从大到小排，对于y同理。
- 然后可以使用堆贪心，因为u[1]*v[1]>u[2]*v[1],u[1]*v[1]>u[1]*v[2]，取出前k个即可。

#### 486E（#）
- 判断一个数能不能在LIS上：求出以每个数为开头/结尾的LIS长度，看看加起来-1是否等于最长的LIS长度。如果等于，那么说明它在LIS上，且位置固定（它一定是LIS上第x个位置）。
- 判断一个数是不是必须在LIS上：看LIS第x个位置有没有多种选法，如果有就不必须在，否则必须在。

#### 884D
- 倒过来变成合并，每次把两堆或三堆合并成一堆。
- 显然合并三堆是更优的（类似三叉哈夫曼树），但是可能合并不完，因为每次是3->1，减少两个，如果初始有偶数堆最后会剩两堆。
- 发现不如初始先合并最小的两堆，再做。

#### 1292C
- 推式子，它这个是个排列，
  
$$
  \begin{aligned}
&\sum_{1\leq u\lt v\leq n} \operatorname{mex}(u \rightarrow v)\\
=&\sum_{1\leq u\lt v\leq n} \sum_{i\geq 1} [\operatorname{mex}(u\rightarrow v)\geq i]\\
=&\sum_{i\geq 1} \sum_{1\leq u\lt v\leq n} [\operatorname{mex}(u\rightarrow v)\geq i]
\end{aligned}
$$
  
  也就是有多少 $(u,v)$，使得路径上包含 $0..i-1$ 的所有数。 
- 那么首先 $0..i-1$ 要在同一条路径上 $i$ 才可能计算答案。
- 其次如果固定 $i$ 满足条件（$0..i-1$ 在同一条路径上），那么最理想的方案是两端有一个 $i-1$，这样到 $i-1$ 可以删去一个数。所以一定是初始有一个 $0$，然后从小到大，往链两端加入一条权值为 $i$ 的边，贡献是两端子树大小乘积。
- 求出这个子树大小，然后倒过来递归，每次删去两端的一端，递归下去。
- 状态数 $\mathcal{O}(n^2)$，转移 $\mathcal{O}(1)$，记忆化搜索即可。

#### 1251E1
- 直接来做 E2。
- 按照 $m_i$ 从小到大排序，有个朴素的想法是设 $dp[i][j]$ 表示考虑完前 $i$ 个，$i+1..n$ 还有 $j$ 个被贿赂的最小代价。
- 转移第一种是 $i+1$ 被贿赂，就转移到 $dp[i+1][j-1]+q_{i+1}$；第二种是没被贿赂，那么要求 $i+j\geq m_{i+1}$，转移到 $dp[i+1][j]$。这足以通过 E1。
- 发现 $i+j\geq m_{i+1}$ 可以移项成为 $j\geq m_{i+1}-i$，也就是一个人跟风为你投票当且仅当后面被贿赂的人数 $\geq m_i-i+1$。
- 把 $m_i$ 相同的放在一起，倒过来考虑，设当前 $\geq m_i$ 被贿赂的人数为 $cnt1$，$<m_i$ 的人数为 $cnt2$，相当于现在一定有 $cnt1+cnt2$ 个人投票，如果够了，那么能全部都选；否则不够，就需要在 $\geq m_i$ 里的再贿赂一些，显然贿赂的越少越好（如果不够之后可以再贿赂），就贿赂直到 $cnt1+cnt2$ 足够，拿个小根堆存一下。

#### 723E（#）
- 显然度数是奇数的永远不可能合法。
- 如果只有度数为偶数的点，根据套路，可以考虑**欧拉路**，恰好有n次进入n次退出。
- 如果有部分度数为奇数的点，考虑把它们度数也变成偶数，即加一个新点连向所有度数为奇数的点。这样所有度数为偶数的点都合法。

#### 1236D
- 它的起点在左上角，所以你一定是越绕越小的螺旋形。假如你直走也可以走，右转也可以走，此时你必须直走，因为如果你转弯了，你就再也绕不出来了。
- 暴力复杂度一定是对的，你每转2次两维必定都减少1。维护一下四个方向的边界，不能超出。最后为了防止不出现没走到的，判断一下走过的格子数量是否为非障碍格子数量。
- 你找下一个停下的位置，需要二分下一个障碍的左端和方向边界取较小值。

#### 1028D
- 保证数字互不相同，ACCEPT给你提供了一些信息，即 $<x$ 的都在 $A$，$>x$ 的都在 $B$。
- 维护一定在 $A$ 中数字的最大值 $u$ 和一定在 $B$ 中数字的最小值 $v$，和所有数的 $set$。
- 如果ACCEPT的时候问的值比 $u$ 小或比 $v$ 大，就挂了，没有方案。否则如果这个数 $>u$ 且 $<v$ 那么不确定在哪个集合，方案数 $\times 2$。现在就能更新 $u,v$ 了，$u$ 是 $<x$ 的最大的数，$v$ 是 $>x$ 的最小的数。
- 结束时还要乘上 $u,v$ 之间的数字个数+1，可以选一个前缀给 $A$，剩下的给 $B$。

#### 618D
- 从简单的入手讨论。
- 如果 $y\leq x$，那肯定尽量走 $y$ 边。你发现除了菊花图比较憨憨删去之后直接不连通了，其它情况一定可以都走 $y$。因为你考虑生成树是一个二分图，你如果两部有连边 $(u,v)$， 你可以在左边乱跳，然后停在 $u$，再到 $v$，最后在右边乱跳。
  
  所以如果树不是菊花，那么答案是 $(n-1)y$，否则是 $(n-2)y+x$。
- 如果 $x>y$，如果你选了 $a$ 条 $x$ 的路径，那么需要 $a$ 条 $y$ 把它们接起来。相当于要求树的最小（点）路径覆盖，树形dp即可。

#### 242D（#）
- 这什么垃圾翻译。。。
- 和某题差不多，你每次找到一个cnt_i=a_i的，点一下，那么它以后再也不会不合法。
- 你最多把每个都点一次，所以一定有解。

#### 804C（#）
- 先给1号点上的所有种类染色。考虑现在到点u，这个点上还有些种类没被染过色。
- 这些没被染过色的，可以给它们分配和u中染过色不同的，且两两不同的颜色。
- 尽量分配编号小的颜色，种类数应该是每个点上种类数max，可以发现没有比这样更少的方案。

#### 980E
- 从大到小贪心，$n$ 必须要选。
- 其它的从大到小贪心，能保留就保留。
- 保留即路径上的都得保留，判断一下路径上点的数量。 
- 树状数组维护dfs序，删点就直接暴力，树状数组给子树-1。

#### 732E
- 把电脑扔进multiset，把适配器排序贪心。
- 具体来说就是枚举除多少次，如果有就和multiset里的配对，删除。

#### 1179C（#）
- 从大到小枚举最后剩下来的值x看看可不可行，可行当且仅当a_i>=x的个数严格大于b_i>=x的个数。
- 现在你要带修改，且要快速询问， 保存a_i>=x的个数-b_i>=x的个数，求最靠右的>0的位置。
- 维护线段树，每次看右儿子的最大值，如果<=0就到左儿子，否则到右儿子。

#### 520D
- 维护一个大根堆一个小根堆，里面是能拆的方块。
- 拆了之后向四周扩展，把那些能拆的也加进去。取了的用 map 标记一下。

#### 1616E
- 这题在现场。先求LCP，如果有前面大于后面就直接输出1.
- 否则你一定是两种情况之一：替换一个比它小的；替换一个和它一样的。
- 比它小的直接计算即可，维护后面每种字符的位置；一样的要移过来，维护个vector即可。

#### 1498D（#）
- 相当于要维护这次操作过后哪些位置能到达。记f[i]为答案。
- 记g[i]表示这次操作选的a为多少才能到达i，对于之前能到达的i（之后可以一直a=0），g[i]=0。
- 然后更新，从小到大，g[i]+1->g[calc(i)]，最后将g[i]<=y的且之前不能到达的i，f[i]更新为当前操作的编号。

#### 622E
- 显然根的不同子树独立，分开考虑。
- 如果两个点深度不同，它们是不影响的。
- 两个深度相同的有交必定会完蛋，所以一定要一个等一秒，相当于深度+1。
- 所以现在就变成可以给若干个数增加，问全部互不相同时和最小为多少。
- 排序之后贪心即可。

#### 1190C
- 先手如果一步就赢那么显然先手必胜。
- 不能一步就赢，那么后手可以重复先手的操作使局面不变，也可以正常操作，所以要么是平局要么是后手必胜。问题的关键就看后手能不能一步就赢。
- 枚举先手取的区间，如果左右都相同，那么就可以必胜；否则如果两边都不完全相同，后手一定不可以获胜。如果先手不能必胜且不存在后手不可以必胜，就后手必胜。

#### 1552E（#）
- 记c=⌈n/(k−1)⌉。
- 考虑先取出第二次出现位置最小的c个区间，将[第一次,第二次]做为它们的区间。
- 考虑从剩下的取出第三次出现位置最小的c个区间，将[第二次,第三次]做为它们的区间。
- 以此类推共取k-1次。可以发现不同组的区间显然两两不交，故一个位置被覆盖的次数最多为c。

#### 1132D
- 答案显然有可二分性。
- 你每次一定给最邻近关机的电脑充电，因为你要求所有电脑都不能关机。
- 用优先队列维护电脑的关机时间，每次给最小的加，如果取出来的时候已经小于当前时间了说明它已经关机了，这个mid不行。

#### 1534E（#）
- 假设第i个位置在异或中出现了c_i次（c_i必须是奇数）。令sum=Σc_i，则k|sum，c_i<=sum/k。
- 满足这个当然有解，可以考虑看成矩阵（一行有k个，一列有sum/k个）以列为优先填。
- 在sum固定的情况下一定是让max{c_i}尽量小，可以变成初始c_i都为1，每次给最小的c_i+=2，看是否满足条件。它说答案不超过500次，最多也就500*k次操作，可以通过。

#### 1148E（#）
- 首先总和不变。可以把操作看成对于s_j-s_i>=1（=1相当于交换顺序，无关紧要）的两个数，s_j--，s_i++。
- 对s_i++，s_j--，只要对值相同的取最后/最前的一个，相对顺序就不会改变，说明存在操作使相对顺序不变。
- 将s,t排序，设a_i=t_i-s_i。现在要把前面的某个-1，后面的某个+1。可以发现有解相当于要求前缀和>0。
- 具体的构造方法类似于括号序，看栈底和当前数的大小关系即可。

#### 909D
- 直接暴力复杂度是平方的。容易想到把同颜色当成一个同色段。
- 左右的同色段每次长度减少1，中间的同色段每次长度减少2（左右都没了）。
- 可以暴力，因为每个点只会消失一次，所以可以直接暴力给每个段长度 $-1/-2$，如果减没了直接暴力合并，复杂度为 $O(n)$。

#### 576B（#）
- 首先树相同必须重心相同，一棵树最多有两个重心，说明必须存在一个<=2的循环。
- 如果存在不动点即p_i=i，可以造一个以i为根的菊花。
- 否则存在对换p_a=b,p_b=a，考虑断开a,b的边，那么发现两部分排列后将会变成对方。
- 所以如果存在长度为奇数的循环则无解。否则将循环上奇数位置连a，偶数位置连b即可。

#### 496E
- 由于 $a_j\leq b_j$，所以可以把条件改为 $-a_j\leq -c_i,b_j\leq d_i$。
- 把演奏家按照 $(-c_i,d_i)$ 的二元组排序，按照顺序，你一定是取 $-a_j\leq -c_i,b_j\leq d_i$ 中 $b_j$ 最大的，因为之后的 $-c_i$ 都不比当前的小，所以你只需要尽量的取 $b_i$ 大的。

#### 229D
- 题目相当于分成若干个段，使得每段和不降，问n-最小段数。
- 设 $f_i$ 为 $1..i$ 不降的最少段数，$h_i$ 为此时最后一个塔的最小高度。
- 有一个直观的想法：存在一种答案最小的方案，最后一个数也是最小的。
- 这个怎么证明呢，假设 $1..i-1$ 都满足，那么 $h$ 存的就是可能的最小高度。$f_i$ 的转移即为

$$
f_i=\min_{j<i,h_j\leq sum(j+1,i)} \{f_j-j\}+i-1
$$
- 这个形式不好看，设 $g_i$ 为 $f_i-i$。

$$
g_i=\min_{j<i,h_j\leq sum(j+1,i)} \{g_j\}-1
$$
- 由于 $g_{i-1}$ 可以转移的 $j$ 在 $g_i$ 也可以转移，所以 $g_{i-1}\geq g_i$。所以你找到最大的满足条件的 $j$，它的 $g$ 一定是最小的，同时 $h$ 也是 $sum(j+1,i)$，即证明了 $i$ 也满足条件。
- 问题变成怎么找这个 $j$，$j<i,h_j+pre_j\leq pre_i$，而这个 $pre_i$ 也是单调递增的，故可以维护一个单调（$h_j+pre_j$ 递增）队列。

#### 269C（#）
- 非源非汇的点流量平衡。
- 由于最后是DAG，考虑一个类似于拓扑排序的做法。
- 首先入度为0的应该是1号点和无边相连的点。
- 那么加入队列的，没访问的邻边都是出边，更新一下，看看另一端能不能加入队列。

#### 1603C
- 如果你知道一个数最后分成了x个，那么一定是尽量平均的分配（设y=val mod x，则有x-y个u和y个u+1，其中u=[val/x]，无论怎么调整都不能使最大值减小或最小值增大）。
- 考虑怎么求整个序列的值，这就显而易见了，你从右往左，每次求最少操作几次，使得值不超过右边的数的值即可。
- 但是，你一个数拆分是整除的形式，即这个u只有sqrt V种，当前数尽量大，转移一下即可。

#### 995C（#）
- 原来每个不超过1e6，最后要求和不超过1.5e6。
- 向量相加显然和夹角有关系，考虑哪些夹角可以。
- $c^2=a^2+b^2-2ab\cos C$，不妨设 $a\leq b$，那么 $c^2\leq a^2(1-2\cos C)+b^2$，当 $cosC\leq 1/2$ 时 $c^2\leq b^2$。
- （这个是把两个向量首尾相接，形成三角形两条边）。
- 拿出三个向量，正反有6个向量，一定有两个夹角 $\leq pi/3$，满足条件。
- 到最后只剩下两个向量时，夹角之间 $\leq pi/2$，这样长度可能乘上 $\sqrt 2$，也不超过1.5e6。

#### 1217E（#）
- 有个简单的思路，平衡的是不是每一位最多只有一个数非0。
- 思考一下，发现如果有多个数某位都非0，且还要满足条件，那么一定需要进位。
- 对于前面的位，如果后面有进位，要满足条件自己也要进位。
- 到最后会进到一个没有数出现过的位，就gg了。
- 那么不平衡的一定有两个数在某一位都非0，要求最小就是这一位非0的最小的两个数之和。
- 线段树记录一下区间每一位非0的数中，最小和次小的值即可。

#### 1158C（#）
- 先考虑没有-1的情况，存在i,j，i<j<nxt_i<nxt_j一定无解。否则可以构造出解。
- 对于后缀最大值（nxt_i=n+1），它们之间的小区间又是独立的（nxt_j<=i），递归下去做。
- 具体实现可以类似于建树，i的父亲是nxt_i，层数低的比层数高的值大，同层编号小的比编号大的值大。
- nxt_i=-1的情况，直接取nxt_i=i+1即可，这样不会使得原来有解的变成无解。

#### 808E
- 这题比较特殊的在于 $w_i$ 不超过3。
- 只有两种比较经典，先从大到小排序，一定是要么+1，要么-1 +2。
- 枚举3有多少个，询问1,2组成的答案即可。

#### 1468H（#）
- 首先每次减小 $k-1$ 个，$(n-m) mod (k-1)$ 不为 $0$ 显然无解。
- 设 $d=(k-1)/2$，考虑最后一步，中心是 $b_x$，删去了中心左边的 $d$ 个数，右边的 $d$ 个数。
- 如果不存在 $x$ 使得 $b_x$ 左/右边有 $d$ 个非 $b$ 中的数，那么显然无解。
- 否则你在前面删的时候，$k$ 个数都取要删的数，一定能调整成最后 $b_x$ 左右各 $d$ 个数。

#### 549B（#）
- 设b_i表示当前i收到的消息数量，初始b_i=0。如果不存在a_i=0那么直接结束。
- 每一次找到a_i=b_i，钦定i加入party，称这个操作为fix。
- 那么显然每个点fix过后b_i>a_i，不会再次被fix。如果某一步找不到就结束。

#### 508E
- 可以发现，只要在当前时间放右括号合法（和栈底）匹配，那么一定就直接匹配。
- 因为如果你中间再加点别的，不如在这个右括号后面加，并不影响其他的，只是可能导致当前栈底时间过了。
- 如果时间没到就加左括号拖时间，然后就可以大力模拟了！

#### 1411E（#）
- <span style="color:red;">**这种题目（什么能不能达到，能不能凑出来）考虑寻找不变量（输入什么都不会变，或者只和极少输入的数有关）。寻找不变量之后考虑所有能到达的状态**</span>。
- 对于这题，就考虑字符是什么和字符前面的符号无关，考虑哪些符号是可达的。
- 首先最后一个一定是+号，同样的，倒数第二个一定是-号。
- 考虑是否满足这个条件就可以了，找到一对+-，那么就可以从减号的位置递归。
- 这有一种情况可能找不到，就是------…-+，只有最后一个位置是加号，那么取m=|S|-1即可。
- 去除最后两个数的限制，之前的可以直接贪心，从大到小排序，一个一个加入。否则你后面取的一定有一部分是抵消它的（这个是2的幂次，一次只能在一位上加），可以全部取反。

#### 748E
- 记录瓣数为 $i$ 的橘子有多少个。
- 从大到小枚举答案，那么 $\geq 2i-1$ 的都可以直接分了。如果当前 $\geq i$ 的橘子数量 $\geq k$，那么直接OK，否则继续往下。

#### 346C（#）
- 首先相同的x_i显然可以删去。2操作相当于走到左边一个最近的x_i的倍数。
- 如果2操作某个x_i已经<b，那么之后操作这个x_i一定也<b，删去即可。
- 否则就需要决策怎么走是最优的，发现一定是走2操作后最小的x_i，走到a-a mod x_i，否则假设走另一个x_j更优，那么考虑某一步一定会从>=a-a mod x_i走到<a-a mod x_i，那么这一步在a-a mod x_i开始也一定可以走，步数也不会更多。所以一定走2操作最小的。
- 算一下时间复杂度，你每两步操作就会使答案至少减少当前x的最大值，而x的最大值>=数字的个数，而你每次操作的复杂度也是数字的个数，所以复杂度和a-b是线性关系。

#### 979D（#）
- 把条件转化为v<=s-x,k|v,k|x，要求x xor v最大。（可以直接判断k|x是否满足，不满足则无解）
- 由于v<=10^5，如果你知道了所有k的倍数建的trie树，复杂度为O(log v)。
- 所以可以考虑在加入的时候，给所有k|v的trie插入v。
- 询问时只需要对k的trie查找，trie每个节点记录子树满足条件的最小的v是多少（要满足v<=s-x），看往哪个子树走。

#### 1601C
- 很容易想到，$b$ 应该是按照递增的顺序插入$a$ 的。
- 证明很简单，如果有相邻两个 $b$ 中的数按 $x>y$ 插入，换成 $y,x$ 一定不劣。
- 再想，是不是 $x<y$，$x$ 在 $a$ 中第一个最优的位置 <= $y$ 在 $a$ 中第一个最优的位置。
- 这个其实也好证明，设 $p$ 为 $x$ 插入到第1个位置前的逆序对数，$v_i=-1/0/1$（分别对应 $a_i$ 比 $x$ 小，相等，比 $x$ 大），那么 $x$ 插入到第 $i$ 个位置后有 $p+v_1+v_2+\cdots+v_i$ 个逆序对，所以第一个最优的位置为 $v$ 的前缀和最小值第一次出现的位置。
- 那么当 $x$ 增大时，有些 $v_i$ 减少了 $1$，对应到前缀和上是某些后缀减少了 $1$，最小值不可能前移。
- 一种可以用线段树维护最小值和出现位置，还有一种是用分治，求出 $mid$ 的第一个最优位置，那么左边和右边就完全没有关系了（它们之间的逆序对数是固定的），递归做即可。

#### 552E（#）
- 如果把括号加在两个之间，对答案没有影响。如果加在一个 $+$ 一个 $\times$ 之间，那么在 $+$ 那段扩展，答案一定也不会变劣。
- 所以只有可能在两个 $\times$ 之间或一个端点一个 $\times$ 之间加，枚举一下，然后暴力计算表达式即可。

#### 550E（#）
- 特判n=1。如果最后一个数是1，那么无论怎么操作，最后一个数的值一定是1，无解。
- 如果倒数第二个是1，那么前面怎么合并都是1，最后和0合并即可。
- 000可以变成10，即只要最后0的个数=1或>=3都一定有解。
- 考虑最后0的个数为2，即xxx…1..100。如果之前还有0，那么可以把1..10合并成0，那么最后就有3个0，有解；否则只能是1..100，不能操作00（最后一个数会变成1），操作11或10都是减少1个1，最后只能变成00，00显然没有合法方案。

#### 1098B（#）
- 一种是隔行相同，隔列字符集合相同；一种是隔列相同，隔行字符集合相同。（或两者都有）
- 枚举一下是第一种还是第二种（2），枚举隔行/列相同的集合和顺序（4*3），枚举另一种的顺序（2），枚举另一种隔列/行变不变（2），然后算一下即可。

#### 1062E
- LCA为 $x$，一定满足所有点的dfs序都在 $[dfn_x,dfn_x+siz_x-1]$。
- 所以如果删去的不是dfs序最小或最大的，并不会影响LCA。
- 所以就删去dfs序最小的和最大的，求出剩下的dfs序最小的和最大的，求它们的LCA即可。

#### 584E（#）
- <span style="color:red;">将 $p$ 变成 $1,2,…,n$，变成将 $s$ 交换成升序的最小代价。</span>
- <span style="color:red;">答案的下界是 $\frac{\sum |i-p_i|}{2}$，达到下界必须每次交换都没有浪费。</span>
- <span style="color:red;">考虑从大到小确定数的位置，枚举 $i$ 表示 $>i$ 的数都归位了，现在要将i归位。</span>
- <span style="color:red;">找到i右边第一个 $j$ 使得 $p_j\leq pos_i$ 的位置，交换。这样显然不存在浪费，最后也一定会归位。（没归位前右边一定有 $\leq pos_i$的数）</span>

#### 266C（#）
- 递归，首先保证最后一列无1，那么再交换有1的行和最后一行。
- 可以去掉最后一行，最后一列，再重复上面的步骤。

#### 723F（#）
- 把和s,t不相连的边先搞出若干棵生成树。
- 考虑每个生成树，如果只和s,t中其中一个相连，那么必须要连（否则不连通）；如果都相连，可以任意选择；最后要把s,t连通，就选一个都相连的两边都连起来或s,t有边直接连起来（尽量选前者，对度数贡献小）。
- 所以就看都相连的个数，如果为0就把s,t连起来看看度数行不行，如果不为0就选一个和s,t都连，剩下的贪心尽量不超过上界，如果还是超就无解。

#### 1283F（#）
- 每个数出现次数为儿子个数，父亲出现的一定比儿子早，没有出现的点即为叶子节点。 
- 第一个数就是根节点，接下来考虑连边情况。
- 将叶子节点加入小根堆，从后往前枚举i，弹出堆顶u，将a_i和u连边，如果a_i的儿子已经连完了就加入堆。
- 注意到最大值只和二进制数最高位有关（最高位显然两两不同），所以维护子树里的最大值即可。

#### 1276C（#）
- 不妨假设R<=C。那么选进来的数出现次数都不超过R。
- 固定了R之后，每种数就尽量选，看最多能选多少，再确定C。
- 构造的方法是不停地往右下走，如果走过了就再往右。

#### 286C
- 很容易有一种贪心的想法，就是和栈顶能匹配就匹配。
- 但是题目规定了某些一定为右括号，这样不好办，前面左括号数量可能不够。但是相反左括号就没有这个问题。
- 所以把序列倒过来，就变成钦定某些是左括号了！为什么能匹配就匹配是对的呢？
- 可以调整，你一定能把(())调整成()()，因为当时能是右括号你填了左括号，中间的限制都一样，所以一定能改。

#### 1468A
- 容易发现，$\min(b_1,b_2)\leq \min(b_2,b_3) \Leftrightarrow b_1\leq b_3\ or\ b_2\leq b_3$。
- 从后往前考虑，如果 $b_{k-1}\leq b_k$ 则 $b_k$ 满足，考虑 $k-1$；否则 $b_{k-1}\gt b_k,b_{k-2}\leq b_k$ （$b_{k-2}\leq b_k\lt b_{k-1}$），那么 $b_{k-1}$ 和 $b_k$ 都满足，考虑 $k-2$。
- 所以就可以dp了。设 $dp_i$ 表示以 $i$ 结尾的答案，则 $dp_i=\min_{j<i,b_j\leq b_i}\{dp_j+1\},\min_{j<x<i, b_j\leq b_i\lt b_x}\{dp_j+2\}$。
- 找到每个 $i$ 之前最近的位置使得 $b_x\gt b_i$，所有数按照 $b_i$ 排序后更新 $dp$，树状数组查询，$x$ 之前的 $+2$ 转移，$x$ 及之后 $+1$ 转移即可。

#### 1593G（#）
- 考虑哪些中括号一定要变成小括号，可以发现奇偶性相同的位置，不能有一对匹配的括号。
- 设有a个奇数位置的中括号，b个偶数位置的中括号，那么至少要|a-b|个中括号要变成小括号。
- 将相邻的奇偶性不同的一一匹配后删去，剩下的转为小括号。
- 可以发现小括号一定有合法的匹配方案（中括号区间内，把更小中括号包含的删掉，剩下的长度还为偶数）。

#### 765E
- 对每条边，以它为根分成两部分，求出每个儿子合并出的长度，看有几种不同的，0种说明是叶子，1种说明OK，其它情况都不行。这个可以直接dfs。
- 枚举根看一下儿子是否合法即可，这时候有2种也是可以的。

#### 425B
- 分析题目给的这个条件。如果你确定了前 $i$ 行都是矩阵，那么考虑 $i+1$ 行。
- 考虑第 $i$ 行的某个矩形，一种是它直接封口了，就是 $i+1$ 行就不是同一个矩形了；另一种是没封口，$i+1$ 行和它是一个矩形。可以发现，下一行的对应位置，要么全部相同（同一个），要么全部相反（封口）。
- 但是，如果出现相邻两个一个封口一个不封，那么就连在一起了（颜色相同），而上一行不是同一个，不合法。
- 所以这一行要么给所有的都封口（即取反），要么都不封（和上一行相同）。
- 由于最多翻 $k$ 行，所以前 $k+1$ 行一定有一行没有翻，枚举那一行，bitset求其它行的方案。

#### 1607G
- 设第 $i$ 道食物吃了 $x_i$ 单位鱼肉，要满足 $\max(m-b_i,0)\leq x_i\leq min(a_i,m)$
- 推式子，x之和前面系数带个2，要求 $|S-2\sum x_i|$ 尽量小，如果都取最小/最大都不够小/不够大那么就直接取，否则就按照S奇偶性，最多相差1.

#### 356C（#）
- 设为1,2,3,4的个数分别为a,b,c,d。最后的目标是a,b清零。
- 首先一定是12变成3，现在a,b最多有一个非零。
- 如果a非零尽量111变成3（2次），b非零尽量222变成33（2次），比从4移出来要优。现在a,b<3。
- 如果a=1，c>=1则13变成4（1次），d>=2则144变成333（2次），否则无解。
- 如果a=2，c>=2则1313变成44（2次），d>=1则114变成33（2次），否则无解。
- 如果b=1，d>=1则24变成33（1次），c>=2则233变成44（2次），否则无解。
- 如果b=2，则22变成4（2次）。
- 发现上面产生的无解情况即总和为1,2,5的情况，并不会把有解判成无解。

#### 1610E（#）
- 先思考如何快速判断一个不降序列是不是好的，拿出一个子序列，如果最小值=最大值则显然是好的。
- 如果不相等，如果存在x,y,z(x<=y,y<=z,x<z)，{x,y,z}如果是可怕的，那么序列显然不是好的。此时x一定小于avg，z一定大于avg，是可怕的则y>(x+y+z)/3，即2y>x+z。
- 会发现x一定取序列的最小值，y,z会取两个相邻的值。
- 看是否满足这个条件就行了，因为假设是可怕的，>avg的最小值是y，那么你剩下的平均值要越小越好，且<avg的个数<=除了这个数外>avg的个数，那只会取x,z。
- 枚举最小值，那么有2(y-x)<=(z-x)，每次取的数字至少*2，可以发现能贪心的往后取第一个最小的，而且每次都至少乘2，所以只会做log次，可以直接暴力二分，复杂度两个log。

#### 1239C
- 这个题意很绕，是有一个队列和一些在等待状态的人。时间到了且他前面没人在排队他就会去排。
- 所以维护一个事件序列，用优先队列。维护一个当前的时间，对一个到时间的人，如果前面没人排，他就加入排队队列（queue），否则他进入等待状态， 由于出等待状态时按照从小到大的顺序，所以可以拿个优先队列维护。
- 如果队列空了就从等待状态拿最小的过来。求下一个时间点，一种是队列里有人，那么就+p，即他接水的时间；如果没人，那么就从下一个事件的时间开始。

#### 260D（#）
- 把黑和白的分开，每次选出黑和白最小的两个权值，在它们之间连它们最小值的边，然后删掉一个点。
- 这样显然不会产生环，权值也符合条件，但是不一定连通。
- 找到最大的那个块（大小显然>=2），里面一定有黑点和白点，将其它的块都连权值为0的边上去即可。

#### 762D
- 可以发现，只能在第二行后退，否则之前经过的相当于把你限制住了，你出不去。第二行后退也只能第一行/第三行前进 - 第二行后退 - 第三行/第一行前进。
- 这就比较憨了，因为你知道你也可以通过上下右走，使得中间有奇数列时从第一行->第三行，有偶数列时从第三行到第一行，而你这个操作是无论如何都从第一行到第三行。
- 你不妨只加入中间有两列的，即 $(1,x)\rightarrow (3,x+3)$，这样相当于只有上/下/右/跨两列三一互换，直接dp即可。

#### 1131E（#）
- 对不同的字母分开来讨论。枚举字母c。
- 现在有一个新的字符串s，l,r,m分别表示s左边，右边，所有的极长c串长度。
- 如果s所有字母都是c，那么现在的答案就变为m+(m+1)*|s|。
- 如果不是，且原先答案为0，说明答案就是m；否则答案为max(l+r+1,m)即包含原先的c和不包含两种。

#### 627C
- 把起点和终点看作代价为0的加油站。
- 到达一个加油站时，一定会加到至少能到下一个代价不比它大的加油站的油，如果加满也到不了就加满。
- 直接模拟即可。

#### 731D
- 观察到：**相同的数字永远是相同的，不同的数字永远是不同的**。
- 两个串，除去它们的LCP（永远相同），看下一个位置，一定得一个小于另一个（一个为空直接OK）。
- 所有 $>c$ 的数之间， $>c$ 的和 $\leq c$ 的大小关系都是不变的，所以只要考虑 $\leq c$ 的数之间的大小关系。
- 设第 $i$ 小的数为 $p_i$，初始 $p_i=i$，一次操作把 $p_c$ 移到开头。所以你做 $c$ 次操作就会变成原序列。
- 操作 $x(1\leq x\lt c)$ 次相当于把最后的 $x$ 个数移到开头，即 $c-x+1,c-x+2,\cdots c,1,2,\cdots,c-x$。
- 如果两个数 $a,b$，本身 $a<b$，则要求要么都没移到开头，要么都移到开头；如果 $a>b$，那么要求 $a$ 移到开头，$b$ 没移到开头。
- 对于合法的区间，做个区间加。最后看最小的 $x$ 使得和为总条件数（不一定是 $n-1$，因为可能本身相邻的有一个为空）即可。

#### 364B
- 它那个换过去和换回来的不能一样的限制没什么用，因为你直接不换这个就行了。
- 那么你每次显然希望能换到的尽量大，对后面的限制也越松（$\leq cost+d$）。
- 暴力的思路是每次暴力跑01背包，上界是当前的 $cost+d$，如果跑出来能比原来的 $cost$ 大就更新继续跑。
- 不过这个太傻了，背包时只有上界在变。不如刚开始跑一遍01背包，然后每次找当前不超过 $cost+d$ 最大的可以凑出来的位置。

#### 1252E
- 字典序一般就从前往后逐位确定，需要判断这一位填 $x$ 可不可行，可行再考虑下一位。
- 是否可行是和后面的有关的，从后往前处理。
- 只有最后一位填 $[L,R]$ 都可行，其它位要满足：和某个后一位的数差的绝对值不超过 $k$；满足大小关系。大小关系是一个区间，最后一位的填法也是一个区间，所以从后往前都是两个区间的交。
- 初始最后一位的合法区间为 $[L,R]$，前面的位是后面 $[L-k,R+k]$ 和当前大小关系 and之后的结果。如果某一位合法区间为空显然无解。
- 否则就可以从前往后贪心，第一位取最小值，然后再求个交，求交里第二位的最小值，以此类推。

#### 1132E
- 求出 $\operatorname{lcm}\{1,2,3,4,5,6,7,8\}=840$，设它为 $L$。
- 那么，把 $cnt_i$ 分解成 $cnt_i=\frac{L}{i} \times p_i+q_i(0\leq q_i\lt \frac{L}{i})$。如果 $p_i$ 为 $0$ 那么直接全部加入，否则加入 $p_i-1$ 个 $L$ 和剩下的 $\frac{L}{i}+q_i$ 个，可以发现这一定能表示出原先所有的（和二进制分组类似的思想）。
- 现在 $i$ 只有 $<2\times \frac{L}{i}$ 个，写个暴力看看大概背包复杂度是1e7级别的。
- 最后再暴力枚举每个位置，看能加多少个 $L$，更新答案即可。

#### 965E（#）
- 建出trie树，把树上字符串的点标记。
- 你现在可以把一个标记点上移，要求没有一个点有多个标记。
- 容易想到贪心，对于每个子树，把最深的点移到当前点，每个点维护一个堆，启发式合并。

#### 962E（#）
- 显然没必要给BR连边。
- 考虑BR会不会和左/右方向上第一个P之后的位置连边，发现肯定不如连到第一个P，第一个P再连出去。
- 同理可以证明两个P中间的连边是PRR…RP，PBB…BP的形式。

#### 1584E
- 操作显然和顺序无关。先考虑整个序列。
- 由于 $1$ 只有一个相邻的，所以 $(1,2)$ 一定被减了恰好 $a_1$ 次，然后 $(2,3)$ 一定被减了恰好 $a_2-a_1$ 次，$(3,4)$ 一定被减了恰好 $a_3-a_2+a_1$ 次，以此类推。
- 现在 $1,2,\cdots, n-1$ 已经满足，而 $(n-1,n)$ 被减了 $a_{n-1}-a_{n-2}+a_{n-3}-\cdots$ 次，要求和 $a_n$ 相等，即 $a_n-a_{n-1}+a_{n-2}-\cdots=0$。
- 次数必须 $\geq 0$，否则不合法。
- 对于 $r$ 维护合法的 $l$，$r$ 变成 $r+1$ 就是给所有的都取反然后加上 $a_{r+1}$，此时新变成不满足的那些，把它们删去。再加上现在和为 $0$ 的还满足的个数。

#### 524D
- 把题目写的按秒表示，就变成一个顺序的时间序列。
- 如果当前还在线的人数 $<M$，你就新加一个人。否则还认为是最后一次操作的人（使得不同人数尽量多）。
- 过程中到 $M$ 就合法，否则不合法。

#### 238C
- $u,v$ 的链上（包括 $u,v$）所有点伸出去的子树都是外向的，链上必定前缀指向 $u$ 后缀指向 $v$。
- 先根据每条边预处理两端为根时子树的答案，那么链上某个点的贡献可以通过相减得到。
- 枚举 $u$，dfs的过程中看 $v$，外向的累加，链上的记一下方向，当前是指向 $u$ 还是指向 $v$ 即可。

#### 575F
- 维护当前代价最小的区间。
- 如果第 $i$ 秒的区间和当前区间有交集，那么可以直接求交（不在区间内的不小于最小答案加上到区间的距离）。
- 没交集，不妨设当前区间在左边，那么中间（当前区间右端点-最小区间左端点）之间答案都一样。
- 说白了就是两个开始斜率是-1，中间斜率为0，最后斜率为1的函数加起来，再把斜率>1或<-1的变成1或-1。

#### 946E
- 所谓排列后能回文即最多一个字符出现奇数次，而长度为偶数，说明都出现偶数次。
- 枚举lcp（越长越好），看出现奇数次的数，判断一下可不可能，可能就递归解决。

#### 553D（#）
- 最小的尽量大，考虑二分答案 $mid$。
- 设 $i$ 周围选了 $a_i$ 个，那么 $a_i/d_i\geq mid$，即 $a_i\geq mid*d_i$。
- 先假设所有点都能选，$a_i=d_i$。然后把那些不能选的 $k$ 个删去，更新周围的 $a$。
- 之后再找到 $a_i<mid*d_i$ 的点，删去，更新周围的 $a$。
- 如果最后还有点就合法，否则不合法。

#### 773C（#）
- 最后答案一定是一个区间，考虑如果求出了最小值，那么把那些 $r=1$ 的位置的 $r$ 变成上一个数，在把 $1$ 单独当一个数，答案就 $+1$ 了，最大值是 $1$ 的个数。
- 记 $a_i$ 表示 $2^i$ 的个数，$b_i$ 表示 $(2^i,2^{i+1})$ 中的数的个数。
- 考虑二分最小值，具体判断方法是，从小到大枚举 $i$，记录还能在后面继续加的数的数量 $x$ 和之前剩余的可以当 $r$ 的个数 $y$，尽量加 $a_i$，如果 $a_i\leq x$，则用完 $a_i$，剩下的尽量用$y$，$x$ 变成 $a_i$；否则将 $a_i$ 多余的给 $y$，$y+=a_i-x$。

#### 1622E
- 绝对值最大，$n$ 很小，考虑直接枚举绝对值里的正负。
- 枚举完之后就知道每个 $p_i$ 对答案贡献的系数了，系数越大的分配的值越大，算一下答案，更新即可。

#### 274D（#）
- 考虑如何判断两列的先后顺序。
- 如果有一行两列中有-1或这两列的这一行相同，这一行就不管；否则就固定了两个的大小关系。
- 但是你这样暴力枚举两列再枚举每行复杂度太高。
- 固定某一行，现在要连这一行的边。-1的直接不考虑，发现只需要连大小相邻的不同的。
- 对这一行每种权值建一个特殊点，特殊点连向这一行这种权值的点，这种权值的点又连向下一个特殊点。
- 现在就看建出的图有没有环，有环则无解，否则跑个拓扑序即可。

#### 226D（#）
- 和272E类似，每次选择和为负数的一行/一列的翻转，使矩阵总和至少+2。
- 由于绝对值之和mx<=1e6，且达到mx后一定合法，所以可以直接暴力翻。

#### 847D（#）
- 枚举i，表示必须要走到位置i后直接结束。拿一个堆维护之前的狗粮能吃到的最早出发时间。
- 那么堆里>=T-i的就可以弹掉了，想要吃它们走不到i。
- 如果当前位置本身就走不到就直接退出。否则加入当前狗粮的出发时间T-i，判断堆的大小即可。

#### 518E（#）
- 把式子重复项删去，变成a_1<a_{k+1},a_2<a_{k+2},…,a_{n-k}<a_k。
- 即a_1<a_{k+1}<a_{2k+1}<…，a_2<a_{k+2}<a_{2k+2}<…，…，a_k<a_{2k}<a_{3k}<…。
- 这个要求绝对值之和尽量小，就不能用经典套路了。不过还是可以对两个固定位置之间的取值分类讨论。
- 如果两个固定的都是负的，中间的数尽量往大取。如果两个固定的数都是正的，中间的数尽量往小取。否则要使得绝对值之和尽量小，中间的数正负的个数尽量平均。
- 为了方便起见，可以认为每个这样的下标差为k的序列中，开头有个负无穷，结尾有个正无穷。

#### 1607H
- 操作后两个数的和为 $a_i+b_i-m$，和不同的两个数一定不同。
- 现在这个 $b$ 就没啥用了，存 $a$ 可能的范围（区间，注意要 $a,b$ 都非负），两个数要相同必须区间有交。
- 现在问题就变为数轴上有一大堆的线段，取若干个点覆盖到每一条线段。
- 贪心，按照右端点排序，如果当前区间没被覆盖，那么覆盖右端点是最优的，排序做一遍即可。

#### 332C
- 假设确定了学生选了哪些，那么主席首先要让不满意度尽量小，所以一定会取不满意度最大的若干个。
- 其次要让白头发尽量少，那么就可以按照 $(-b_i,a_i)$从小到大排序，取前 $k$ 个，也就是说后面 $p-k$ 个不会被取。
- 那么整个序列的最后 $p-k$ 个都不会被取，剩下的学生会取 $(a_i,-b_i)$ 最大的若干个给主席，再塞上最后的 $p-k$ 个，就达到学生期望了。

#### 19C
- 判断长度为 $L$ 的有没有出现，有个NOI题的经典套路：每 $L$ 个位置设一个关键点，那么两个相邻相同的串中关键点的位置相同，求个LCP/LCS就可以了，这样套个后缀数组ST表查询，是 $O(n\log n)$ 的（调和级数）。
- 不过好像可以直接暴力枚举，因为每种只出现 $10$ 次，暴力枚举开头判断 LCP 应该也行。

#### 77C
- 考虑树形dp，设 $dp[u]$ 表示考虑 $u$ 的子树，从 $u$ 出发回到 $u$ 的最大答案。
- 有没有可能第一次走到某个 $v$ 然后下去走了一圈，第二次再走到某个 $v$ 下去走一圈呢？发现这和第一次到 $v$ 然后两圈绕完，再 $v,u$ 之间走一次是等价的。
- 所以每个子树绕圈只有一次，转移考虑首先是尽量希望走到某个子树走一圈再上来，如果还有剩余，就走到某个儿子再走上来。
- 绕一圈的按照dp值从大到小取，还有多就把儿子剩下的加起来，和当前剩下的取 $\min$，能取多少取多少。

#### 1085E（#）
- 对于a,b相等的前缀，s也必须和它们相等。
- 对于不等的第一个位置，看能不能介于它们之间。
- 如果不行之后就只有压下界或压上界，你就一位一位往后枚举，再枚举填什么，看是否可行，如果不行看能不能压界，还不行就没办法了。

#### 847F
- 显然2不好判，1,3相对来说都还好。
- 1操作，把初始的所有人按照(票数,最后一票时间)排序，枚举 $i$ 为结束，那么 $i$ 之前的都不用操作，后面的从前往后尽量加到比 $i$ 的票数恰好多1，看 $i$ 还在不在里面，如果在说明无论如何都能选中。
- 3操作，如果加上所有的票都选不上，那么就一定选不上了（特判a=m，剩下的情况他一定是时间最晚的）。

#### 429C（#）
- 每个点的儿子个数为0或2的图有个重要的性质：设叶子节点个数为x，那么1+2(n-x)=n，x=(n+1)/2。
- 儿子个数可以>2的话叶子节点数可能更多。由于非叶子节点两两等价，设f(s)表示s集合的点是否能构成一棵树（非叶子节点数为|s|，总点数为s中c_i的最大值）。
- 转移的时候需要用g(s,i)表示选了s的点，为若干个森林（至少2个），叶子节点个数为i是否可行。
- 注意特判叶子节点数>12和n=1。

#### 1425E
- $k=0$，不能操作，你只会激活一个点，选后缀和-代价最小的。
- $k>=2$，如果 $k=2$ 你可以把任意一个点移到链的左端，激活它，即只需要花最小原子的代价就可以得到所有（或只激活最后一个），$k>2$ 我在移到左端的过程中先把要移的点的出边乱接几次，最后再接到正确的。
- $k=1$，是最麻烦的。考虑修改的是 $i$ 的出边，一种是变成往前，一种是变成往 $i+1$ 后，往前一定连到 $1$，连 $1$ 的话就变成环和链，环一定选最小的（可能不选），链就选后缀和-代价最小的（可能不选）；往后就连到 $i+2$，选 $1..i$ 最小的/$i+1$或之后的后缀和-代价最小的/都选。

#### 1387B1
- 贪心。由深到浅考虑每个点。
- 对于一个点，把它和它的父亲节点交换，答案+2，再把两个点都打上标记。
- 每次取最深的点时如果被标记那么就跳过。
- 最后根节点可能没打标记，那么它和任意儿子也交换一下，答案+2。

#### 475C（#）
- 注意到每次只能向下或向右，所以路径长度是O(n+m)的。
- 找到最靠上其次最靠左的X，它横向的连续X有x个，纵向的连续X有y个。
- 那么考虑第一步如果往右说明纵向的必须为y个，往下说明横向的必须为x个。
- 可以直接暴力枚举另一个方向的长度，然后暴力判断是否合法。复杂度为O((n+m)^2)。

#### 1070G
- 枚举集合点，如果集合点不是怪的话两边就直接独立了，否则需要枚举两边哪边先移动。
- 现在把两边分开，不妨只考虑左边。
- 你从右往左，如果这个点能移动到集合点就移动（因为它会把它到集合点路径上所有的东西清空，在它左边的能走到它后面的就可以直接走过去了）。
- 如果最左边的不能移动那么就不行，否则你把原来不能移动的最后再移动即可（所有的都清空了，一定能走）。
- 判断能不能移动可以从每个点开始预处理，类似右端点固定求后缀和最小值。

#### 949D
- 先思考如果只有一端有宿管怎么做。
- 可以发现，假设马上要查寝室 $i$，那么所有人都移动到 $\max(pos-d,i)$，再把 $i$ 位置上多余的人移动到 $i+1$。特别的，如果这样移动位置 $i$ 人数还不到 $b$ 个，那么全部移到 $i+1$。
- 可以发现两端的也差不多，你先用同样的方法，求出宿管只在左边/右边时哪些寝室人数能达到 $b$ 个，假设左边有 $x$ 个寝室，那么把前 $xb$ 个人当作左边的，其它当成右边的，分别做结果不会改变。
- 所以就看现在两边不能满足条件的人数的较大值即可。

#### 1618G
- 考虑固定了 $k$ 怎么做，有一种贪心的想法是你每次能换多大换多大，一直换直到换不了，以任意顺序换即可。
- 你把相邻的价值差不超过 $k$ 的合并到一个并查集，求出并查集里原本属于自己的物品个数，它们可以被换成并查集里前 $k$ 大的数。
- 由于并查集对应的是原来物品排序后的一个区间，所以容易求出前 $k$ 大的数之和（原物品序列做一遍前缀和就好了）。
- 维护并查集里原本属于自己的物品数量，最右边的数的位置即可。
- 对于多个 $k$，把相邻物品差从小到大排序，把 $k$ 也从小到大排序，每次把差值 $\leq$ 当前 $k$ 的都合并即可。

#### 1039A（#）
- 题目给定a_i是单调递增的，那么a_i+t也是单调递增的，且b_i是单调递增的，所以b_i>=a_i+t。
- 那么说明x_i>=i，否则一定无解。否则若x_i=c，那么删除b_c和a_i后对应位置依旧需满足b>=a+t。即变成b_i>=a_{i+1}+t,b_{i+1}>=a_{i+2}+t,…,b_{c-1}>=a_c+t。满足条件的情况下要求b尽量小（否则x_i可能>c）。
- 最后再判断一下x_i是否=c即可。

#### 542F
- 贪心，每次取两个时间相等的权值最大的，把它们合并成一个点，时间变成 $i+1$。如果只有一个问题，那么无法合并，也认为时间变成 $i+1$。
- 对过程中每个点权值求个最大值即可。

#### 522C
- 如果之前没有人不满意，通过跳过的人数和每盘菜已经用了多少是可以知道有没有可能用完的。
- 如果有人不满意，说明有一道菜之前就用光了。只有第一个不满意的人有意义，因为后面的可能都是因为和这个人同一道菜没有才难过。
- 你可以推测，之后别人吃的菜一定不是，前面所有吃这种菜+不知道的数量还不到 $a_i$ 的也一定不是，否则可以是。

#### 594C
- 原题面写的很离谱，反正意思是删掉 $k$ 个矩形使得包含这些矩形的最小矩形面积最小。
- 容易想到一定是删除 $x$ 轴最小最大的若干个，$y$ 轴最小最大的若干个。
- 直接 $O(k^4)$ 枚举，去个重计算一下实际删点个数，如果 $\leq k$ 则更新答案。

#### 846E
- 把所有 $i$ 和 $x_i$ 连一条边。现在是 $k_i$ 个父亲能变为 $1$ 个儿子，$1$ 个儿子能变为 $1$ 个父亲。
- 设 $dp[u]$ 表示 $u$ 的子树做完之后，$u$ 点最多剩下多少（负的代表最少还缺多少）。
- 初值为 $b_i-a_i$，转移就是那些非负的儿子直接把权值给父亲，负的要从父亲里要，计算一下。
- 最后只要 $dp[1]$ 非负即可，如果要构造方案就考虑从 $1$ 开始，先做正儿子，再把自己多余的贴给负儿子，再做负儿子。

#### 730D（#）
- 可以贪心，走完第i座桥，首先要求喝的饮料数尽量少，其次要求当前饮料剩下来的时间尽量多。
- 新来了一座桥，如果能直接走过去不超时就直接走，否则先把当前剩下的双倍时间走完，然后看能不能直接走（t>=2l）到下一个，能就走，否则先把能走的t-l暴力走（l-x<=t-2x,x<=t-l），接下来必须要一直喝饮料，只要>=r就开始暴力喝饮料，距离-r（如果ans过大直接用除和模代替）。

#### 467E
- $ABAB$，可以调整成两个 $A$ 在原序列中相邻（即中间没有其它的 $A$），两个 $B$ 在原序列中相邻（即中间没有其它的 $B$），具体方法是先fix第一个 $B$，$A$ 变成它左/右边第一个 $A$，再fix第二个 $A$，$B$ 变成它左/右边第一个 $B$。
- 然后可以贪心，每次取 $ABAB$ 右端点最小的，然后把当前 $pos$ 变为右端点+1。
- 枚举第二个 $B$ 的位置，看上一个 $B$，如果有两个 $A$ 夹着它，说明就OK，右端点就是当前位置。两个 $A$ 夹着怎么判断呢？你拿个栈维护，如果它的上一次出现位置被删了直接OK，否则把被夹着的数全部删了。
- 总复杂度 $O(n)$。

#### 1250G
- 如果你每次做都reset，能赢那么说明一定不是无解，到这一步一定可以；如果到某一步会输，那么一定要在这一步之前结束。
- 之前只要没分出正负，按一次reset和之前一直按reset是完全一样的。枚举最后一次reset的时间，之前就是分不出胜负就继续，要分出胜负就reset。之后看哪个赢可以二分时间前缀和判断。

#### 727F
- 题目等价于每次给定 $a[0](a[0]\geq 0)$，询问删除掉几个数能使得任意前缀和非负。
- 有一个牛逼的思路，你倒着过来扫，如果是正的就抵消之前的负的，最后那些剩下的就得给 $a[0]$ 抵消。
- 你把那些没被抵消的拿出来，从大到小（负数）做个前缀和，你可以自己抵消一个前缀，然后把后缀的移除，二分一下即可。

#### 414D
- 容易想到，比如是第 $x$ 时刻最大，那么其它时刻到的，对应初始的时候就不用放。
- 现在就是所有的都得在同一时刻到，也就是说在某一时刻所有点在同一深度，然后向上。
- 如果选择点的深度范围是 $[l,r]$，且深度为 $i$ 的点有 $c[i]$ 个，那么到同一深度需要的代价为：
  
  $$
  \sum_{i=l}^r (r-i)*c[i]
  $$
- 原因就是考虑每升水等了多少次，刚开始 $l..r-1$ 深度的水等了一次，再 $l..r-2$ 的水等了一次，以此类推。
- 把所有点的深度拿出来排序，选出来的一定是一段连续的区间，设最大的深度为 $x$，需要的代价为：
  
  $$
  \sum_{i=l}^r (x-dep[i])
  $$
- 现在就可以 two-pointers 来求代价不超过 $p$ 的区间了，注意 $r$ 移动时可能改变 $x$，此时需要加/减区间长度（试写法而定）。

#### 746F
- 你对于每个 $l$，要求最大的可以听到的 $r$，中间所有的乐趣值都能得到。
- 显然你尽量会让时间长的只听一半。拿两个multiset维护，一个是听一半的歌，一个是剩下的歌。
- 加入的话就先加到听一半的，如果 $>k$ 首就把最小的移到剩下的歌。
- 删除的时候，如果在听一半的里删，还有剩下的歌的话从剩下的歌移一首过来。
- 维护听一半的歌的/2上取整值之和和剩下的歌的值之和。

#### 432E（#）
- 刚开始想的是每次找Up-Left most的位置，填尽量小的数，然后边长尽量长。
- 后来发现不对，你填尽量小的数，可能别的数更小但你不能填。
- 应该改为填尽量小的数，填到一个这一行能填更小字母的位置或不能填的位置。

#### 81D（#）
- 首先每个数放的次数不能超过[n/2]，所以a_i可以和[n/2]取min。如果a_i之和不到n那么无解。
- 如果有一种数的数量是[n/2]，考虑n的奇偶性，如果是偶数那么在所有偶数位置放这个数，奇数位置任意放其它数；如果是奇数依旧在所有偶数位置放这个数，剩下必然至少有两种数（否则总和不到），各取一个放1,n两位置，剩下随便放。
- 否则，对于每种数，按照顺序1,3,5,7,…,2,4,6,8,…放下去即可。

#### 132D（#）
- 你考虑长为len的一段数的表示方法：
  1. 给每个1的位置+；
  2. （在最后一个位置为1的情况下）$+2^{len}$，$-2^0$，再给每个为0的位置-。
- 有一个容易想到的错误贪心：对于每一段1，如果长度为1就直接+，否则在最低位-，最高位+1的位置+。
- 很显然第二种表示方法只有第一个位置和最后一个位置都为1才有意义，否则你可以删去前后的0。
- 继续考虑，发现第二种如果其中有连续的>=2个0，你可以把它拆分成前后都用第二种不会更劣。
- 对于长度len>=2的，开头结尾没有0的，其中没有连续>=2个0的，且倒数第二个位置是1，用第二种不比第一种更劣（1的个数>=0的个数+2），也不比拆分更劣。
- 在开头加两个0，从低位往高位考虑，如果这一位和下一位都是1，则这一位为第二种的起点，直到出现某一位和它下一位都是0结束，否则的话用第一种。

#### 370D（#）
- 一定有一维卡边界，你可以知道正方形的边长是max(xmax-xmin,ymax-ymin)。
- 枚举卡边界的是x维还是y维，已知边长，看另一维有没有合法方案即可。

#### 958E2
- 直接 $dp$，设 $dp_{i,j}$ 表示前 $i$ 个时间点选了 $j$ 个区间的最小代价。
- 而区间只会是相邻端点形成的，非相邻端点形成的区间代价更大。
- 那么 $dp_{i,j}=\min\{dp_{i-1,j},dp_{i-2,j-1}+a[i]-a[i-1]\}$。
- 这个明显是凸的，可以使用wqs二分来优化，把每个区间代价减去 $mid$。


#### 123C
- 对于所有 $(i,j)$，可以发现 $(i-1,j)$ 和 $(i,j-1)$ 必须得相同（都从 $(i-1,j-1)$ 过来）。
- 那么容易发现，与 $(1,1)$ 距离为 $d$ 的都相同（相当于是个斜角线），那么这条斜角线只需要考虑上面优先级最小的点。
- 现在就变成一个序列问题，首先得是一个合法序列，然后得满足按照优先级第 $k$ 小。
- 然后逐位确定，也就是看优先级最小的填左括号的方案数，如果 $\geq k$ 就填左括号，否则填右括号。


           
#### 1231E（#）
- 排序后不同显然无解。每个数显然只会被操作一次。
- 考虑被保留下来的，相当于你要找一个S的子序列，T的子串，使长度尽量长。
- 枚举T中的左端点，枚举S，看最多能有多长。


#### 353E
- 考虑那些连续的指向一个方向的段。如果一个点在长度 $\geq 2$ 的段就标记一下。
- 在长度 $\geq 2$ 的会选非两端的，而交替段（一堆长度为 $1$ 的）只能选一半（(x-1)/2下取整）。


#### 958B2（#）
- 选出离某个点最远的点当根，把树长链剖分。
- 把长链的长度都拿出来，排序，贪心的选即可。
- 你一定会先选长链，不完整的链一定会后取到。

#### 313E（#）
- 加起来的和mod m只有 $<m$，不用减 和 $\geq m$，要减去m两种可能。
- 开个桶记录每个数字出现次数，你显然希望mod m和为m-1的尽量多，那么只有b=m-1-a(a+b=m-1)的情况（不存在a+b=2m-1）。
- 从小到大枚举a，如果对于一个a_i找不到多余的b=m-1-a的话，就先压进栈里，如果之后的b=m-1-a’多余的话可以和栈里的匹配（b和更大的a匹配然后-m一定不优，a和之后更小的b匹配也一定不优）。
- 对于剩下来栈里的a，和多余的b之和一定>m，从大到小枚举b，弹栈（一定-m那肯定越大越好）。
- 最后排序输出即可。

#### 404E
- 碰不到的墙，你放在那里也没用。
- 原点两侧只需要考虑第一个墙，之后的墙一定碰不到，也没用。
- 而如果两边都有墙，你必须两堵墙都撞到一次，那么之后再走任何一个位置（或者不动）都不满足条件了。故最多只有一边有墙。
- 没有墙的话直接模拟。
- 有墙的话，最后一步往左一定在右边，反之亦然（如果不在这一边，而墙又撞到了，说明之前一定把墙到原点的都覆盖了，而在原点右边往左一定也不行）。
- 离原点更近的摆放方案一定越优，它抵消了更多的反向移动。
- 二分最远的摆放位置即可。

#### 73D
- 考虑你做完了第一个操作之后怎么做第二个操作。
- 那么每个连通块具体哪个点连是没有关系的，只需要认为最多连 $\min(tot,k)$ 条边。
- 每条边都可以连接两个连通块，所以 $\sum min(tot_i,k)\geq 2(m-1)$，$m$ 为连通块数。
- 尽量使所有的 $tot_i$ 都不超过 $k$，超过 $k$ 就无效了，每次选最小的连通块连，左边计数一下。

#### 1218I
- 题意是指可以把一行或一列对应位置异或上 $c$ 数组，求一组方案从 $a$ 变成 $b$。
- 首先求出两个矩阵的异或 $a\oplus b$，现在变成从全 $0$ 矩阵变成 $a\oplus b$ 的解决方案。
- 也差不多，枚举一下行选不选，列选不选。如果有种情况不合法，即代表两变量不能同时满足。2-SAT建边输出方案即可。

#### 101D
- 每条边只能经过两次，那么说明你走进了某个子树，必须走完了再走出来。
- 设走完 $u$ 子树需要最少的时间为 $f[u]$，那么从 $\sum f[v]$ 转移（和它们的顺序无关）。
- 和它们的顺序有关的是所谓的平均时间，把那个 $n-1$ 最后再除。设走完 $u$ 子树所有点的答案为 $g[u]$。
- 考虑两个子树 $x,y$，$x$ 在 $y$ 之前新增的贡献是 $f[y]*sz[x]$，$y$ 在 $x$ 之前新增的贡献是 $f[x]*sz[y]$，那么如果 $f[y]*sz[x]<f[x]*sz[y]$ 则说明 $x$ 在 $y$ 之前，排序后更新即可。

#### 858E
- 记Sample为 $A$，Regular为 $B$。
- 先求出 $A$ 的个数 $x$，那么 $1,2,\cdots,x$ 都是 $A$，$x+1,x+2,\cdots,n$ 都是 $B$。
- 如果本身是 $A$ 且在 $A$ 的位置上，本身是 $B$ 且在 $B$ 的位置上，那么删去。
- 剩下的，再记录占着 $B$ 的位置的 $A$，占着 $A$ 位置的 $B$，占着其它位置的 $A$，占着其它位置的 $B$ 记录。还有 $A,B$ 的空余位置也要记录。
- 首先尽量让占着位置的赶紧走，所以如果是 $A$ 占 $B$ 且 $A$ 有空位，移过去；$B$ 占 $A$同理。
- 如果还有占着其它位置的，就把一个占着其它位置的 $A$ 或 $B$ 移过去。
- 如果以上都不满足，即有占着位置且没有空位，把一个占位置的移到其它位置即可。

#### 144E
- 相当于你要到 $x+y=n+1$，每次可以 $x--$ 或 $y--$。
- 只要目标点不重复，过程一定是可以做到不重复的。因为过程重复只有可能是距离相同的点，你一定可以通过调整来做到不重复（起点和终点都按 $x$ 从小到大）。
- 所以，每个点能到达的最终 $x$ 的范围是一个区间，问题选出若干个点使得每个点和区间一一匹配。
- 把区间按右端点从小到大排序，相同按左端点从大到小排序，选最左边的没覆盖的点，贪心即可。

#### 491B（#）
- 把曼哈顿距离的绝对值拆了，分别记录x+y,x-y,-x+y,-x-y的最大值。
- 对于每种方案，算一下四个的最大值是否比当前答案小，小就替换。

#### 134C（#）
- 拿个堆维护每个人手上还剩的自己的牌的数量。考虑自己的牌最多的人x，尽量要让自己的牌最多的人牌数最少和剩下的还有牌的人最多，就和剩下的自己的牌的数量从大到小前x大的人交换，使它们自己的牌都-1。

#### 76B
- 和每个老鼠最近的奶酪要么一个要么两个。
- 把所有只有一个最近的要选的奶酪去掉，这些到底给其中的哪些老鼠其实没啥关系，反正总数是对的（你如果有但是不给，要给有两种选择的老鼠，那么这个老鼠空着还不如交换一下不会更劣）。
- 对于剩下的两种的老鼠，从左往右扫过去，如果他左边没有覆盖，那么选左边的；否则看右边有没有覆盖，没有的话选右边的；都覆盖了就不选了（反正距离都是一样的）。

#### 248D
- 先二分答案。然后分情况考虑。
- 一种是走，直到过程中拿到的糖果数=人数，则回来。
- 一种是走到底（拿到足够的糖果，且至少到最后一个人）返回。
- 实际上如果你必须回到开头就没第二种什么事了，第二种省下的是最后一趟回来的时间。

#### 306B
- 相当于选出尽量少的区间覆盖所有位置。
- 贪心，维护当前覆盖到的位置 $x$，然后找下一个区间使得满足覆盖的部分连续且右端点尽量大（就是左端点不超过 $x+1$ 的右端点最大是多少），然后覆盖过去即可。


#### 86B（#）
- 从上到下，从左到右，先用 $1*2$ 和 $2*1$ 的来覆盖。剩下的空位找四连通的已经被覆盖的接在一起。
- 如果没有说明四连通都是障碍物，无解。可以证明每个块大小不超过 $5$。


#### 125D（#）
- 考虑前三个位置，必有两个在同一等差数列，枚举一下，就知道等差数列的前两项和公差。
- 由于数字互不相同，直接往后取即可。取完了之后，剩下的给第二个数列。
- 但是第一个数列可能没有这么长，可能删去了一段后缀。
- 先特判第一个数列不删，删去最后一个位置，删去最后两个位置可不可行。
- 否则至少删去三个位置，第二个数列的最后两个数固定了，可以倒推哪些数要在第二个数列，反过来判断第一个数列即可。

#### 120I
- 经典枚举lcp。
- 从后往前枚举lcp长度，然后枚举这一位填什么。
- 那么之后位幸运值最大的填法就是和当前填的一样，计算一下是否合法，合法就往后一位一位算即可。


#### 1431F
- 先二分答案。
- 然后从左到右，维护当前块所有数字的优先队列，如果大小为 $m$ 且 $sum$ 满足条件就可以分一块，否则如果大小为 $m$ 看当前的是不是比最大值小，是的话也替换。

#### 1431G（严谨正确性证明？）
- 先发现一个结论，Alice选了一个数后，Bob一定会选比它大的最小的。
- 把选出的数分成若干段，那么每段一定长度为偶数，而把前一半Alice选，后一半Bob选一定最大，Alice从中间开始往左边选。
- 直接二维dp，记录当前到 $i$，选了 $j$ 个。转移就枚举当前连续段 $x$ 的长度。