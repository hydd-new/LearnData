#### 1523E
- 刚开始想的是直接 dp，记录当前两端都没有/左右有一盏/两端都有的答案，转移就考虑哪个范围能继续递归。
- 其实可以有另一种思路，期望等于 $i$ 次操作后还没结束的概率之和+1（即 $E(x)=1+\sum_{i\geq 1} P(x>i)$）。
- 那么每一盏灯（除了最后一盏）就要求它后面 $k-1$ 个位置都没有灯，组合数就能计算 $i$ 盏灯的答案（选完后在每盏灯后放 $k-1$ 个空位，最后一盏除外）。


#### 1391E
- 图上构造还是比较困难，考虑先求个dfs生成树。求完之后如果存在深度 $\geq n/2$ 的显然就存在路径。
- dfs 树有非常好的性质，就是只会有祖孙边。所以如果两个同深度的点一定没有边，不同深度的只有祖孙关系才有可能有边。
- 现在知道了深度 $<n/2$，所以可以给同深度的尽量两两匹配，至少有 $n/2$ 对，然后两对之间，每个点在某个深度只有一个祖先，所以最多只有两条边。


#### 555E
- 也是类似，图上构造比较困难，可以先缩点变成一棵树（原因是定向在边双里一定可以使得两两可达）。
- 然后就只有一条简单路径，给它定向即可，最后看有没有冲突。相当于是路径覆盖，直接树上差分即可。


#### 13E
- 傻逼了。。。第一想法就是LCT，其实不需要，范围这么小。
- 考虑直接暴力的话是操作复杂度 $O(n)$，询问复杂度 $O(1)$，且没有很好的性质。
- 那么可以直接用分块来分摊复杂度，比如说只暴力修改一部分（块内的），每个点维护第一个会到不是当前块的哪一个点。
- 那么对于修改一个块内的后继，只会影响当前块内的点；询问的时候暴力一块一块跳。


#### 235C
- 直觉就是倍长后后缀自动机。。。因为循环同构相当于倍长后的一个长度的子串。
- 由于后缀自动机支持前面删去一个字符（link），后面加上一个字符（trans），直接在上面跳。
- 但是有个问题就是可能会算重，循环同构的有可能相同。这个一种可以求出 $x$ 的循环节（kmp），还有一种就是在SAM上标记一下说明这个点已经经过了。


#### 321E
- 一眼决策单调性（进一步还满足四边形不等式，相交$\leq$ 包含）。
- 普通决策单调性可以分治，四边形不等式可以直接改变循环范围（从 $(i,j-1)$ 的决策点到 $(i+1,j)$ 的决策点）。


#### 631E
- 不妨只考虑数字往后移动，往前移动类似。
- 考虑 $i$ 移动到了 $j,k$（$i\leq j\lt k$），如果 $k$ 比 $j$ 更优即 $(j-i)a_i-(S_j-S_i)\lt (k-i)a_i-(S_k-S_i)$，整理一下变成 $a_i\gt \frac{S_k-S_j}{k-j}$。
- 那么说明有效的点一定在凸壳上，维护凸壳。
- 加点的时候是在一端加入，可以直接弹栈再加；询问的时候二分找，然后转移即可。


#### 1208F
- 维护一个 $d_j\And d_k=x(j<k)$ 时 $j$ 的最大值是多少， 然后做个高维后缀和（最大值）。
- 枚举一个 $i$，一位一位确定答案，具体的方法是看答案这一位填 $1$ 是否可行（当 $d_i$ 这一位为 $0$ 的时候，看 $d_j\And d_k$ 新增要求这一位为 $1$ 后是否还存在 $j>i$ 的方案），通过高维后缀和判断即可。


#### 741D
- 重排之后能形成回文串当且仅当最多只有一个字符出现了奇数次。
- 点分治/dsu，每次加入子树的时候枚举最后剩下的字符，看是否存在符合要求的答案。
- 时间复杂度 $O(n\log n|\Sigma|)$。


#### 1439C
- 操作后仍然不会改变它是一个非降序列，直接线段树二分后覆盖。
- 询问的话，先去除 $x$ 的限制（给 $y$ 加上 $x$ 之前所有数字之和）。然后一定是分成不超过 $\log n$ 段，因为每一段取完，总和至少 $/2$（否则这一段一定还没完），而线段树上只对应不超过 $\log n$ 个区间，直接线段树上二分即可，复杂度是 $O(n \log^2 n)$。

#### 547E

- 对 $n$ 个串建 AC 自动机。将询问离线后差分。每次插入一个串时给所有前缀 +1。
- 现在就变成某个前缀，问某个串出现了多少次，相当于求 fail 树上子树的权值之和，树状数组维护即可。
- fail 子树代表的是以它为后缀的前缀。

#### 1406E

- 容易想到，如果答案是素数，显然只能通过询问它本身才能判断（或询问完其它所有素数）。
- 根据经典结论，$\gt \sqrt n$ 的素因子最多只有一个。先把 $\leq\sqrt n$ 的素数都删掉了，如果过程中发现 $x$ 有这个因子就暴力求出它的幂次。
- 现在要找是否有 $\gt \sqrt n$ 的素因子，直接暴力显然不太行，还是考虑分块，每次连续删掉 $B$ 个，然后看现在剩下的数字个数是不是恰好少了 $B$，如果不是就说明其中有，再暴力找。
- 需要的次数应该是 $\pi(n)+\pi(\sqrt n)+(\pi(n)-\pi(\sqrt n))/B+B$，取 $B=\sqrt{\pi(n)-\pi(\sqrt n)}$，则不超过 $\pi(n)+\pi(\sqrt n)+2\sqrt{\pi(n)-\pi(\sqrt n)}$。而 $\pi(n)\leq 9592,\pi(\sqrt n)\leq 65$，总次数符合要求。

#### 613D

- 可以建出虚树再做，显然影响并不大。
- 看一下边上有没有被缩起来的点，然后树形 dp（如果有缩起来的说明这条边也可以花 1 代价拆除）。
- 使用牛逼建虚树方法：“把点按dfn排序，相邻点的lca丢进去，再排序，每个点在虚树上的父亲就是自己和前驱的lca。”

#### 1439B

- 要达到集合的条件，度数 $<k$ 的点都是没用的，可以删掉，不停删去直到剩下的点度数都 $\geq k$。
- 要达到团的条件，可以降低一下条件，只删去度数 $<k-1$ 的，然后对于每个度数为 $k-1$ 的判断是否能成团。看似复杂度很高，其实 $k>\sqrt {2m}$ 时显然不能成团，而每判断一次会删去 $k-1$ 条边，所以复杂度是 $O(m\sqrt m)$。

#### 940F

- 如果没有修改操作就是经典莫队（查询直接暴力查tot，因为 mex 不会超过 2sqrt）。
- 现在带修改，所以得用带修莫队。就是按照（左端点所在块，右端点所在块，时间）排序。
- 注意修改移动的时候如果遇到了区间内的同时要更新tot。

#### 1110F

- dfs序是 $1,2,\cdots,n$，这很有意思。把所有叶子编号求出来，从小到大排成序列 $leaf$。
- 没有修改，考虑离线直接把答案处理出来。
- 现在知道了 $u$ 到所有叶子的距离，那么往 $v$ 走，会使得 $v$ 子树里的叶子（是一个 $leaf$ 下标连续的区间）的距离减少 $1$，其它叶子距离增加 $1$。
- 拿个线段树处理一下区间加减区间最小值。

#### 364D

- 这题真不错，首先可以发现随机选一个数，有 $1/2$ 的概率在最后答案里。
- 你随机 10 次，求出其它数和这个数的 $gcd$，做个倍数和，求出 $gcd$ 为每个数是否可行（判断个数是否有一半），得到最大的就是必须选这个数的答案。

#### 662C

- 首先有个暴力就是 $2^n$ 枚举每一行翻不翻，然后求每一列最优的方案，复杂度是 $O(2^nm)$。
- 发现列的顺序没有关系，只和列上每一行的状态有关系，求出 $2^n$ 种状态分别出现的次数 $f_s$。
- 如果你翻了 $t$ 状态的那些列，答案就为 $\sum_s f_s\times g_{s\oplus t}$，$g_s$ 表示状态 $s$ 中 $1$ 的个数。
- 改写一下就变成 $\sum_x \sum_y f_x\times g_y[x\oplus y=t]$，直接 FWT 就可以求出所有 $t$ 的答案。

#### 1270G

- 条件移个项变成 $1\leq i-a_i\leq n$。这个很有意思，它对应的也是一个下标。
- 看一下条件，$\sum a_i=0$，改成 $i-a_i$ 的形式，也就是 $\sum (i-a_i)=\sum i$。
- 由于 $i-a_i$ 也是个下标，考虑将 $i$ 和 $i-a_i$ 连边，那么一个环就能恰好满足这个式子（每个数的下一个编号和=每个数编号和），且显然会有环。

#### 455D

- splay/fhq-treap显然可以做。不过也可以用分块。
- 每个块维护起始的位置（块内真实的值，是这个起始位置开始取）。每次从前一块移动一个值的时候就把起始位置之前的位置替换，并把起始位置向前移一步。
- 询问的时候整块就维护一下每个数出现次数，散块就暴力。

#### 1515F

- 操作相当于要求每次生成的点非负。如果最后的值（一定固定为 $(\sum a_i)-(n-1)x$）为负则一定无解。
- 之前做了好几道只要满足最后条件就合法的，不妨猜测这题也是。假如拿出了最大的和它旁边的（至少是最小的），若 $\max+\min<x$，那么最大可能的总和 $(n-1)\times \max+\min=(n-2)\times \max+(\max+\min)<(n-2)x+x=(n-1)x$，矛盾。
- 所以每次取最大值和旁边的就可以了，用并查集和邻接表维护（任意选择一棵生成树即可）。

#### 1278F

- 拆一下，假设洗出王牌的轮数集合为 $S(x=|S|)$，那么 $x^k$ 的组合意义就是在 $S$ 中选择 $k$ 次数。
- 反过来考虑，知道 $k$ 次数分别选的什么求轮数集合的概率。
- 求出选 $k$ 个数（每个数在 $[1,n]$ 轮），有 $i$ 个不同的方案有 $dp(k,i)$ 种，对应轮数集合的概率是 $(\frac 1m)^i$（每张牌出现的概率仍然是独立的 $\frac 1m$）。

#### 1370F2

- 首先把所有点都问一次，那么就可以得到一个在两点路径上的点 $u$ 和两点之间距离 $d$。
- 路径上深度最大的一定是一个关键点，直接二分深度，询问大于等于此深度的点距离是否可行。
- 另一个点也很好求，把和这个点所有距离为 $d$ 的都拿出来再询问一次。
- 这样需要 $12$ 次，不过可以优化：你知道第一次询问出的点 $u$，以 $u$ 为根，那么较深点的深度至少是 $d/2$，就可以减少一次。

#### 240F

- 要排成回文串，先求出出现奇数次的数的个数，$>2$ 则不能排，$=1$ 把这个数放一个到中间继续排，否则直接排。
- 排的方法就是从 $a$ 到 $z$ 依次放，线段树维护区间每种字符个数。

#### 650D

- 如果原先 LIS 必须包含这个被修改的数，那么不包含它的 LIS 长度 $-1$，否则不变。
- 包含这个数的就求出之前比它小的LIS最大的，之后比它大的LIS最大的，求和 $+1$。
- 离线即可。

#### 700C

- 0 条边就是判断本身两个点是否不连通。
- 1 条边就是先缩边双成树，然后两点树上路径的所有边的最小值。
- 2 条边的话就一定不会删树边，剩下的给每条边权值加上 $+\infty$ 跑最小割，为了尽量少删边故一定会删 $\geq 2$ 条，边数最少其次权值最小的。

#### 576D

- 先考虑怎么暴力，设 $dp[x][u]$ 表示点 $u$ 是否可以从 $1$ 开始走 $x$ 步到达，转移就看相邻的边是否已经可以走，更新过去的点。不过这个复杂度太高。
- 发现其实很多种不同的 $x$ 对应当前能转移的是一样的，把边权从小到大排序，那么对应的已经解锁的边是一个前缀。
- 对于每次对应解锁边集变化的 $x$，它到下一次边集变化 $y$ 之间都是不变的，bfs 一遍看能不能直接到达 $n$，如果不能就得看再走 $y-x$ 步能到哪些，可以用 or/and 矩乘，进一步可以用 bitset 优化，复杂度是 $O(m(n+m+n^3\log d/w))$。



- 其实还可以进一步优化，你发现你只需要知道答案矩阵的第一行，也就是哪些是可以从 $1$ 开始走到的（或者说本身只有第一行有值）。
- 那么如果你能快速维护另一个矩阵（当前能走边的邻接矩阵）的 $2^k$ 幂，那么就可以暴力乘（现在就乘就只需要 $O(n^2)$ 了）。
- 考虑修改一下，把某个原先是 $0$ 的 $a_{i,j}:=1$，那么对 $0$ 次方影响就是这个位置，$1$ 次方就考虑它做左边的影响和右边的影响，每次成功修改再考虑操作下一次，而每个最多变成 $1$ 一次，所有矩阵总共 $n^2\log d$ 个数，每次更新是 $O(n)$，复杂度是 $O(n^3\log d)$。

#### 1363F

- 看这个操作，每次把 $s_r$ 移动到 $s_l$ 的位置，也就是每个数都可以往前移动若干个位置，求操作数。
- 首先两个串的可重集必须相同。考虑类似求编辑距离的 dp，设 $dp(i,j)$ 表示 $s[1..i]$ 和 $t[1..j]$ 匹配的最少操作次数（如果 $s$ 长度比 $t$ 小说明从后面拿了若干个上来）。
- 转移就考虑三种：直接匹配；从后面拿一个 $t$ 对应的字符（必须还有）；$s$ 当前字符被拿走了。
- 难以考虑的是你不能确定当前的状态是怎样的，可能 $s$ 这个字符已经被移走了但你拿来直接匹配，可能后面所有 $t$ 对应的字符都移走了但你还继续移过来，可能你还了一个没借过的字符。
- 不过显然得满足 $s[1..i]$ 的可重集 $S$ $\subseteq t[1..j]$ 的可重集 $T$（现在 $T-S$ 的都是从后面拿上来的），这样就能避免不合法情况（前两种会导出字符个数不同，最后一种会违反这个条件）。

- 所以直接这么转移是可以的，所有非法状态都不会记录到答案，而合法状态显然都会被计算到。

#### 163E

- 和之前的547E类似，只不过匹配反过来了。
- 把 $S$ 的串加入 AC 自动机，建立 $fail$ 树，在每个串末尾对应的节点子树加 $1$（能匹配那些以它为后缀的）。
- 然后枚举询问串的每个前缀，看以多少个 $S$ 中的串为后缀，求和即可。

#### 516D

- 这个 $f$ 就是到带权直径两端点距离的较大值。
- 把直径整条拉出来，那么不在直径上的每个点是它父亲的权值 $+val_e$，直径上的求出最小的点，往两边扩展也是 $+val_e$。
- 那么把直径上（也是全局）最小的点拿出来，以它为根，那么每个点的权值都是父亲的权值 $+val_e$。
- 双指针一下，$r$ 从大到小，$r$ 变小就是删除一个数（它一定没有儿子），$l$ 变小就是加入一个数（它一定没有父亲），并查集维护即可。

#### 1554E

- 未被标记的节点个数。。。这个东西一看好像拓扑序，就是相邻拓扑序比它大的个数。
- 而它是棵树，可以随意定向不会成环，$a$ 的值就是出度大小。出度总和为 $n-1$，故 $k$ 必须得是 $n-1$ 的约数答案才不会为 $0$。
- 每次考虑一个叶子节点连边的定向，显然定两种方向会导致最终答案不同，每次删掉一个叶子节点，可以发现 $a$ 共有 $2^{n-1}$ 种。
- 那么，$k=1$ 的方案可以由总方案减去，其它情况得要求不能出现出度是 $1$ 的，所以叶子节点的边都是入边，现在出现的新的叶子还得满足 $k$ 的条件，所以 $k>1$ 最多只有一种方案。
- 有一个显著的优化是你只需要考虑素因子，求出方案后得到真实的 $k$，把那个 $k$ 的答案设成 $1$。

#### 1039D

- $k$ 减小答案不会变小，这是因为你 $k-1$ 可以用 $k$ 的路径方案且每条路径删掉一个点。
- 可能的取值只有 $O(\sqrt n)$ 个，直接写假的整体二分（每层判断复杂度和答案区间一点关系都没有）的复杂度是 $O(n\sqrt n\log n)$。判断就是dfs，每次看子树上来两条最长的，能接起来就接起来。
- 不过也可以直接根号分治，$k\leq \sqrt n$ 直接暴力，$k>\sqrt n$ 答案种类只有不超过 $\sqrt n$ 个，二分和当前相同的右端点暴力判断。不过取块大小为 $\sqrt {n\log n}$ 应该会更优。

#### 1495D

- 树上 $u$ 到 $s,t$ 的距离和原图相同。那么原图中在 $s,t$ 最短路径上的还得在树上 $s,t$ 的简单路径上，所以原图 $s,t$ 的最短路径必须唯一才有解。
- 对于其它点到 $s,t$ 要走的第一个的点得相同，从合法的那个点过来都可行，求出个数相乘即可。

#### 505E

- 最小化最大值，先来个二分。就变成所有数都 $\leq mid$。
- 直接模拟可能会出现 $-p$ 之后 $<0$，还得重新考虑。
- 反过来操作，初始都是 $=mid$，每次可以把若干个 $+p$。
- 每次先减去 $a_i$，然后再给若干个加上 $p$，要求每一时刻都不能有 $<0$ 的（否则往后做答案就 $>mid$）。
- 要求结束的时候的值 $\geq h_i$。

#### 293E

- 先点分治，然后就变成两个不同子树的点到根的 $A$ 值和不超过 $x$，$B$ 值和不超过 $y$。
- 把每个点对应的可以的点的限制拿出来，就变成二维偏序，注意去重（在同一子树，算成有序对，把选同一个点也算进去）。

#### 258D

- 把期望拆成每个 $i<j,a_i>a_j$ 的概率之和。设 $p_{i,j}$ 表示 $a_i>a_j$ 的概率。
- 交换 $x,y$，那么它们之间的概率变成 $\frac 12$，而其它数和它们的概率也是取平均值。
- 初始 $p_{i,j}$ 都是 $\frac 12$，修改的时候 $O(n)$ 计算影响，最后答案求和即可。

#### 755F

- 先把排列建环，那么每个环最少可以花 $\lceil \frac {len}2\rceil$ 的代价使得它们都收不到。
- 换句话说，如果环长是偶数，每一步操作都可以删掉两个数；否则环长是奇数，最后一次操作只能删掉一个数。
- 要收不到的尽量多，那就尽量选一次操作能删两个的，如果还有的多就选能删一个的。
- 要收不到的尽量少，那每一个环第一次一定会影响两个，然后之后每次都可以只影响一个，最后一次可以一个都不影响。也就是如果取完一个环那么取了多少减少多少，否则会多减少一个。那么如果能正好有若干环的和为 $k$ 那么就可行，否则要多减少一个。
- 因为环的总和为 $n$，种类只有 $\sqrt n$ 种，把同样长度的环进行二进制分组即可。

#### 1458C

- 这个题比较经典，只有前 $4$ 个操作的话那么就直接记录每个方向位移了多少次。
- 第 $5/6$ 个操作就是置换把两个反过来（下标和数值反过来）。
- 所以这个你就直接记录 $(i,j,p_{i,j})$，第 $5$ 个操作就是交换第一维和第三维，第 $6$ 个操作就是交换第二维和第三维，前 $4$ 个操作就是在第一维/第二维加上一个值再取模，记录现在三维的顺序和每一维加上了多少即可。

#### 848C

- 区间 $[l,r]$ 里的 $pre_i\geq l$ 的贡献为 $i-pre_i$。
- 由于 $pre_i\lt i$，所以不妨把区间改为 $[1,r]$。也就是求 $l\leq pre_i,i\leq r$ 的 $i-pre_i$ 的数字之和。
- 你如果直接动态维护的话就必须得用二维数据结构了，但是可以套个CDQ分治来离线维护。
- 把操作变成添加/删除一个二维点 $(pre_i,i)$。对当前询问有影响的操作如果是添加就加上贡献，否则就减去贡献。
- 两边递归完后，合并时计算贡献即可。

#### 724E

- 容易想到一个最大流是每个点从 $S$ 连 $p$，连到 $T$ 为 $s$，任意两点编号小向大建 $c$ 的边。
- 这个直接建边显然复杂度过高，但是可以由于最大流=最小割，而前 $i$ 个点具体是哪些和 $S$ 相连并没有关系，你只需要知道个数。
- 如果和 $S$ 连就断掉 $T$ 即可，和 $T$ 连不仅要断掉 $S$，还要断掉之前所有和 $S$ 相连的点的边。
- 记录之前有多少连到 $S$，当前到了哪个点，滚动数组优化 dp 空间即可。

#### 908G

- 先枚举一个数，算它的贡献。对于每个 $i=1,2,\cdots,9$，把每一个数字变成 $\geq i$，最终的数字求和显然等于原数字。
- 记录一下到哪一位，是否压上界。如果填 $<i$，那么不会影响贡献；填 $\geq i$，在最后加入一个 $1$，枚举每个 $d$，计算答案后求和即可。

#### 605E

- 容易想到记录 $dp[i]$ 表示 $i$ 到 $n$ 的期望天数。
- 假设当前已经求出的是期望天数前若干小的，感觉不太好转移。
- 考虑剩下的期望天数最小的有什么性质，由于它是最小的，如果没有往已经求出的那些点的边，那么它就会停在原地。求出这个条件下期望天数最小的天，就说明其它的作为剩下的期望天数最小的一定不可行（它比它们小，且它一定不会走到期望天数比它大的）。
- 就这样转移，具体来说每个的概率是比它小的边都没出现$*$它出现了$*$它的期望天数求和后 $+1$，注意要把不动的移过去解方程。
- 这个方法类似dijkstra？

#### 1301F

- 考虑路径长成什么样，走若干步 — 跳一步 — 走若干步 — 跳一步 — ...。
- 乍一看好像很难，想枚举第一步跳的在哪个位置，预处理后面的答案。
- 然后发现其实没必要枚举位置，枚举跳第一步的颜色，那么前面的也预处理，后面的也预处理。可以发现前后预处理的其实可以是一样的（前面不一定只能走，也可以允许跳）。
- 具体求法就是每一步要么走要么跳，跳就到所有颜色相同的（然后标记一下以后不更新这种颜色跳的了），bfs 即可。

#### 713D

- 设 $dp(i,j)$ 表示以 $(i,j)$ 为右下角的最长正方形的边长。
- 怎么转移呢？和二维前缀和类似，只不过现在是取最小值，也就是 $(i-1,j),(i,j-1),(i-1,j-1)$ 的最小值 $+1$（如果当前位置没有拼图那么答案为 $0$）。
- 那么直接求答案很难，因为有不超出矩形的限制，所以可以二分答案，那么在前 $mid-1$ 行前 $mid-1$ 列为右下角就不能形成矩形，其它就求 $dp$ 最大值是否有 $\geq mid$，有说明答案合法。

#### 961G

- 考虑每个单点的贡献（显然贡献系数是一样的）。
- 考虑和它同一组的数的个数，它的贡献系数就是所有方案下，所在组数的个数之和。
- 这个等价于再选一个同组的数的方案数。再拆开，枚举一个同组的数，求它们在一组的方案数，就是 $(n-1)S(n-1,m)$，注意同组的数可能是自己，所以还要加上 $S(n,m)$。
- 所以答案就是 $((n-1)S(n-1,m)+S(n,m))\sum_i a_i$。算单个斯特林数用组合数容斥即可。

#### 1223F

- 考虑每个位置开始往后第一个能消完的，这之后的就是直接拼上去。
- 怎么处理第一个能消完的？首先先看下一个和当前的是否相同，是就到下一个就能消完；否则说明要先把下一个开头的消掉，也就是到 $nxt_{i+1}$ 又变成只有 $a_i$ 一个数，然后再继续判下一个数是否相同。换句话说就是 $i+1,nxt_{i+1}+1,nxt_{nxt_{i+1}+1}+1,\cdots$。
- 怎么优化判断？类似 $kmp$ 自动机，每个点记录往后路径上第一个某种字符出现位置，然后把中间的无效的暴力删去。一种实现是可持久化线段树，但有网友用了map的swap，发现其实是可行的，因为任意两个数的 $nxt_i$ 不同（如果相同，那么不是最短的可以把最短的那段拿掉依旧合法，且长度变短，矛盾）。

#### 1149C

- 它这个和普通的树括号序类似，只不过少了一个最左边的左括号和最右边的右括号。
- 树上两点距离，如果不是祖孙关系，就是dfs序小的右括号..dfs序大的左括号之间去掉匹配的括号后的长度；是祖孙关系，就从dfs序小的左括号..dfs序大的左括号之间去掉匹配的括号后的长度。
- 这里给出一个更进一步的结论：**树上任意一个区间去掉匹配的括号都能表示树上的一条简单链，树上的所有简单链都能用这种方法表示**。（后半句上面就已经说明了，前半句就看你把匹配的删去后是 `)..)(...(` 就说明是非祖孙关系的距离，是 `(...(` 或 `)...)` 就说明是祖孙关系）。
- 删去匹配括号后的长度，也有一个结论：**在序列里找到一个分隔位置，最大化分隔位置后的和-分割位置前的和，其中和指把 `)` 当成 $-1$，`(` 当成 $+1$ 求和**。（如果找到的分割位置恰好是删去后剩下的某括号之后，一定不如放在最后一个 `)` 之后。如果不放在某个剩下的括号后，一定可以移动到前面的剩下的 `)` 之后，因为括号序列的一个后缀和一定是非正的，前缀和一定是非负的，减一下还是非正的，不如移到前面贡献变成 $0$）。

- 怎么求这个的最大值？考虑第一个把答案区间分成两部分的点，那么就是左儿子的一个后缀 与 右儿子的一个前缀，如果分隔位置在左边，那么右边就全是正的（右边前缀和最大值），左边先负后正（左边后缀答案最大值）；分隔位置在右边同理。所以要维护前缀和最大值，后缀和最小值，前缀后缀答案最大值，区间答案。

#### 1364E

- $0 \operatorname{or} x=x$，所以可以先求出 $0$ 的位置。
- 把排列随机打乱，然后求出第一个位置的值。
- 往后扫，如果有一个数是当前数子集（or 一下），就把当前数替换，求出新的数的值。
- 每个数求它的值就随机 $20$ 个位置 or 一下来判断，它错误的概率是 $0.001\%$，且错误了并不会导致答案错误，只有可能导致询问次数增加。
- （不考虑发生错误的情况）理论上需要的次数为 $2n+11\times 20$，实际上跑不到 $11\times 20$，初始一定会满，且一次求值不一定只比原先少 $1$ 位数字。

#### 442D

- 路径就分为祖孙链或非祖孙链。由于没有颜色数限制，所以非祖孙链一定可以从 LCA 断开分成两条颜色不同的一定不会更劣。
- 设 $dp_u$ 表示非根节点 $u$ 的子树（再加上 $u$ 往父亲连的边）的答案，那么答案最大的儿子一定要和它到父亲的边颜色相同，其它儿子颜色只能不同。
- 设 $v$ 为答案最大的儿子，$w$ 为次大的儿子。从 $\max(dp_v,dp_w+1)$ 转移过来（这个东西其实是到根节点的轻边数量的最大值）。
- 现在树是变化的，每次可能会加上一个儿子。但是到根轻边的数量最多 $\log n$，所以每次可以暴力往父亲更新，如果父亲的答案增加则继续更新。因为 $dp$ 总和只有 $O(n\log n)$，所以复杂度也为 $O(n\log n)$。

#### 960G

- 容易想到前后缀可能是独立的，考虑前缀最大值和后缀最大值所在位置的下标，发现前缀最大值后缀最大值一定都包含最大值 $n$，那么前后的确就独立了。
- 那么设 $f_{i,x}$ 表示前 $i$ 个数有 $x$ 个数是前缀最大值，那么 $ans=\sum_{i=1}^n {n-1\choose i-1}f_{i-1,a-1}f_{n-i,b-1}$（枚举最大值的位置）。
- 转移就是 $f_{i,x}=(i-1)f_{i-1,x}+f_{i-1,x-1}$，发现转移就是第一类斯特林数，且初始值也是一样，所以就是第一类斯特林数。
- 考虑组合意义，就是从 $n-1$ 个里选出 $i-1$ 个组成 $a-1$ 个环，剩下的 $n-i$ 个组成 $b-1$ 个环。
- 由于是对所有 $a$ 求和且有组合数，所以前 $a$ 个环和后 $b$ 个环的组成元素和个数没有具体要求，所以可以先组成 $a-1+b-1$ 个环，然后再从其中选 $a-1$ 个。
- 即答案是 ${a+b-2\choose a-1}s(n-1,a+b-2)$，组合数好算，难点在于斯特林数。
- 具体斯特林数可以构造生成函数，因为 $f_{i,*}$ 本身就是生成函数式的转移，分治 NTT 即可求出。不过也可以多项式求逆的方法倍增求出。


#### 204E
- 先建立广义后缀自动机，拿个线段树记录一下每个点在哪些串中出现过。
- 线段树合并求出子树里有多少种字符串， $\geq k$ 的就说明可行，对于每个串的结尾节点求一下到根路径上有多少可行节点累加即可。


#### 1254D
- 操作等价于换根后子树加。
- 每个点如果要加，那么选择的 $r$ 和当前点必须在根的不同子树。
- 根据树剖的套路，只对特殊的外子树和重子树直接更新，询问的时候就跳重链（重链上的直接更新完了，只有链切换的时候贡献要算）。

#### 1209F

- 把边拆点，使得每条边都只有 $1$ 位数（注意要变成有向图）。
- bfs，原先距离小的先更新，距离相同的按照添加的数从小到大更新。
- 为了方便可以把距离相同的存成一个 vector 加入队列。

#### 1389F

- 假设当前另一种右端点最靠右的位置是 $x$，那么你只能选这种左端点 $>x$ 的。
- 设 $dp_i$ 表示选 $i$ 的答案（且 $i$ 是当前右端点最靠右的），那么就要枚举另一种的 $j$ 使得 $r_j\lt l_i$，然后选择所有 $r_j\lt l_k,r_k\leq r_i$ 的所有当前种的区间。
- 把两种区间都按照右端点排序，那么 $j$ 的范围就是另一种的一个前缀。现在要快速计算最优的转移点，也就是要求出转移点的贡献。那么 $i$ 右移的时候，会更新一个前缀 $+1$。
- 所以只需要维护一个前缀最大值，前缀 $+1$，单点修改的数据结构，线段树即可。

#### 356D

- 首先可以发现，子树和最大的一定是某棵树的根，且所有根的子树和必须得是 $s$。
- 这两个是必要条件，但是否充分？可以发现可以把剩下所有的按照子树和从大到小接到子树和最大的形成一条链。
- 所以现在就要求是否有若干个点的和为 $s$（最大的必选），可以发现这个就是 $01$ 背包，但是复杂度太高。但是由于值域并不大，且只需要记录是否出现，故可以用 bitset 优化。
- 不过还需要记录方案，但是每个点只需要记录一次。所以对于每次新增的 $1$，暴力记录它们是这一轮加入的，和加入前的 bitset xor 一下然后 `_Find_next` 跳过去即可。

#### 1148F

- 它用 $mask$ 操作一次等价于用 $mask$ 里每一位的都操作一次。
- 不妨假设初始和是正的，现在要变成负的。
- 每个数只和它为 $1$ 的那些位有关，那么不管低位怎样，最高位还是能确定当前数的符号。
- 把每个数按照最高位分类，那么从低到高考虑每种最高位的数，那么你可以知道这些数现在的和，可以把它取负。
- 你只要把每一组的和变成非正，而由于初始和为正，所以不可能每组都是 $0$，就符合题目要求了。

#### 671D

- 设 $dp_i$ 表示 $i$ 的子树和 $i$ 到父亲的边都覆盖的最小权值和。
- 但是这样还不够，这个点可能还有往上的路径覆盖了好多个点。
- 拿个线段树维护覆盖了链上深度为 $\geq x$ 的点的答案，子树转移覆盖到的取 $x$ 的最小值。启发式合并一下点，$x$ 从小到大维护答案越来越小的。注意还要加入选择当前点往上的路径，此时所有儿子只需要取代价最小的。

#### 1553G

- 你操作一次之后一定会变成偶数，所以你可以把 $s,t$ 都操作一次一定就连通，所以答案不超过 $2$。
- 答案为 $0$ 容易判断，看是否在同一个连通块（每个质数建虚点，并查集合并）。
- 答案为 $1$ 可以考虑每个 $a_i+1$ 会使得哪些原先不连通的质数连通块连通，给两两连通块标记一下（$C(7,2)$）。

#### 535E

- 每个人花费的时间是 $T=\frac S{s_i}+\frac R{r_i}$。把时间除以 $R$ 变成 $T=\frac{\frac SR}{s_i}+\frac 1{r_i}$。
- 设 $k=\frac SR,x=\frac 1{s_i},y=\frac 1{r_i}$，$T=kx+y$，$y=-kx+T$。
- 确定了斜率 $\frac SR$ 后就确定每个需要的时间，你发现这等价于用一条斜率固定的直线去切，那么只需要保留凸包上的点。
- 不过注意，你用来切的线斜率必须是负的，所以你保留的是下凸壳，最后取斜率为负的部分（左半部分）。
- 注意时间一样的人是可以保留的。

#### 724G

- 还是和 WC2011 的那题一样，任何一条路径都能由起始两点的一条简单路径再加上若干个环组成，这个之前也证明过，取个生成树后加边归纳即可。把所有简单环的异或和加入线性基。
- 如果线性基上第 $i$ 位有 $x(x>0)$ 个 $1$，那么能异或出 $2^{tot-x}\times 2^{x-1}$ 个第 $i$ 位是 $1$ 的数，剩下的都是第 $i$ 位为 $0$ 的数。如果没有 $1$ 则异或出的都是第 $i$ 位为 $0$ 的数。
- 简单路径就是两点到根路径上权值异或，可以求出简单路径第 $i$ 位为 $0/1$ 的个数。
- 对应能异或出多少个答案第 $i$ 位是 $1$ 的，就可以求出来了。最后乘上 $2^i$ 求和即可。

#### 311D

- 模数不特殊不太能做，这种对单个数一直操作就考虑有没有循环节。研究一下模数，发现它是质数。
- 因为你每次三次方，所以你想看的应该是不停三次方后会不会形成循环节，也就是 $a^{3^x}\equiv a\pmod p$，也就是 $(p-1)|(3^x-1)$，然后打个表发现 $x=48$ 就满足条件。
- 线段树，每个节点维护 48 个和，表示当前区间做 $0,1,\cdots,47$ 次操作后的区间和。

#### 482C

- 容易想到的一种做法是先枚举答案，然后状压dp。
- 不过这样复杂度太高，好像有一句玄学的话：概率从前往后推，期望从后往前推。
- 我们倒着设状态，$dp_s$ 表示当前问了状态 $s$，确定字符串的期望步数。
- 设 $num_s$ 表示 $s$ 状态有多少种字符串，彼此不能区分。你考虑这一次问什么，加上这一位，只有那些 $num_{s|2^i}$ 中的那些还是不能区分，所以可以计算概率后转移。
- 至于 $num$ 数组的计算，先记录在这个状态下不能区分的是哪些字符串（二进制状态）。
- 直接枚举两个字符串然后枚举 $s$ 复杂度还是太高，可以先求出两个串共有的位置，然后再求个高维后缀和。

#### 1473F

- 一眼最大权闭合子图。
- 直接建边能达到平方，不过可以发现，往前连，两个相同的数字只需要连后面的那个。
- 现在边数只有 $O(n\max d(a_i))$，根据经典表格，$\max d(a_i)\leq 12$。
- 接下来就可以跑最大权闭合子图了。原图的边连 INF，S 向非负权点连权值，负权点向 T 连权值绝对值，先累加非负权边，再减去最小割即可。

#### 1469F

- 链接上去的时候，显然选链的中点是最优的（白点数量固定，那么一定是深度越小越好）。
- 操作的策略？你想让整体深度深度都小，每次接的一定接到深度最小的点（你不可能一直不接它接深度大的）。那么每个点接到的深度+半链长度就是这条链会达到的最大权值。
- 容易猜测会长度从大到小接，每次选长度最长的接不仅使当前答案最小，也有更多的深度小的候选点（更严谨的证明可以考虑调整）。
- 那么，每次相当于是给某个区间深度的加 $1$，由于你是从小到大取的，所以可以直接差分更新。

#### 1422F

- 在线乍一看没啥思路，先想想离线。
- 枚举右端点，考虑线段树维护左端点的答案。右端点移动时，那么有些后缀的幂要增大到当前 $p$ 的幂次，拿个单调栈维护指数的后缀最大值，然后弹栈暴力区间乘，线段树即可。
- 那么在线也一样，只不过需要用可持久化线段树记录历史版本。

#### 79D

- 区间取反，可以变成差分。差分后最多把 $1$ 的位置变成 $2k$ 个。
- 反过来，初始有一些灯亮，每次可以选择两盏距离为 $d$ 的灯一起取反。
- 那么由于操作顺序无关，你每次可以选择一盏亮着的灯和另一盏灯取反，继续操作那一盏灯和另一盏，以此类推，直到两盏灯都关了。
- 那么，从每盏亮着的灯开始求到其它亮着的灯的最短路，求出之后就可以状压 dp 两两删去。

#### 1140F

- 你发现 $x_0,a$ 一直在左边，$y_0,b$ 一直在右边，容易联想到矩阵。操作变成矩形有三个点的时候第四个点也会有。而矩阵对应二分图，行向列连边。
- 二分图连通的部分，左边和右边的两两都有连边。用并查集维护一下。
- 但是并查集不方便删除，这个好办，线段树分治一下即可。

#### 372D

- 首先有个经典结论，**树上包含 $a_1,a_2,\cdots,a_k$ 的连通块的最小边权和为按照 dfs 序排序后当成一个环相邻点距离和再 $/2$，因为这样把每一条边都算了两次**。
- 然后就可以 set 来维护点 dfs 序大小，双指针求即可。

#### 1373G

- 这里用的题意是 luogu 的翻译，认为二元组第一个数是行，第二个数是列。
- 每个格子不能有多个棋子并不重要，你可以调整顺序满足要求。
- 求出每个球用最小的步数到 $x$ 行时 $y$ 是多少，对于 $y$ 相同的需要往后放，那么就是 $y\geq v$ 的个数不能超过 $ans-v+1$，设 $y\geq v$ 的个数为 $f_v$，那么 $ans=\max\{f_v+v-1\}$。
- 那么修改就是前缀加/减，求全局最大值，线段树即可（注意值域是 $2n$ 而不是 $n$）。

#### 1372E

- 由于是平方，所以尽量要放到同一个位置的数量尽量多。考虑先枚举最多的。
- 设 $dp_{l,r}$ 表示被区间 $[l,r]$ 完全包含的，那么选择一个 $k$ 认为它放最多，能放的都放到位置 $k$，剩下的变成 $[l,k-1]$ 和 $[k+1,r]$。
- 有多少个包含的可以预处理。然后就可以直接转移了。

#### 512D

- 你发现操作等价于每次选择一个度数不超过 $1$ 的点删去，求删去 $k$ 个点的方案数。
- 相当于是拓扑排序前 $k$ 个数计数，你先把拓扑排序排完后剩下的环删去，那么那些和环有一端相连的树认为它们是有根的，否则是无根的。有根时认为根不是叶子。
- 对于有根树，设 $f_{i,j}$ 表示 $i$ 的子树选择 $j$ 个删去的方案数，树上背包合并（必须子树的点都选才能选自己），需要乘上一个组合数。
- 对于无根树就比较麻烦，考虑把所有点当根都计算一次，那么每种方案会计算 $tot-k$ 次，也就是除了删掉的点当根其它的方案都会算到，最后除掉即可。
- 树上背包可以卷积优化，但没有必要。

#### 487D

- 这种做多了就知道是倍增或者分块，这个倍增显然不好维护，就只能倍增。
- 先考虑暴力，那么直观想法是维护每行的点第一个会到上一行的点在哪一列，操作 $O(m)$ 询问 $O(n)$。
- 然后考虑优化，这种倍增不容易维护，使用分块，每 $O(\sqrt n)$ 行分一块，操作复杂度就变成 $O(m\sqrt n)$。
- 那么分了若干层之后，每次修改直接重构整一块，询问就一块一块跳。
- 由于本身操作次数是 $O(\frac nm)$ 级别，所以总复杂度是 $O(n\sqrt n)$。

#### 633F

- 选择两条不相交的链，那么一定有一条边可以分成两部分，使得两条链分别在两个子树。
- 用记录边的 dp，就可以转移了（或者也可以换根dp之类的也行）。

#### 85E

- 这个曼哈顿距离最小容易想到转成切比雪夫。
- 那么就是要用两个边长相等的正方形覆盖所有点，且要让边长最小。
- 求出一个能包含所有点的最小的矩形，显然它四条边上都有点。
- 两个正方形至少得包含两个边界上的点，且如果某一维超出边界可以平移。
- 那么两个正方形一定靠在矩形的两个对角，具体边长可以二分或者看每个点到两个角的切比雪夫距离取小的。

#### 1207G

- 操作串一直在变，不妨对询问串建 ACAM。
- 操作串在 ACAM 上跑，询问只需要知道多少跑的过程中经过的点在 $t$ 的子树里。
- 你跑的时候给当前点加 $1$，询问在 dfs 序上树状数组即可。
- 但是操作串总长可能很大，不过每次改变量不大，给操作也建个树，每次走到一个就加入这个串新增的字符。

#### 917D

- 设 $g_i$ 表示钦定 $i$ 条边重合的方案数，那么即分成 $n-i$ 个连通块的方案数。
- 根据经典 Prufer 序列结论，把若干连通块连成一棵树的答案是 $\prod a_i\times n^{k-2}$。
- 这个 $\prod a_i$ 有个经典组合意义是每个连通块选一个点，dp 记录当前在哪个点，有多少连通块，当前连通块是否选点即可。
- 最后给 $g$ 二项式反演一下就可以求出答案。

#### 338E

- 要求 $a_i+b_j\geq h$，那么就是 $a_i\geq h-b_j$。
- 你要匹配一定是把两个区间排序后两两匹配，但是排序不好维护。
- 不妨考虑类似括号序列的方法，在 $h-b_j$ 位置 $+1$，$a_i$ 位置 $-1$，要求任意前缀和非负。
- 变成后缀加减要求任意值非负，线段树维护。

#### 542E

- 可以发现操作就是把两个点捏起来。
- 感觉三角形是捏不掉的，想让它消失必须选一个内部一个外部，但是即使选了新的 $x$ 还是会连原先三角形的边，所以有三角形就无解。进一步猜测和二分图有关，考虑奇环和偶环。
- 奇环如果选一个环内一个环外和刚才一样，环长都不会变；如果两个都在环内，会变成一个奇环一个偶环，而环长变成 $3$ 时就无解。
- 偶环如果选一个环内一个环外，环长也不会变；环内的有可以变成两个奇环或变成两个偶环。
- 所以只有二分图有解，对于二分图的每一个连通块，能取到任意两点最短距离的最大值，取一个 bfs 树同层的点合并即可。

#### 1365G

- 按位或是可以重复合并的。
- 由于任意两个不同数至少有一个二进制位不同，也就是任意 $x\neq y$，$x$ 取反和 $y$ 一定有相同位。
- 求出和 $x$ 取反有相同位的数合并，这个等价于拿出 $x$ 取反的每一位，和这一位相同的数字的或。
- 直接处理需要 $20$ 次，但是处理完之后询问的次数不是瓶颈，考虑减少处理的询问数。
- 现在这样要询问每一位是 $0/1$ 的，我们希望找到一个满足任意两个不同的数它们至少有两位不同（一位是 $1/0$，另一位是 $0/1$），那么我们只询问 $1$，就只需要 $13$ 次询问。
- 有一种满足上面条件的就是每个数字重标号后 $1$ 的个数一样，那么上面的就成立了。由于 $C(13,6)>1000$，所以就可以选择重标号成 $13$ 位其中恰好有 $6$ 位是 $1$，那么就可以询问每位是 $1$，恰好需要 $13$ 次完成。

#### 1601D

- 分情况讨论这个最大值，这种一般就考虑调整：
  - 最大值都是 $a$，不妨假设 $a_i<a_j$。
    $j$ 先上 $i$ 一定上不去，不如先让 $i$ 上且 $j$ 有可能上去且最后高度不会更高（结论是 $i$ 先上）；
  - 如果一个最大值是 $a$ 一个最大值是 $s$，不妨设 $i$ 的最大值是 $a$，$j$ 的最大值是 $s$。
    如果 $a_i>s_j$ 则还是 $i$ 先上 $j$ 一定上不去，不如先让 $j$ 上可能上去且最后高度不会更高（结论是 $j$ 先上）；
    不如 $a_i\leq s_j$ 则 $i$ 先上不会影响 $j$，$j$ 先上则不一定（结论是 $i$ 先上）。
  - 最大值都是 $s$，不妨假设 $s_i<s_j$。
     $i$ 先上，一定不会影响 $j$；$j$ 先上，可能会影响 $i$（结论是 $i$ 先上）。
- 所以发现最大值小的一定优先，最大值相同的可以直接贪心思想，一定是 $s$ 小的先上。



#### 1023F
- 由于你的连接都想让顾客选，所以先把边权都设成 $0$，求一棵最小生成树。
- 对于剩下的对面的边可能可以替代你，对于那些边考虑它和树边形成的环，那么你的权值就不能 $\geq$ 它的权值，这样就可能选他的了。
- 所以你把你的边权值设成 $+\infty$，其它树边权值设成 $0$，每次链取最小值即可。
- 注意可以离线，所以可以把剩下的边权排序后并查集维护。


#### 702F
- 暴力就是按照 $q$ 从大到小，其次 $c$ 从小到大，能购买的依次购买。简单点说就是如果余额 $\geq c$ 就减去 $c$，答案 $+1$。
- 直接做不好做，考虑拿平衡树维护每个人剩下的价格。
- 但是如果你暴力直接 split 成两部分，然后暴力减去再一个一个插入，复杂度也不对。但是你 split 成三部分，$[0,c),[c,2c),[2c,+\infty)$，只需要暴力加入第二部分，第三部分的相对大小一定还是比之前大，所以可以直接 merge。
- 这样复杂度是对的，因为每次操作后至少减半。


#### 549F
- 使用经典单调栈来求出每个点作为最大值的区间（使用经典方法认为相等时前面大）。
- 然后每次枚举最大值和长度较短的区间，用 vector+binary search 求出较长区间的答案。这个本质上等价与 dsu on tree，所以复杂度是 $O(n \log^2 n)$ 的。


#### 1348F
- 构造一组方案可以贪心，从小到大枚举 $i$，每次把 $i$ 给包含 $i$ 的右端点最小的。
- 是否有第二种？如果有一定能通过交换一个和之前 $r$ 最大的得到，判断一下即可。


#### 1400G
- 容斥，直接 $O(2^m)$ 枚举哪些不满足的条件都同时出现了（注意这个是可以容斥的，考虑容斥原理的式子）。
- 枚举集合的大小 $x$，那么 $x\in[l,r]$ 的都可行，在里面用组合数选择 $x$ 个。
- 有多个限制的情况，那么要求 $x$ 在他们 $[l,r]$ 的交集内，依旧用组合数选，但是注意已经有若干个选好了。
- 而已经选好了多少个数可以枚举，预处理组合数的前缀和，$[l,r]$ 的答案就前缀相减一下即可。


#### 1355F
- 一种暴力的想法是我一个一个质数问幂次，次数太多。
- 一种优化方法就是相邻两个质数一起问，但次数还是太多。
- 首先你知道只需要枚举到平方根，但这还不够。枚举到四次方根，如果当前剩下的 $1$ 则直接结束。否则剩下的因数最少的是一个质数（$2$），次数最多的是三个不同数相乘（$8$），取中间数 $4$ 乘到当前答案上即可。
- 比较小的质数，因为不同的质因子不超过 $9$ 个，可以先把质数分组使得乘积不超过 $10^{18}$（可以轻松的分成 $5$ 组），然后询问求出哪些质数出现了，再逐个询问个数。


#### 1051E
- dp。关键在于如何快速转移。
- 如果 $1..i-1$ 都已经划分，考虑 $i$，那么如果 $i$ 的位置为 $0$ 就不行，否则长度在 $[|l|+1,|r|-1]$ 的都可以，长度为 $|l|$ 的和长度为 $|r|$ 的要特殊判断，具体方法就用 exkmp 来求出每个后缀和 $l,r$ 的 lcp，然后判断 lcp 的后一个数。


#### 578D
- 这题好像是 GP of Korea 的弱化版，那题是求 $LCS\geq n-k,0\leq k\leq 3$。下面就讲那题。
- 求 LCS 可以用二维 dp，记录 $s[1..i]$ 和 $t[1..j]$ 的 LCS。
- 首先记录 LCS 状态（其中有一个固定），一般可以对于一个固定的 $j$ 记录所有 $i$，但是直接记录状态数量太大，但是可以差分记录 $LCS(i,j)-LCS(i-1,j)$，它的值显然 $\leq 1$，当作二进制状态记录。
- 这样状态还是太多，但是可以发现所有 $|i-j|\gt k$ 的状态都是没有用的，它们更新到的LCS 一定一直长度不到 $n-k$。
- 再记录一下 $i-LCS(i,i)$（$LCS$ 满足至少是 $i-k$），状态数量变为 $(k+1)2^{2k}$。
- 转移就考虑枚举当前 $t_j$ 是什么，更新二进制状态，转移复杂度为 $O(|\Sigma|k)$。
- 总时间复杂度是 $O(|\Sigma|k^2 2^{2k})$。


#### 1451F
- 如果没有 2 操作，那么就是简单的 nim。
- 考虑能不能把数分个类还是变成类似 nim 的操作。
- 你发现，因为除了起点，其它的数都在右下角，所以按照 $x+y$ 分层那么这一层的只能减。
- 考虑和 nim 类似维护每一层的各自的异或。那么你操作的时候这一层就一定会变化，比它大的层你一定想调整成什么就调整成什么（原来的异或和为 $s$，原来的当前数是 $a$，想把异或和调整成 $t$，那么把 $a$ 换成 $s\oplus a\oplus t$ 即可）。
- 那么，容易想到分成全为 $0$ 和不全为 $0$ 两种，全为 $0$ 只能变成不全为 $0$，不全为 $0$ 可以把第一个不为 $0$ 的组变成 $0$（这个就是 nim，取异或和第一个不为 0 的位把这一位对应为 1 的某个数操作），其它的组可以随便调所以都可以变成 $0$ 就能变成全 $0$ 的组，且游戏不会一直进行下去（每层按照字典序的比较方式每次都减小），结束状态为全 $0$，所以全 $0$ 就必败否则必胜。


#### 794F
- 用线段树维护区间所有数字的贡献系数标记（标记记录的是数字为 $i$ 的要变成什么）。
- 求答案的时候就把贡献系数和值乘起来相加即可。
- 注意标记下传时，父节点的标记是后操作的，对于子节点现在是 $x$ 的，看父节点中 $x$ 会变成什么即可。


#### 811E
- 由于只有对列的询问，所以可以直接对列建线段树。
- 记录区间里左右边界的点属于的连通块编号，合并的时候对于中间交界处两边相同的就可以直接并查集合并，最后重标号一下。


#### 725E
- 如果你加入的硬币不会被他选那么一定没用。
- 反之如果硬币都被它选了，把这些硬币加起来合并成一个面值，那么之前要选的剩下的还是会选。
- 不过还可以优化，面值相同的都是等价的，每一次找下一种（预处理）还有的面值尽量买，这样复杂度就变成 $O(c\sqrt c)$。


#### 1380F
- 考虑没有修改怎么 dp，那么 $dp_i=(c_i+1)dp_{i-1}+[c_{i-1}==1](9-c_i)dp_{i-2}$，显然可以写成矩阵形式。
- 有修改相当于是修改一个矩阵，动态dp，线段树维护矩阵乘积即可。


#### 914G
- 枚举结果的 $2^i$，再求出 $s_a|s_b=x,s_c=y,s_d\land s_e=z$。
- $\sum_i \sum_{x\&y\&z=2^i} f_i\times f_j\times f_k\times (\sum_{s_a|s_b=x,s_a\&s_b=0} 1)(\sum_{s_c=y} 1)(\sum_{s_d\land s_e=z} 1)$。
- 第一个子集和卷积，第二个直接记录，第三个异或卷积，最后用与卷积合并即可。


#### 325E
- $n$ 是奇数，这个图会有两个自环分别是 $0,n-1$，且它们对应的其它入边就为唯一的 $\frac{n-1}2$，而非 $0$ 点只能经过一次，故无解。
- 考虑 $n$ 是偶数，这个图仍会有两个自环分别是 $0,n-1$。那么 $x$ 和 $x+n/2$ 连的出边都相同，且对应的那两个点也只有这两条入边。
- 给每个点指定一条出边，使得每个点出边指向的点不同（也就是 $x$ 和 $x+n/2$ 指向不同），就会形成若干个环。
- 题解说有多个环时，一定存在某个 $x$ 使得 $x,x+n/2$ 不在一个环。考虑反证，如果所有 $x,x+n/2$ 都在一个环，那么它们对应的 $2x,2x+1$ 也在环内，这一定能从 $1$ 开始覆盖到所有点，故只有 $1$ 个环了，马屁吨。
- 每次选择一个 $x,x+n/2$ 不在同一个环的把出边交换一下，就合并了两个环。


#### 1584F
- 因为数据范围很小且串很多，考虑直接记录当前最后一个字符是什么，而因为每种字符在每个串最多出现两次，所以可以直接用二进制状态记录这个串匹配的是第几次出现。
- 每次加入一个字符的时候看这种字符下一次出现位置即可，直接转移难固定顺序，可以用 bfs 的方式转移。


#### 1422E
- 可以直接 $dp$，设 $dp_i$ 表示以 $i$ 开头的后缀的最小答案，如果能删除就 $dp_i=\min(dp_{i+2},s_i+dp_{i+1})$ 转移（不过 $dp_{i+1}$ 不会删掉它的前面两个，否则和删掉前两个的相同，所以等价于 $s_i+s_i+dp_{i+2}$），否则就 $dp_i=s_i+dp_{i+1}$。
- 第一种转移不是很容易，不过可以先求个第一个不同位置（显然之前都是同一个数），然后再比大小。由于每次都是在前面加入所以可以反转过来，维护后缀相同的数字个数即可。

#### 1515G

- 回路上所有点都在 $v$ 的 SCC 中。
- 由于 SCC 任何两点间都有回路，所以对于 SCC 上的某个回路可以并上一个能到点 $v$ 的回路 $t$ 次，你对于任意两个点的回路都并上来，那么回路上就有 SCC 的所有点。所以 $s,t$ 相同的情况下，SCC 任意一点的答案相同，只需要找出环，不需要考虑是否能到所有点。
- 那么对于现在的回路，也可以任意两个并起来权值相加，因为两个回路都能到达所有点，可以先走完第一个再走第二个。根据裴蜀定理，能走出所有环长和 $t$ 的 $\gcd$ 的路径。
- 根据经典套路，求个外向树，所有非简单环都可以用非树边形成的环表出，有个巧妙的证明是 $\sum val(x_i,x_{i+1})=\sum d_{x_i}-d_{x_i+1}+val(x_i,x_{i+1})$，如果是树边后面的值就是 $0$，否则就是包含它的环的大小（即使是横叉边也可以通过乱走得到这个）。

#### 1312G

- 这个 $S$ 直接求出来总长度可能很长，但是给出形式可以直接建 trie。
- 然后 dp 求每个需要耗费的时间，一种从父亲的时间 $+1$ 转移，表示后面加一个字符；一种是从某个祖先加当前字典序位置转移过来，预处理初始时所有串的字典序位置，那么当前字典序是这个串字典序减去祖先字典序。
- dfs，维护一个单调栈即可。

#### 627D

- 最小值最大，容易想到二分答案，对符合条件的点染色。
- 关键在于如何判断，先考虑固定根的情况，那么对于完全被染色的子树显然可以走，其它的子树只能走一个且走完了需要满足答案。考虑 $dp$，满的子树直接加进答案，不满的子树选最大的加入。
- 对于一个点，选出两个不满的儿子都可以加入，父亲的子树不满的情况一定可以往上到某个点使得父亲子树为空或为满，从一个不满的儿子进来到另一个即可不满的儿子出去即可。

#### 995F

- 虽然 $d$ 很大，但是最多只有 $n$ 种本质不同的权值。
- 考虑 dp 离散化后的权值，这样中间有可能有空着，所以要容斥一下（二项式反演）。
- 求答案的时候用组合数乘一下求和即可。

#### 1493E

- 最大的答案显然是和 $r$ 最高位相同，比它低的位全 $1$。$r$ 就是全 $1$ 时答案显然就是 $r$。
- 如果 $l$ 和 $r$ 的最高位不同，那么能达到最大值（选 $[2^x-1,2^x]$）。
- 如果最高位相同，那么要使得最高位有，所以区间长度一定是奇数。
- 对于一个偶数 $x$，$x\oplus (x+1)=1$。区间长度很小时特判，由于区间长度为奇数，所以最后的结果只会形如 $x$ 或者 $x\oplus 1$ 或者 $1$。那么 $r$ 是奇数答案显然为 $r$，否则区间长度够长（$\geq 5$）那么答案为 $r+1$。

#### 797F

- 显然老鼠相对顺序不会改变。
- 直接 dp，$dp(i,j)$ 表示前 $i$ 个洞有 $j$ 只老鼠的最小距离，那么 $dp(i,j)=\min_{j-c_i\leq k\leq j}(dp(i-1,k)+sum(i,j)-sum(i,k))$，$sum(i,j)$ 表示前 $j$ 只老鼠都到 $i$ 的距离。
- 把和 $k$ 有关的拿出来，拿个单调队列维护即可。

#### 1558D

- 它给出这么多，实际是给你了一些不等式 $a_x<a_y$ 或 $a_x\leq a_y$。
- 根据最后的结果，所有相邻的都是 $a_{i-1}\leq a_i$ （过程中的结果的条件一定比这个弱）。
- 其实还有一些条件，插入的时候会有 $a_i<a_p$，如果插入之前有条件 $a_{p-1}<a_p$，就把那个符号改成 $\leq$。
- 重新整理一下题意，就是现在有一个序列 $a'$，相邻两项满足 $a'_{i-1}\leq a'_i$ 或 $a'_{i-1}<a'_i$，问方案数。
- 直接做不好做，考虑把两种的形式变成一样，如果 $a'_{i-1}\leq a'_i$，可以转化成 $a'_{i-1}<a'_i+1$，为了不影响其它条件，给 $a'_i,a'_{i+1},\cdots,a'_n$ 整个后缀 $+1$，且给 $m+1$。
- 假设有 $c$ 个是 $<$，剩下 $n-1-c$ 个是 $\leq$。要从 $n+(n-1-c)$ 里选 $n$ 个数给 $a$，方案数为 ${2n-1-c}\choose n$。
- 求出 $c$ 的大小即可。一种方法是平衡树（要手写，因为和排名有关）维护插入，还有一种是线段树，倒序维护（线段树不方便维护插入），每次删掉一个数再计算贡献（注意留下的前一个对后一个就不会是小于号了）。

#### 241E

- 所有无法从 $1$ 到达的点都是没用的，所有无法到达 $n$ 的点也都是没用的。
- 由于是个 DAG，从 $1$ 到达任意剩下的点长度都唯一才行（否则不同的两条再走相同的路到 $n$ 就不合法了）。
- 这样的好处是说明了如果合法必定存在一个数组 $d$ 使得 $1$ 到第 $i$ 点的唯一距离是 $d_i$，且这个数组容易转移。
- 由于每条边只和两端点有关，那么一条边 $(u,v)$ 实际上是限制 $d_u+1\leq d_v\leq d_u+2$，直接建图差分约束即可。

#### 285E

- 恰好且数据范围很小，考虑二项式反演。
- 用 dp 来计算，不是钦定完美数的位置不需要考虑，最后阶乘计算一下即可。
- 设 $dp_{i,j,0/1,0/1}$ 表示前 $i$ 个数钦定了 $j$ 个完美数，前面一个数没选/选，当前数没选/选的方案数转移就考虑这个数钦不钦定，钦定了的话选前面的还是后面的即可。
- 最后乘上阶乘二项式反演一下即可。

#### 1519E

- 极角不同即斜率 $y/x$（$x=0$  特判）不同。
- 把点和能到的两个斜率对应的特殊点连边，两个非特殊点能匹配当且仅当有一个公共点和它们都相邻。
- 发现有特殊点非特殊点很麻烦，而非特殊点只会连两个点，不妨把它删去变成一条边，问题就变成有公共点的两条边能匹配，问匹配方案数。
- 这个就经典了，每个连通块分开考虑。先求个 dfs 生成树，从下往上考虑每个点向子树的边，如果有偶数条则直接匹配，如果有奇数条则和这个点向父亲的边匹配。只有边数是奇数会剩下一条边。

#### 235E

- $\sum_{i=1}^a\sum_{j=1}^b\sum_{k=1}^c d(ijk)$，那么考虑一个约数，尽量让它从 $i$ 中选，其次从 $j$，最后从 $k$。
$$
&\sum_{i=1}^a\sum_{j=1}^b\sum_{k=1}^c\sum_{x|i}\sum_{y|j}\sum_{z|k} [\gcd(i/x,y)=1 \& \gcd(i/x,z)=1 \& \gcd(j/y,z)=1]\\
=&\sum_{i=1}^a\sum_{j=1}^b\sum_{k=1}^c\sum_{x|i}\sum_{y|j}\sum_{z|k} [\gcd(x,y)=1 \& \gcd(x,z)=1 \& \gcd(y,z)=1]\\
=&\sum_{x=1}^a\sum_{y=1}^b\sum_{z=1}^c \lfloor\frac ax\rfloor \lfloor\frac by\rfloor \lfloor\frac cz\rfloor[\gcd(x,y)=1 \& \gcd(x,z)=1 \& \gcd(y,z)=1]\\
$$

- 如果没有 $\gcd(y,z)=1$ 的限制可以分开来计算，但是如果有，可以枚举 $g=\gcd(y,z)$ 莫比乌斯反演。那么这个 $g$ 和 $x$ 要互质，剩下的可以枚举个 $x$，其它的预处理一下计算（$\lfloor\frac a{xy}\rfloor=\lfloor\frac{\frac ax}y\rfloor$）。

#### 1557E

- 考虑把国王逼到最后一行，刚开始放在左上角。要保证任意时刻国王不在当前行和当前行上面。
- 如果某一步国王往下走，说明国王不在下一行，那么你也可以往下走。
- 如果国王一直左右横跳，则你从这一行左边扫到右边，如果它一直左右横跳，说明它不在下一行，往下走；如果它往上说明搞错了他之前不在下一行，再重新扫；如果它往下，那么你也往下。
- 由于每次它往下你也一定往下，所以它最多往下 8 次，往上也最多 8 次。它每上移动一次你都要重新扫，而本身会把所有都走一次，所以次数应该是 $2\times 7\times 8$，可以通过。

#### 1430F

- 一种是某波打完后为了之后不超时的换弹，一种是打某波过程中的换弹。
- 设 $dp_i$ 表示第 $i$ 波打完后换弹需要的最少子弹数，然后枚举下一次打完后换弹的时间，暴力求中间是否可行和需要的子弹数量。

#### 293B

- 路径上一定会有 $n+m-1$ 个点，那么 $k<n+m-1$ 一定无解。
- 且每个点和右下方的任何点都可以形成到达 $(n,m)$ 的一条路径，所以每个数和右下角的数都不同。
- 直接搜索，每个点不能和左上方的点颜色相同，用二进制状态记录哪些出现的。有一个剪枝就是如果是选一个没出现过的颜色，那么选任何的都是一样的，只需要计算一次。

#### 1153F

- 不妨变成 $l=1$ 最后答案乘上 $l$。
- 选择的线段的端点重合的方案数小一个数量级，故不需要考虑。
- 只需要考虑 $2n$ 个区间端点和随机变量 $x$ 的相对位置。
- 设 $dp_{i,j,0/1}$ 表示前 $i$ 个点有 $j$ 个左端点还没匹配，当前 $x$ 是否被选了的方案数。
- 一种就是新增一个左端点，一种是选择之前的一个左端点匹配，一种是放 $x$（要求没匹配的 $\geq k$）。
- 由于 $dp$ 时钦定了线段间和同一线段两端点顺序，所以答案是 $dp_{2n+1,0,1}\times 2^n\times n!/(2n+1)!$。

#### 1322D

- 把序列翻一下，要求选一个不降的子序列。
- 设 $f_{i,j}$ 表示攻击力为 $i$ 的有 $j$ 个人的最大收益，转移就是 $f_{i+1,\lfloor j/2\rfloor}=\max(f_{i,j}+\lfloor j/2\rfloor\times c_i)$。每次加入一个新的人更新这个数组。
- 直接暴力是 $O(n^3)$ 的，不过可以发现由于这个式子的特殊性，这一层对 $n$ 个 $j$ 产生影响，到下一层就变成 $\lfloor n/2\rfloor$ 个，再下一层 $\lfloor n/4\rfloor$ 个……，所以只会影响 $O(n)$ 个位置的值。故总复杂度 $O(n^2)$。

#### 1146G

- 这个数据范围容易想到网络流。
- 一个是代价一个是收益不好做，先假设所有的高度都是 $h$，加到初始答案，如果最后高度是 $x$ 则代价为 $h^2-x^2$。
- 给每个点往外连 $h,h-1,h-2,\cdots$ 高度对应的代价形成一条链。
- 对于每个分区限制新建一个点，在区间内的点 $x+1$ 代价的边后的点往新建点连 $+\infty$，新建点往 $T$ 连 $c_i$。
- 跑个最小割，从初始答案中减去即可。

#### 986E

- 如果差分不破坏性质，能差分就差分。
- 这题也是一样，$calc(x,y,w)$ 可以变成 $\frac{calc(1,x,w)\times calc(1,y,w)\times \gcd(w,val_z)}{calc(1,z,w)^2}$（其中 $z=LCA(x,y)$），因为逆元一定存在。而且 $w$ 也可以分解成若干个质数的幂次。
- 由于询问可以离线，你直接把询问挂到对应的点上。现在关键在于如何快速维护，由于 $\gcd$ 本质是幂次取最小值，所以要求的是到根路径上所有数这个 $p$ 的幂次和当前数取最小值求和。
- 由于询问只有 $1e5$，你可以处理出所有不同的要询问的 $p$ 的最高幂次，而幂次总和最多只有 $\log$，暴力维护所有 $p$ 幂次的个数，查询直接暴力查询（为了使得总复杂度是 $\log$，操作直接 $O(1)$，询问只枚举比它小的，比它大的用总个数-比它小的计算）。

#### 1185G2

- 这题的关键点在于顺序是重要的。
- 考虑先分开计算一种歌选出 $x$ 首使得总和为 $t$ 的方案数，类似背包转移即可，这部分复杂度是 $O(n^2T)$。
- 然后现在要考虑合并，先把三种分别有 $x_1,x_2,x_3$ 合并的方案数算出来，这个直接 dp 即可。
- 然后暴力思路是直接枚举三种个数和时间，这个复杂度显然太高。先合并两个也不行，这样复杂度是 $O(n^2T^2+n^3T)$ 的。
- 可以直接在 dp 的时候就合并两个，合并还是记录两种的数字个数，只是记录总时间，这样复杂度就是 $O(n^3T)$，应该有 $1/27$ 的常数。

#### 444E

- 虽然形式比较奇怪，但是本质上还是最小值最大，所以先考虑二分答案 $mid$。
- 二分完之后就变成存在一个序列 $p_i$ 使得所有 $g(i,p_i)\geq mid$，$g$ 对应的是最大值，也就是不存在 $(i,p_i)$ 路径上的边都 $<mid$。
- 把那些 $\geq mid$ 的边拿出来，剩下的缩起来只保留点数和其中的 $p$ 之和，每个可以和不同块的匹配，要求每个被匹配的不超过 $p$ 之和。
- 从第一块开始，每到新的一块，尽量把这一块填满（把以前放到其它位置的都放到当前位置），这样一定是其它占用它能占的最少的方案，然后再占其它的。只需要记录之前有多少个就可以判断。

#### 671C

- 区间越短答案越大。具体来说，$l$ 相同时，$r$ 越大，$f(l,r)$ 越小。
- 那么对于每个 $i$，存在一个 $r'$，使得 $r\geq r',f(l,r)\leq i$。
- 考虑 $i$ 减小会如何变化，$\gcd=i$ 的就不能在一个区间内了，$[l,r]$ 区间外最多只能有一个 $i$ 的倍数。
- 假设 $i$ 的倍数的位置分别是 $x_1,x_2,\cdots,x_k$，那么 $l\gt x_2$ 的时候直接无解，记为 $r$ 至少是 $n+1$；$x_1\lt l\leq x_2$，$r$ 至少为 $x_k$；$l\leq x_1$，$r$ 至少是 $x_{k-1}$。
- 对于每个 $l$ 维护最小的满足条件的 $r$，则 $r$ 对应的序列是单调不降的。所以这个区间 $\max$ 可以变成线段树上二分后区间覆盖。而答案可以表示为 $\sum_i [f_{l,r}\geq i]$，线段树维护一下区间取 $\max$，全局求和即可。

#### 1158D

- 网上的题解不知道在写什么。。。
- 看了看官方题解，先选一个凸包上的点（可以取 Down-Left，不需要真的建出凸包）。
- 每一步保证当前的点在剩下的点的凸包上，如果往右就选剩下极角最大的点，否则取极角最小的点。发现这样一定在剩下的凸包上且剩下的点怎样连边都不会碰到之前的点。

#### 536D

- 和图的具体形态无关，只和 $1,n$ 到它的距离有关。 先跑两次 dijkstra 求出每个点到 $1,n$ 的距离。
- 然后把这个距离离散化一下，到任意时刻，取走的一定是距离 $1$ 不超过 $x$ 或距离 $2$ 不超过 $y$ 的。
- 容易想到直接把这个记录到状态里去 dp，关键问题在于转移时怎么求出新增的点权。
- 这个可以前缀和预处理，还是把这两个记录进状态处理出 $s$。假设操作 $y$，那么新增 $s[x][y]-s[x][y']$。

#### 864F

- 字典序最小不好做，一般字典序最小路径会倒着做。
- 而数据范围很小，考虑直接枚举 $t$ 建反图倒着做，先求出哪些点能到达 $t$，然后每个点选能到达 $t$ 的编号最小的相邻点连边。
- 非成环部分形成内向树，把边反向，从 $t$ 开始 dfs，维护一个栈。把询问离线下来，就可以通过栈求出答案。

#### 1510B

- reset 显然是到达了某个关键状态后按的。直接建图难点在于：到了关键状态后还能继续走；处理 reset。
- 由于最终目标是你要到达所有的关键状态至少一次，所以每个关键状态可以建一个对应的新点替代连原先的点要连的边，$S$ 向新点建 $(1,0)$ 边，原先的点只连到 $T$ 的 $(1,0)$ 边（这样的正确性在于走的状态不会成环）。
- reset 相当于回到原点，给原点多次出发的机会，每次出发需要花 $1$ 代价（第一次出发不需要代价，最后减去）。建一个新的 $S'$ 替代 $S$ 连原先 $S$ 连的边，$S$ 向 $S'$ 连 $(+\infty,1)$ 的边。
- 跑个最小费用最大流（注意答案要 $-1$），构造方案就看每个新点连出去的最后从哪出了，变成若干条链，依次输出每一条即可。

#### 587E

- 线性基不好做区间修改，考虑变成维护相邻两个数异或（类似差分），那么就变成两个单点修改了。
- 线段树维护区间的线性基，合并直接把一个插入到另一个。询问的时候再看区间第一个数能否插入，求出线性基大小后求个 2 的次幂输出即可。

#### 1067C

- 牛逼构造题。只考虑 $n\geq 9$。
- 考虑一个 $3$ 行，$(2n-1)/3$ 列矩阵的 $i+j\equiv 0\pmod 2$ （$i,j$ 从 $0$ 开始）。
- 那么这样能把这整个矩阵填到每行只缺 $2$ 个。然后它会往上往下，每往上一层就少了最前最后两个。忽略常数项，$2\sum_i(2n/3-4i)+2n/3>n^2/9$。

#### 682E

- 看这个题面形式，容易猜到就是先求出面积最大的三角形然后坐标扩展两倍（下图红色三角形为最大三角形）。

  ![image-20220213141958045](C:\Users\hydd\AppData\Roaming\Typora\typora-user-images\image-20220213141958045.png)

- 发现如果有任意大三角形外的点，拿出它和红色三角形对应的另一侧的两点，面积一定比红色三角形大，矛盾。
- 现在问题就是找出这个红色三角形。由于三角形的三个端点一定在凸包上（假设某个 $x$ 不在凸包上，考虑另外两个点，相当于求到这个直线的距离，最远的一定在凸包上），所以枚举第一个，枚举第二个的同时双指针第三个即可。

#### 633G

- 先求个 dfs 序，把树拍平了。现在变成区间加一个数区间询问。
- 由于数据范围很小，且 $(n+q)m\leq 2\times 10^8$，所以考虑直接线段树上维护 bitset 表示区间出现过的数字，修改的时候直接平移，询问的时候 or 起来再和质数对应的 bitset 做一下 and。
- 时间复杂度 $O((n+q)m\log n/w)$。

#### 601E

- 考虑只加怎么做，只加的话每加入一个可以暴力更新背包（维护 $w$ 之和不超过 $x$ 时 $v$ 之和最大值）。
- 背包是不支持删除的，撤销是可以的。所以可以在外面套个线段树分治。
- 时间复杂度 $O(k(n+q)\log q)$。

#### 814E

- 最短路唯一而不是最短路长度唯一，这说明最短路树（bfs 树）是唯一的。
- 如果知道了最短路树，那么其它边只能在同层之间连。
- $i$ 的最短路 $\geq i-1$ 的最短路说明 $i$ 要么和 $i-1$ 同层，要么在它下一层。
- 这一层的方案只和下一层有多少点有关，要选出一个一些边（有序）给下一层的点连，再求出剩下两两连边的方案数。
- 根特殊考虑。对于其它层，可以直接设 $g[t][x][y]$ 表示下一层有 $t$ 个点，这一层有 $x$ 个 $2$，$y$ 个 $3$ 的方案数，每次要选一个给下面一层的就是选一个 $2$ 或一个 $3$ 减去 $1$。
- 当 $t=0$ 时就说明要同层匹配了，每个点都有一个父亲，所以实际度数要减 $1$。同层匹配不考虑顺序，先考虑把那些 $2$ 弄没了。考虑第一个 $2$，它可以选另外一个 $2$ 或一个 $3$ 匹配，继续转移。
- 当 $t=0$ 且 $x=0$ 此时只剩 $3$ 了，即每个度数都为 $2$，会形成若干个环，枚举第一个所在的环的大小 $c$，组合数算一下（注意翻转还是同一个，两个点的环不合法），方案数为 $(c-1)!/2$。
- 现在就考虑把这些合起来，设 $f[i][j]$ 表示到第 $i$ 个点，$i-j+1,i-j+2,\cdots i$ 在同一层的方案数。转移就枚举下一层的点数，用 $g$ 计算一下这一层的方案数，转移下去即可。
- 最后计算答案的时候别忘了还得更新最后一层内部连边的方案数。

#### 455E

- 这个 $i$ 相当于是你还剩下的步数。假设最后 $j=j'$，那么可以得到所有 $a[j'],a[j'+1],\cdots,a[i]$ 各自乘上非 $0$ 系求和，要求系数之和为 $n$。
- 如果你知道了最后的 $j'$，那么你一定会在中间 $a[j]$ 最小的位置停留最长时间（系数最大）。且如果最小的位置不是 $j'$ 那么这个 $j'$ 一定不优。
- 所以一定可以转化成先做若干步 $j-1$，然后 $j$ 一直不变，答案就是 $pre[j]-pre[j']+a[j']\times (i-(j-j'))$，把无关项分开就是 $pre[j]+(a[j']\times j'-pre[j'])+a[j']\times(i-j)$。

- 这是若干一次函数的形式，但是它还有 $j'$ 的限制（$i\geq j-j'$ 即 $j'\geq j-i$）。所以需要维护凸包或维护树套树（线段树套李超树）。
- 树套树就比较常规（不知道空间行不行），这里说一下维护凸包，其实直接线段树维护也是不行的，但是由于它是在最后加入，所以可以更新线段树区间内已经满的区间（显然只会满一次），询问的时候二分；
- 或者觉得这个东西显式建出来很难看，可以考虑对于每个 $i$ 维护后 $1,2,4,\cdots,lowbit(i)$ 个点的凸包，转移可以直接转，询问类似于树状数组跳。这样维护的总点数是 $O(n\log n)$ 的，总时间复杂度也是 $O(n\log^2 n)$。

#### 8E

- 不大于取反串说明第一个位置是 $0$。
- 考虑枚举前 $\lfloor n/2\rfloor$ 位，假设为 $x$。以下先考虑 $n$ 是偶数的情况。
- 逆序串和逆序取反串只有一个有用，如果最后一个位置为 $0$ 则只考虑逆序串，否则考虑逆序取反串，两种分别计算个数。
- 如果是逆序串，那么所有不合法的方案是：之前位相同，第 $t$ 位是 $1$，翻过来那边是 $0$，后面位任意。所以对应的不合法的方案数就是 $x$。
- 如果是逆序取反串，不取反时不合法的方案数是 $x$，那么把后一半取反方案数应该还是不变。
- $n$ 是奇数要特殊考虑中间的位置，逆序串中间的数字随意（方案 $\times 2$），逆序取反串如果两边正好相反那么中间只能填 $0$（方案 $\times 2-1$）。判断一下是不是已经够了，如果够了就再枚举后面的位然后一个一个判断。

#### 1421E

- 区间 dp 出合并成一个数，最大和最小是什么。转移很容易，但是这样是 $O(n^3)$ 的。
- 但是无论怎样最后所有数的符号都是 $\pm 1$，看看最优解的符号有没有什么规律。
- 第一步操作后，系数和减少了 $3$。看看所有的系数和 $\bmod 3$ 有什么性质，$n=1$ 一定是 $1$，$n>1$ 时每个数字都是 $\bmod 3=1$，那么合并了之后还都是 $\bmod 3=1$。所以任何时候都是 $\bmod 3=1$。
- 那是不是所有满足这个条件的都可以呢？$n=3$，$1,-1,1$ 的系数就不行，因为第一步就一定会让某两个相邻的系数是相同的。那是不是满足 $\bmod 3=1$ 且有相邻的系数相同的条件就可以呢？
- 答案是可以。证明可以考虑归纳，$n=1,2,3$ 显然成立。
- 对于相邻相同第一个长度 $\geq 2$ 的连续段 $x,x+1,\cdots,x+k-1$，如果 $x>1$ 或 $k=2$，合并 $(x,x+1)$，就和 $x-1$ 或 $x+2$ 相同了，归纳成立；否则如果 $k=n$ 且由于此时考虑 $n\geq 4$，所以合并 $(x,x+1)$ 后还有相同的；如果都不满足则说明 $x=1$ 且 $k<n$，合并 $(x+k-2,x+k-1)$。
