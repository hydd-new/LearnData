---
title: '博弈'
date: 2022-01-10 15:05:25
tags: [博弈]
categories: [CodeForces2100-2300]
mathjax: true
---


#### 1333D（#）
- 求最少和最多的次数，中间的都可以求出。
- 最多的步数是每一次删除一个逆序对，最小的步数可以贪心能翻就翻。
- 再根据最小步数的方案往大调整。


#### 936B（#）
- 先做一遍dfs，记录一下到每个点有没有长度为奇数和偶数的路径。
- 如果不存在到某个0出度点长度为奇数的路径，那么看从s开始能不能走到环。
- 没必要tarjan，直接从s开始dfs，看有没有后向边即可。
- 说一下具体原因：前向边显然可以用若干条树边替代，后向边有就一定成环，横边一定是dfs序大的连向小的。如果有后向边就成环，没有的话前向边没用，横边也一定不成环。


#### 768E
- 值域只有60。拿二进制数记录选过的，暴力跑个求sg。
- 然后就把所有sg异或起来，为0就是NO，否则是YES。


#### 1605D（#）
- 首先看条件 u \oplus v\leq min(u,v)，不妨设 u
- 所以条件就变为 u,v 最高位相同。由于是轮流操作，你还可以把树黑白染色。
- 显然所有点都不能动的构造最大。看黑白两边的节点个数 x,y，不妨设 x\leq y。
- 最高位不同的数之间相互独立，把 x 二进制分解，最高位是那些的都放到 x，剩下的都放到 y。
- 那么所有点相邻的都没有同最高位的，所以都不能走。


#### 603C（#）
- 显然不同石子堆是独立的，将sg值异或即可。
- 如果x是奇数，sg(x)=mex(sg(x-1))；如果x是偶数，sg(x)=mex(sg(x-1),sg’(x/2))。
- sg’(x)=sg(x)^sg(x)^…^sg(x)（k个），即k是奇数为sg(x)，k是偶数为0。
- k是奇数则x奇数mex(sg(x-1))，x偶数mex(sg(x-1),sg’(x/2))。
- k是偶数则x奇数mex(sg(x-1))，x偶数mex(sg(x-1),0)。
- 推出最前面的几个值，发现x是奇数值就是0，x是偶数递归即可。


#### 549C
- 分析一下最后一步能赢的情况。
- 如果是先手：
    1. 全是偶数，后手胜
    2. 全是奇数，如果数字个数是偶数，先手胜，否则后手胜
    3. 有奇有偶，先手胜
- 如果是后手：
    1. 全是偶数，后手胜
    2. 全是奇数，如果数字个数是偶数，先手胜，否则后手胜
    3. 有奇有偶，后手胜

- 具体的方法是：
- 先手：
    1. 后手操作的步数>=奇数数字个数，后手胜
    （后手不存在奇数偶数都取不完的情况，此时说明后手能取完所有偶数）
    2. 看k的奇偶性，奇数先手胜偶数后手胜
- 后手：
    1. 先手操作的步数>=偶数数字个数，看k的奇偶性，奇数先手胜偶数后手胜
    2. 其它情况都后手胜


#### 520D（#）
- 维护一个大根堆一个小根堆，里面是能拆的方块。
- 拆了之后向四周扩展，把那些能拆的也加进去。取了的用 map 标记一下。


#### 1190C（#）
- 先手如果一步就赢那么显然先手必胜。
- 不能一步就赢，那么后手可以重复先手的操作使局面不变，也可以正常操作，所以要么是平局要么是后手必胜。问题的关键就看后手能不能一步就赢。
- 枚举先手取的区间，如果左右都相同，那么就可以必胜；否则如果两边都不完全相同，后手一定不可以获胜。如果先手不能必胜且不存在后手不可以必胜，就后手必胜。


#### 594A
- 这个题就非常强大。
- 你先找到一个平衡状态，就是看上去两个人都不亏的状态，保留两个距离为 $n/2$ 的，A删两边B删中间。
- 由于A先操作，你找距离为 $n/2$ 的最近的点对。

- 首先你看这个能不能达到，你就按照自己的策略删，如果B乱删，删了我要删的，那我就跳过，最后只要保证我把想删的都删了，答案一定不比原来的大，那么B就亏了。
- 其次你看能不能比这个更优，考虑最后一步，B一定会删除它们的中位数。可以发现B可以每次在A操作完后选择中位数删除，选这个点无论怎样都不会帮A的忙（删掉他想删的左边的或右边的），而只要不帮A的忙A就不可能变得更优。


#### 731E
- 设 $dp[i]$ 表示考虑完了前 $i$ 个数的最大收益。
- 如果 $i$ 不选，从 $dp_{i-1}$ 转移。
- 如果 $i$ 选，前缀和固定为 $pre_i$，那么上一步就是另一个人选，从 $a_i-dp_{i-1}$ 转移过来。
- （也可以设 $f[i]$ 表示以 $i$ 结尾，选了 $i$，然后记录前缀最大值转移）。


#### 282D
- 一个数直接取完，如果初始就为0则先手必败，否则先手必胜。
- 两个数的时候是威佐夫游戏（Wythoff's Game），根据结论，只有任意非负整数 $k$，$([k\varphi],[k\varphi^2])$ 是必败态。不过这个值域可以直接 $O(V^3)$ dp。关于威佐夫游戏：

    ![img](https://wikimedia.org/api/rest_v1/media/math/render/svg/da3bc8f56f952f114ce374df1665ae87db647779)

    ![img](https://wikimedia.org/api/rest_v1/media/math/render/svg/8c063f3289e36f1f3f0fc9fdbc13f73ad7464400)

    详见：https://en.wikipedia.org/wiki/Wythoff%27s_game
- 三个数，结论是它和普通nim一样。为什么呢？
    - 如果 $a\oplus b\oplus c\neq 0$，你和普通 nim 一样可以到 $a\oplus b\oplus c=0$ 的。
    - 如果 $a\oplus b\oplus c=0$，你看看能不能翻盘。假如变成 $(a-x)\oplus (b-x)\oplus (c-x)$，考虑 $x$ 的最低位 $k$，所有数 $\bmod 2^{k+1}$，那么原先异或为 $0$ 说明第 $k$ 位有 $0/2$ 个 $1$，减了之后就变成 $3/1$ 个 $1$，一定不为 $0$，不能翻盘。

#### 850C
- 不同质因子的贡献是独立的，可以用sg合并。
- 分解质因数，对于同一个质因子，求出每个数字中这个质因子出现次数（$0$ 不需要加入），那么现在总数字个数不超过 $9n$（$2*3*5*7*11*13*17*19*23*29>10^9$）。
- 现在就变成选一个 $x$，把所有 $\geq x$ 的都减去 $x$，问多少步能都变成 $0$。
- 因为是都变成 $0$，而值相同的数受到的影响是相同的，所以只需要记录每个数是否出现过。状态只有 $30$ 位。
- 把出现过的位置记录成二进制数 $s$，那么一次选 $x$ 的操作变为 $(s\&(2^x-1))|(s/2^x)$。
- 这个可以暴力记忆化，分析复杂度可以考虑认为前 $2^{20}$ 个状态是预处理的。


#### 377C
- 如果操作不是前 $m$ 大的一定不优，
只会操作前 $m$ 大的。
- pick的时候，如果misspick，还是会随机一个给你，还不如你手动pick。
- ban的时候，如果你missban，$m$ 还是会 $-1$，即相当于你ban了最小的，还不如你手动ban。
- 你直接记录二进制状态表示哪些英雄被ban/pick了，当前操作的人在最优策略下的优势。
- 转移的时候就考虑当前和上一个的人是否相同，不相同前一个系数是负的，相同系数是正的。如果是ban不会加上 $a_i$，否则加上 $a_i$。


#### 1584E（#）
- 操作显然和顺序无关。先考虑整个序列。
- 由于 $1$ 只有一个相邻的，所以 $(1,2)$ 一定被减了恰好 $a_1$ 次，然后 $(2,3)$ 一定被减了恰好 $a_2-a_1$ 次，$(3,4)$ 一定被减了恰好 $a_3-a_2+a_1$ 次，以此类推。
- 现在 $1,2,\cdots, n-1$ 已经满足，而 $(n-1,n)$ 被减了 $a_{n-1}-a_{n-2}+a_{n-3}-\cdots$ 次，要求和 $a_n$ 相等，即 $a_n-a_{n-1}+a_{n-2}-\cdots=0$。
- 次数必须 $\geq 0$，否则不合法。
- 对于 $r$ 维护合法的 $l$，$r$ 变成 $r+1$ 就是给所有的都取反然后加上 $a_{r+1}$，此时新变成不满足的那些，把它们删去。再加上现在和为 $0$ 的还满足的个数。


#### 317D
- 对于每个不是别的数的次幂 $x$，你选了个 $x^a$，那么 $x^{2a},x^{3a},\cdots$。
- 求出最大的 $c$ 满足 $x^c\leq n$，那么每次选一个 $a$ 就是把所有 $a$ 的倍数的位置都标记成不能选。这个可以暴力二进制记录状态计算。
- 打表打出sg值，然后询问对次数可以大于 $1$ 的sqrt个暴力异或，>sqrt的直接求出个数异或。


#### 812E
- 它给的这个奇偶性相同的条件非常有意思。把一堆石子移到下一层又很像阶梯nim。
- 把叶子节点的层当作有效层，往上一层是无效层，以此类推。
- 那么就和阶梯nim完全一样，你从无效层移到有效层另一个人可以复读，所以就是所有有效层上点 $a$ 的异或和。
- 如果初始异或和就是 $0$，那么要求交换后异或和还是 $0$，满足条件要么是有效层之间交换或无效层之间交换，要么是有效层和无效层两个值相同的交换。
- 如果初始异或和不是 $0$，那么要求选有效层的一个和无效层的一个要求值异或起来恰好是当前异或和。


#### 255E（#）
- sg打表，从四次根号到二次根号里求个mex。
- x比较小直接输出sg值。
- x比较大，开个根号就足够小了，预处理前缀和计算sg为j数量，就可以求mex了。
- 可以发现sg值不大，所以可以直接暴力。

- 有另外一种方法是直接打表，sg值是整段出现的。
- <4的值为0，<16的值为1，<82的值为2，<6724的值为0，<50626的值为3，<2562991876的值为1，剩下的值为2。（大概也能看出来是成段出现的，4次根号和2次根号跨度很大，当n很大的时候下界都差不多）。


#### 167C（#）
- f(a,0)=0,f(a,1)=1。要求f(a,b)（a>=b），先考虑f(b,a mod b)，如果是必败那显然直接取。
- 如果是必胜，那么考虑做f(a-b^k,b)，但是你发现还得a-b^k>=b，否则相当于变成a mod b了，而且你无论减多少次b^k，a mod b的值还是不变。
- 将a-b^k看成a-(b^{k-1})b，那么不能减到a-[a/b]b。所以问题变成，初始是a/b，每次可以取b^0,b^1,…，取完的人失败。
- 这个东西和巴什博弈（减法博弈）比较像，考虑和那个一样每次无论对方做什么操作，都可以把它移到一个必胜态。考虑在mod (b+1)下，只有取1和b两种，你可以控制它mod (b+1)的值不变，同理对面也一样。最后到<b+1的，胜负就和奇偶性有关（奇败偶胜）。
- 如果mod (b+1)是奇数，那么后手直接和你反着来，你去mod (b+1)为1的他取b，反之亦然，你就输了。否则如果是偶数，如果当前数mod (b+1)不为0，你直接取1，就能使它mod (b+1)的值减少1（变成奇数），否则取b，使得它mod (b+1)的值为1（奇数）。
- 对于原问题，就递归看f(b,a mod b)是否必败，如果必败那么当前状态必胜，否则就按照上述方法计算。


#### 305E
- 有个暴力的 $dp$，就是记 $dp_{l,r}$ 表示 $l..r$ 的答案，转移就枚举切分点 $k$ 满足 $a_{k-1}=a_{k+1}$，从它们 $dp_{l,k-1}\oplus dp_{k+1,r}$ 的 $\operatorname{mex}$ 转移即可。
- 我们称满足 $a_{k-1}=a_{k+1}$ 的点 $k$ 为断点，那么一个（除了两端点）没有断点的段是无法操作的。
- 考虑断点形成的极长连续段，那么不同的极长连续段，无论怎么操作都是独立的。对于独立的我们可以用sg解决。
- 所以只需要预处理所有极长连续段的sg值，现在状态就是一维的了，可以直接暴力枚举分割点的位置 $\operatorname{mex}$ 转移。
- 它要求输出最小的第一步，枚举第一步判断是否可行即可，总复杂度还是 $O(|s|^2)$ 的。


#### 36D
- 反过来方便点，记从 $(n,m)$ 开始往左/上/左上k步是必胜还是必败，$f(1,1)=0$（必败）。
- 那么直接转移是 $f(i,j)=\operatorname{not}(f(i-1,j)\operatorname{and}f(i,j-1)\operatorname{and}f(i-k,j-k))$。
- 没有 $f(i-k,j-k)$，就是普通的黑白染色，$i+j$ 为偶数的为 $0$，其它为 $1$。$i\leq k$ 或 $j\leq k$ 就是这种情况。
- 否则，考虑 $k+1$ 行剩下的列，那么 $f(i-1,j)$ 和 $f(i-k,j-k)$ 对应的颜色一定不同，所以 $f(i,j)$ 一定是为 $1$。$k+1$ 列同理。
- 对于 $k+2\cdots 2k$ 行，$k+2\cdots 2k$ 列剩下的，首先可以发现因为 $f(i-k,j-k)=(i+j)\bmod 2$，所以如果 $(i+j)\bmod 2=0$，那么 $f(i,j)=1$，否则 $(i+j)\bmod 2=1$ 的左/上/左上k步都是 $1$，$f(i,j)=0$。
- 对于 $2k+1$ 行剩下的，和 $2k$ 行没啥区别，那些 $(i+j)\bmod 2=0$ 的还是 $1$，剩下的左/上/左上k步都是 $1$，$f(i,j)=0$，$2k+1$ 列同理。
- 对于 $2k+2$ 行剩下的，这就不一样了，它减去 $k$ 是 $k+1$ 行，就已经是和 $(i+j)\bmod 2$ 反过来了，所以 $f(i-1,j)$ 和 $f(i-k,j-k)$ 对应的颜色一定不同，一定都是 $1$，$2k+2$ 列同理。
- 之后的分析就差不多，$2k+3\cdots 3k+1$ 行又变成正着来了，$3k+2$ 行也依旧同理，$3k+3$ 行依旧是 $1$。
- 所以就是 $k+1,2k+2,3k+3,\cdots$ 一定都是 $1$，剩下的，$\bmod (2k+2)<k+1$ 的正着来，否则反着来。
- 当 $n>m$ 交换一下，只考虑 $n/(2k+2)$ 的值，行列减去这么多 $\times (2k+2)$。


#### 335C
- 如果你放了 $(x,y)$，那么 $(x-1,y\oplus 1),(x,y\oplus 1),(x+1,y\oplus 1)$ 都不能放。
- 发现之后上下就独立了，考虑设 $dp(l,r,s,t)$ 表示只考虑 $l..r$ 行，$l$ 行状态为 $s$ 的位置不能放，$r$ 行状态为 $t$ 的位置不能放的 $sg$ 值。
- 然后就枚举在哪里放，还是分成上下两部分，异或起来求 $\operatorname{mex}$ 即可。


#### 48E（#）
- bfs，到一个点就枚举怎么打，计算杀龙的最小步数。
- 如果不行，那就判断是否组成回路。
- 还是不行那就计算最终成为龙的食物的最大步数。
- 后面两个可以用dfs计算。


#### 38F
- 先暴力求出所有串的权值，建图，就变成了一个 $DAG$。
- 现在就是在 DAG 上 $dp$，记录一下每个点的胜负状态，先手取这个点的能得到的双方权值。
- 如果是必败态，就找后继后手尽量大，其次先手尽量小的。如果是必胜态则额外要求在后继的必败态里找。


#### 1431G（#，严谨正确性证明？）
- 先发现一个结论，Alice选了一个数后，Bob一定会选比它大的最小的。
- 把选出的数分成若干段，那么每段一定长度为偶数，而把前一半Alice选，后一半Bob选一定最大，Alice从中间开始往左边选。
- 直接二维dp，记录当前到 $i$，选了 $j$ 个。转移就枚举当前连续段 $x$ 的长度。


