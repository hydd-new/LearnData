---
title: 'binary_search'
date: 2022-01-18 20:25:40
tags: [binary_search]
categories: [CodeForces2100-2300]
mathjax: true
---

#### 1284D
- 两场讲座要么在 $a,b$ 都不冲突，要么在 $a,b$ 都冲突。
- 也就是对于某场讲座，在 $a,b$ 中和它不冲突的讲座形成的集合是相同的。
- 需要一种和顺序无关且能快速计算的判断方法，可以使用随机权值，异或起来判断是否相同。
- 而不相交的也就是右端点比它左端点小或左端点比它右端点大，存个前后缀异或和即可。
- 其实还有确定性的算法，就是你考虑和 $a$ 不冲突的中和 $b$ 冲突的，把右端点比它左端点小的区间的 $b$ 在线段树/树状数组（离散化）上覆盖，然后查当前 $b$ 区间上有没有被覆盖，其它的情况同理。


#### 1059D
- 如果 $x$ 轴上下方都有点，那么一定无解。否则把所有点都放到 $x$ 轴及以上。
- 半径是有可二分性的，半径大的，圆心依旧在原来的 $x$，能覆盖的只多不少。
- 二分完半径 $r$，就可以求出它合法的 $x$ 区间，对于每个点 $(a,b)$，求出和它 $x$ 方向上距离的范围，假设 $x$ 方向距离为 $d$，那么 $d^2+(b-r)^2\leq r^2$，可以解出 $d$ 的范围，即 $x$ 要在 $[a-d,a+d]$，求交最后看交是否为空决定二分上下界的变化。


#### 689D
- 固定了 $l$，$r$ 一定在一个区间，求出合法的第一个 $r$ 和最后一个 $r$。双指针维护两个 $r$。
- 预处理 ST 表来求区间最大最小值。


#### 1167E
- 枚举 $l$，对于 $r$ 一定是越大越容易满足。题目相当于是去掉 $[l,r]$ 中的数后不存在逆序对。
- 比如当前是 $l,r$，变成 $l+1$ 后，有可能出现一些 $l$ 做较大值或较小值的逆序对。- 做较大值就无解，判断方法是可以维护不超过 $l-1$ 的数的最靠后的位置和为 $l$ 的数的最靠前的位置。
- 做较小值就找为 $l$ 的最靠后的位置，它之前的最大值（如果存在且比它大）就不能出现。
- 所以只要维护每种数字最靠前/最靠后的位置和前缀最大值即可。


#### 1626D
- 枚举最小和最大补全到的2的次幂，那么不超过枚举的个数时，一定选尽量多的。因为你留下来，最多也就能给中间的少那么多，而放两边是一定会少的。
- 对于每个2的次幂，求出最小和最大不超过2的次幂最多能选多少，就可以计算了。


#### 1039B
- 先二分大概缩小一下范围，每次更新完 $l,r$ 后，$l$ 还要减去 $k$，$r$ 还要加上 $k$。
- 到某个范围再随便问一个，如果不对再调整上下界，从头开始整个过程。


#### 875D
- 区间或一定大于等于区间最大值，所以只需要求等于的情况。
- or 一定不超过 log 次变化，对每种 or 里二分即可，单调栈维护 or，ST 表查询区间最大值。


#### 333D
- 这题也太妙了。
- 最小值最大，先二分答案，把 $\geq mid$ 的都标记。
- 现在就是看有没有能组成矩形的四个点都被标记。枚举每一行，枚举有数的两列，如果之前出现过这样的两列，则返回 1，否则标记这两列为出现过。
- 这样每一列最多被标记一次，所以复杂度是 $O(n^2\log n)$。


#### 813E
- 每个区间同一种数字只考虑最后 $k$ 个，也就是对于区间里的数，如果它之后第 $k$ 次出现还在区间内就不计算贡献。
- 也就是对于 $[l,r]$ 内的数，把它之后第 $k$ 次出现的位置拿出来，求 $\gt r$ 的数字个数。预处理每个数的这个位置，询问的时候用主席树来查询区间 $\gt r$ 的数字个数。


#### 369E
- 一眼正难则反，正着一个区间可能包含多个点，而反过来区间只能在相邻点之间。
- 然后，把询问离线，变成了给你一些 A 区间，给你一些 B 区间，求出每个 B 区间包含了多少 A 区间。
- 这个就可以右端点从小到大，其次左端点从大到小排序，询问就是问一个后缀数的个数，树状数组即可。


#### 56E
- 首先先排序，排完之后，考虑这个骨牌推倒了到哪个位置。
- 那么当前位置到推倒到的这个位置之前的这些都倒了，它们能倒的距离是它们中的权值的最大值，树状数组维护前缀最大值即可。


#### 85D
- 先离线后离散化。
- 线段树上维护区间内 $\bmod 5=0,1,2,3,4$ 的答案。
- 合并从左儿子的 $x$ 和右儿子的 $(sz_{ls}-x)\bmod 5$ 转移过来。
- 插入一个数，到叶子节点修改一下权值和 $sz$，往上的时候再合并求出其它点的影响。


#### 1268C
- 由于最后一定会变成连续的，且逆序对至少交换一次，所以不如先把 $1..k$ 放到一起再交换。
- 放到一起一定尽量靠近最中间的数。$k$ 增加时，新增的逆序对数就是以新的 $k$ 开头的逆序对数，树状数组查询即可。
- 至于最中间的数 $x$，维护两个set，一个存 $x$ 及左边的数，一个存 $x$ 右边的数，如果大小差 $>1$ 说明要调整两个set的数，同时维护两个set的位置之和即可计算移动的贡献。


#### 620D
- 不交换直接计算答案。
- 交换一次可以暴力枚举上下交换的是哪两个数。
- 交换两次可以暴力枚举 $a/b$ 中交换的两个数存到两个数组，然后排序，在上面双指针或二分找使得答案最小的。


#### 809B
- 数据范围是 $3\log n$ 级别的，考虑二分。
- 如果你确定 $[l,r]$ 内有，那么询问 $(mid,mid+1)$（$mid$ 为常规的 $\frac{l+r}2$），返回TAK说明左边一定有，否则右边一定有。然后就能求出第一个被选中的位置 $x$。
- 求出第二个也一样，对 $[x+1,n]$ 再做一次即可（$mid$ 为常规的原因就是让左边的区间长度一定不比右边小，不会导致递归到一个区间内没有选中位置的区间）。


#### 425D
- 什么经典题。
- 还是分成大行和小行，大行是点数 $\gt \sqrt n$ 的，小行是点数 $\leq \sqrt n$ 的。
- 有小行的就枚举小行内的两个，四个点坐标都确定，判断一下是否可行。
- 两个大行就枚举两行，边长就确定。然后枚举每一列，那么四个点的坐标都确定，判断一下是否可行。


#### 862E
- $f(j)$ 中 $a$ 的贡献和 $j$无关，预处理出其中 $b$ 的贡献为 $c_i$（$b$ 在后面操作不变），就变为 $f(j)=\mid\sum (-1)^{i-1}a_i+c_j\mid$，维护 $\sum (-1)^{i-1}a_i$。
- 修改后容易维护这个值 $s$。因为求的是答案最小值所以可以把 $c$ 排序，就变成求和 $s$ 差值最小的数，lower_bound 然后判断即可。


#### 1070E
- 可以二分答案，也就是至少做的任务数，任务越多时间一定越长。且你做一定会把最小的若干个给做了。
- 求出做这么多任务最小的难度，然后扫一遍求一下需要的时间，看是否可行即可。
- 最后输出它的难度。


#### 730C
- 先二分答案，然后对于距离在答案内的，从小到大购买，如果能在规定的距离内满足数量和总价两个条件，此答案就可行。


#### 1136E
- 把式子边长 $a_i>a_{i+1}-k_i$，但是两边形式不同，改成 $a_i-\sum_{j=1}^{i-1} k_i>a_{i+1}-\sum_{j=1}^i k_i$。
- 令 $c_i=\sum_{j=1}^{i-1} k_i,b_i=a_i-c_i$，加操作就先给 $b_i$ 加，然后之后连续一段小于它的数都变成它，询问就把区间 $b,c$ 的和求出来。
- 再线段树上二分找到之后比它大的第一个数，中间区间赋值即可。区间赋值，求区间和/最大值。


#### 1379D
- 只需要知道所有 train 的 $m_i$​ 对 $\frac{m}{2}$​ 取模的结果即可（一天每隔 $\frac{m}{2}$ 分钟就有一辆车）。
- 现在要在 $0$ 到 $\frac{m}{2}-1$ 的环上取一段长为 m-k+1 的区间，使区间内发车的 train 数量最多。
- 复制两份，把 train 排序，双指针即可。


#### 762E
- 把所有电台按照 $r$ 从小到大排序，一对 $(i,j),i<j$ 有贡献当且仅当 $|x_i-x_j| \leq \min(r_i,r_j),|f_i-f_j|\leq k$。
- 现在就变成静态二维偏序了，CDQ分治+树状数组即可。


#### 400E
- 每一位显然是独立的，拆开来。
- $s[i][j]=\operatorname{and}_{k=0}^{i-1} a[j+k]$，所以 $\operatorname{and}$ 起来为 $1$ 的必须所有的数字都为 $1$。
- 维护所在的1的段的长度和答案即可。


#### 138C
- 对于蘑菇，求它不被砸到的概率。
- 对于每个左区间的数，要乘上不往左边倒的概率；对于每个右区间的数，要乘上不往右边倒的概率。区间乘也可以类似差分在 $l$ 乘在 $r$ 除。
- 把这样对端点的操作排序。对于每个蘑菇就知道了概率，和它的价值相乘后累加。


#### 65C
- 你在时刻 $x$ 能抓到，由于你速度不比他慢，之后也能抓到。
- 所以可以二分，二分完了之后求出它在哪个位置，看我从开始就走到那个位置的时间是否不超过二分的值，如果是就可行。


#### 387E
- 容易想到建立笛卡尔树，然后那些需要删的点，贡献是它们子树的大小之和。
- 其实没必要真的把树建出来，求出前后第一个比它小的，就知道它在笛卡尔树上的子树大小。这个可以用 set 解决。


#### 852D
- 显然可以二分。提前 floyd 预处理任意两点最短路。
- 人放一边点放一边，把能到达的连边跑二分图匹配。
- 如果匹配数量够表示当前答案可行。


#### 24E
- 先把所有子弹按照 $x$ 坐标从小到大排序。如果相撞就是前面往右的子弹和后面往左的子弹相撞。
- 按照原来的顺序扫，然后维护之前往右的子弹的现在最大的 $x$ 坐标，如果当前是往左的且 $x$ 坐标不比它大那么就相撞，当前答案合法。


#### 883C
- 枚举其中一种用了多少次，然后另一种如果比直接贵就直接下载。
- 否则你就尽量用另一种，最后剩下的一小部分可以考虑直接或者用另一种。
- 两种反过来也要做一下，因为否则枚举不到最后小部分用第一种的情况。


#### 431E
- 二分答案，那么 $>mid$ 的都不管，不能选进来。
- $\leq mid$ 的，每个能加入 $mid-now$。维护 $\leq mid$ 的个数和数字和，线段树上二分即可。


#### 70C
- $x$ 增大，满足条件的 $y$ 减小。
- 双指针维护，条件可以变为 $a/rev(a)=rev(b)/b$。
- 维护 map 表示已经加入的数的 $rev(b)/b$，加新的数时看一下和 $a/rev(a)$ 相同的个数。


#### 253E
- 显然是满足可二分性的，如果答案偏小就降低优先级，否则提高优先级。
- 判断就按照优先级模拟即可。注意它要求优先级互不相同，你可以认为相同情况下它优先，最后在处理一下。


#### 1575B
- 首先可以二分答案，因为假设半径 $r$ 可以，你选的圆心点为 $A$，那么扩大 $r$ 后，依旧认为线段 $OA$ 在直径上，这样覆盖的一定包含原来覆盖的。
- 固定了 $r$ 后要判断，具体的方法是，首先圆心里 $O$ 距离为 $r$，说明它要在以 $O$ 为圆心半径为 $r$ 的圆周上。
- 那么对于其它点，它如果被覆盖说明到圆心距离不超过 $r$，也以它为圆心作一个圆，要在和 $O$ 为圆心的圆相交的弧上（你发现弧一定是劣弧，可以求出交点后判断是哪一边的弧）。
- 现在只要求交点，这个其实不用解方程。要找到点使得到两个距离都为 $r$，可以先考虑求出两点的中线，在中线上找满足条件的点的度数（弧度制），三角函数解一下即可。
- 给弧度范围加，左加右减，然后扫一遍即可。


#### 774B
- 总宽度固定，一种选的多另一种就选的少。
- 两种价值从大到小排，相同的情况下宽度从小到大排，第一种选一个前缀，第二种就能选多少就选多少，双指针即可。


#### 1488F
- 每个数维护前一个比它大的时刻。
- 对于询问，从 $r$ 开始，每次跳到前一个比它大的，中间的收益都在当前位置卖。
- 可以用倍增在线求出答案，也可以离线，建出森林，维护栈，二分解决。


