---
title: 'dp'
date: 2022-01-12 10:17:25
tags: [dp]
categories: [CodeForces2100-2300]
mathjax: true
---


#### 1433F
- 求出一行选取不超过一半，$sum \bmod k=x$ 的和的最大值。记录 $dp[i][x]$ 表示到这一行第 $i$ 个，当前 $sum \bmod k=x$。转移考虑当前的数加不加，分别转移到 $dp[i+1][x],dp[i+1][(x+a[i])\bmod k]+a[i]$。
- 不同行合并就是直接每行循环 $\max$ 卷积起来，$x[i]+y[j]\rightarrow z[(i+j)\bmod k]$。


#### 1187E
- 明显只和第一次选的点有关，和其它的顺序无关。第一次选了点 $u$，令 $u$ 为根，最后的权值为所有点子树的 $size$ 之和。
- 换根的时候只会影响两个点的 $size$，维护 $size$ 之和即可。


#### 1486D
- 区间升序排序应该比较敏感，可以二分答案，假设中位数 $\geq x$。把 $\geq x$ 的位置变成 $1$，$\lt x$ 的位置变成 $-1$。
- 判断答案是否可行就是看是否有长度为 $k$ 的区间和 $\geq 0$（$\geq x$ 的数至少有一半）。


#### 519E
- 显然两点简单路径上只有中点是可行的，没有中点就没有可行点。
- 发现要到其它点一定先在路径上走，走到某个点再出去，而出去的路对于两个点是一样的。换而言之，只能是路径上离它最近的点是中点的点才行。
- 求出路径的中点，看它是不是 LCA。如果是，那么在所有点除去路径上相邻两点的子树的其它点都是可行的；如果不是，那么在它的子树除去路径上是它儿子的相邻点（相邻点一定一个是它父亲一个是它儿子）的子树的其它点是可行的。


#### 455C
- 根据经典结论，**两棵树合并后的直径一定是原来直径端点两两距离的最大值**。
- 为了长度最小，一定选两棵树直径中点连接，那么现在的直径长度就是第一棵树本身直径长度，第二棵树本身直径长度，两棵直径长度/2上取整之和的最大值。发现和端点没啥关系，只与长度有关，记录长度即可。
- 用并查集维护每个点所属连通块。


#### 165E
- 对于每个 $x$，相当于要求 $y\subseteq \neg x$
- 做高维前缀和求出所有 $\subseteq v$ 的数字是否出现，出现过的某个位置即可。


#### 319C
- 砍倒最后一棵树后其它树后其他树就都不需要代价了。
- 设 $dp[i]$ 表示砍倒第 $i$ 棵树的最小代价，那么 $dp[i]=\min\{dp[j]+b[j]\times a[i]\}$。
- 考虑 $x<y$ 且 $x$ 比 $y$ 更优，移项可得 $\frac{dp[y]-dp[x]}{b[x]-b[y]}>a[i]$，$i$ 越大，$a[i]$ 越大，越不容易满足，维护单调队列斜率优化即可。


#### 1393D
- 固定菱形的中心，发现要满足条件，距离它在半径内的所有点颜色都得相同。
- 对每个点求出最近的和它颜色不同的点的距离，可以bfs转移。


#### 628D
- 还是正常一样两个答案相减，不过可能 $l-1$ 直接少了1位，所以用 $solve(r)-solve(l)+ok(l)$。
- solve的时候就不用考虑前导0了，直接奇数位偶数位都按照限制来，记一下到哪一位，现在 $\bmod m$ 的值，有没有压上界即可。
- ok直接枚举每一位判断。


#### 734E
- 把同色点缩起来。
- 现在就变成每条边相邻的点颜色不同。这个需要的步数很好算，求出直径的中点，每次取反即可。所以需要的步数是 $\lceil \frac{x+1}2 \rceil$。


#### 1006F
- 这种 $k$ 很大的，如果是一维一般考虑 meet in the middle。
- 现在是二维，也差不多，考虑折半搜索。求出距离起点为 $n-1$ 的，距离终点为 $m-1$ 的，每个点看 $\oplus k$ 在另一边走过来有没有，map记录即可。


#### 1110D
- 记录一下以 $i/i+1$ 为中心的顺子选了几个。
- 每一种都不可能选 $\geq 3$ 个，因为这样可以拆成三个刻子。
- 枚举上一个的状态，转移即可。

#### 1353F
- 假设 $(1,1)$ 的高度变为了 $h$，那么只有高度为 $(i-1)+(j-1)+h$ 的点 $(i,j)$ 可以经过。
- 同样道理，只有 $a_{i,j}-(i-1)-(j-1)$ 的 $h$ 才有可能。
- 枚举所有可能的 $n^2$ 种 $h$，然后 $dp$，设 $dp[i][j]$ 表示到 $(i,j)$ 的最小代价，从左或上转移即可。


#### 713C
- 令 $a[i]-=i$ 变成单调不降。最后出现的数一定在现在的 $a$ 中出现过，否则你可以不停的给没出现过的 +1，答案只会变小。
- 把 $a$ 排序去重得到序列 $b$。
- 设 $f[i][j]$ 表示在第 $i$ 个位置放数字 $b_j$ 的答案。
- 转移就从 $f[i-1][\leq j]+|a_i-b_j|$ 的最小值转移过来，记录 $f[i][*]$ 前缀最小值即可。


#### 833B
- 设 $dp[i][j]$ 表示前 $i$ 个数分成 $j$ 段的最大价值，转移就是枚举段的开头。
- 很容易发现，固定 $j$，转移权值从 $i$ 到 $i+1$ 是给一个后缀+1。所以满足决策单调性。
- 枚举第二维，第一维分治即可。


#### 1446C
- 先建个trie树。异或值最小的首先得满足是 $lcp$ 最长的。
- 对于某个点的两个儿子，要么有一个儿子的子树没选点，要么有一个儿子的子树只选了一个点（都有 $\geq 2$ 个点直接两边内部连边，不连通）。
- 不考虑两条边重合变成一条边的情况，那么就变成，要最后是一个基环树，并且基环树的环的大小为 $2$。
- 分类讨论：
    - 有子树没选点，就直接做另一个子树（要求选点数 $\geq 2$）；
    - 如果两个子树都只选了一个点，那么就造了一个大小为 $2$ 的环；
    - 有一个子树只选了一个点，另一个子树选 $\geq 2$ 个点，直接递归大的子树，选了一个点的子树一定和其它不会成环。
- 设 $dp[u]$ 表示 $u$ 子树最多可以选多少个点，转移即可。


#### 1156D
- 枚举01分界点 $u$。那么答案就是 $\sum_u (d[u][0]\times d[u][1]-1)$，其中 $d[u][0/1]$ 表示从 $u$ 出发只经过 $0/1$ 的边能走到的点的数量，$-1$ 是因为去掉只有 $u$ 一个点。
- 这个就维护 $0/1$ 两个并查集，把每个点只通过 $0/1$ 的边走到的连通块并起来。$d[u][0/1]$ 分别是属于 $0/1$ 的连通块大小。


#### 383D
- 设 $dp_{i,j}$ 表示 $1..i$ 的一个后缀和 $=j$ 的方案数，转移就是一种是只有 $i$ 一个树，另一种是从 $dp_{i-1}$ 转移过来。


#### 1215E
- 根据经典结论，最后同颜色的一定相对顺序不变。
- 二进制记录之前出现了哪些，相当于求个逆序对，同颜色的递增排，之前出现的值比它们小，就看每个数后有多少个之前出现的数即可。


#### 13C
- 713C的后半部分。
- 把 $a$ 排序去重得到序列 $b$。
- 设 $f[i][j]$ 表示在第 $i$ 个位置放数字 $b_j$ 的答案。
- 转移就从 $f[i-1][\leq j]+|a_i-b_j|$ 的最小值转移过来，记录 $f[i][*]$ 前缀最小值即可。


#### 771C
- 设 $dp[u][i][0/1]$ 表示 $u$ 的子树到 $u$ 距离 $\bmod k=i$ 的点数和跳的次数之和。
- 从 $\bmod k=0$ 到 $\bmod k=1$ 需要多跳 $1$ 次。
- 换根 $dp$ 转移，最后注意答案要除以 $2$（无序对）。


#### 466D
- 用 $h$ 减去每个数。然后就要所有数都变成 $0$。
- 再差分，区间操作就变成单点操作了。还是要求每个位置都为 $0$。
- 差分值为 $1$ 说明这里要放左端点，这里开始之后的都减 $1$。
- 差分值为 $-1$ 说明之前要放右端点，这里开始之后的都减 $1$。
- 差分值为 $0$ 可能是之前放了个右端点这里又放了个左端点。
- 差分值为 $1$ 的新增一个左端点，差分值为 $-1$ 的选择之前的一个左端点匹配，差分值为 $0$。


#### 1482E
- 暴力 $dp$ 是 $f[i]=\max_{j<i}\{f[j]+val(j+1,i)\}$。
- 这个权值只和最小值位置有关，维护一个单调栈，存后缀最小值。
- 那么转移就从单调栈里的元素 $x$，$\max_{j\leq x}\{f[j]\}+b_j$ 更新当前的值。
- 发现这个和 $i$ 没有关系，维护这个值和这个值的前缀最大值，方便弹栈的时候更新。


#### 1223E
- 设 $dp[u][0/1]$ 表示以 $u$ 为根的子树，$u$ 和父亲没有/有一样的颜色的最大贡献和。
- 转移首先是 $\sum dp[v][0/1]$，然后选最大的 $k/k-1$ 个 $dp[v][1]+cost(u,v)-dp[v][0]$ 非负的分别转移到 $dp[v][0/1]$。


#### 1198D
- 要分割使答案更小要么行上切一刀，要么列上切一刀。
- 所以设 $dp[x1][y1][x2][y2]$ 表示这个矩形的最小代价，转移就枚举在哪行切分成两部分，当然还有全部都覆盖的情况，取最小值。


#### 1238E
- 你考虑二进制记录哪些字符在之前出现。
- 这个相邻的绝对值之差，如果另一个在之前出现则当前是正贡献，否则是负贡献，计算一下加进状态。
- 具体怎么看有多少负贡献多少正贡献？先求出相邻两个字符分别为 $a,b$ 的个数，转移就是当前字符，另一个在当前二进制里的都是负的，其它都是正的。
- 你可以预处理一个字符 $c$ 和一个二进制状态的贡献，转移就从二进制状态去掉 lowbit 转移过来。


#### 1552F
- 你走到某一个位置，那么之前的一定都是 active 的。
- 设 $dp[i]$ 表示走到 $i$（$1..i$ 都是 active 的）被传送回去需要多久才能离开 $i$，那么转移就是你先被传送到 $y_i$，而 $y_i$ 一定是 active 的，你需要先从全 active 的状态从 $y_i$ 走到 $y_{i+1}$，再走到 $y_{i+2}$，依次类推。所以 $dp[i]=1+\sum_{j=y_i}^{i-1} dp[j]$，记录前缀和转移即可。


#### 1185G1
- 直接状压 dp，记录当前选过的歌的状态，最后一首歌的编号。
- 转移枚举选了哪首歌即可。


#### 1077F2
- 这个一眼单调队列。
- 设 $dp[j][i]$ 表示当前到 $i$ 且选了 $i$，总共选了 $j$ 个元素的最大和。
- 先枚举 $j,i$，要从 $a_i+\max_{i-m\leq k<i} dp[j-1][k]$ 转移过来，显然是单调队列（滑动窗口）的形式，维护即可。


#### 543D
- 设 $f[u]$ 表示 $u$ 的子树到 $u$ 都满足条件的改良道路的方案数。
- 转移看所有 $v$，如果 $v$ 到父亲的路不改良，那么 $v$ 的子树只有一种方案（全部改良），否则随意。即 $f[u]=\prod (f[v]+1)$。
- 然后换根 $dp$，注意要把 $f[v]+1$ 除掉，但是可能没有逆元，所以 $f[u]$ 要记录有多少个 $0$，非 $0$ 的乘积，才能换根。


#### 1106E
- 如果你选了某个红包，由于 $s_i\leq t_i\leq d_i$，所以之后 $d_i$ 秒能选的红包一定不会再选到这个红包。
- 设 $dp[i][j]$ 表示现在到 $i$ 秒，之前干扰了 $j$ 次，由于你在Bob本身要跳过的时候干扰是无效果的，所以第 $i$ 秒如果有红包，要么干扰转移到 $dp[i+1][j+1]$，要么不干扰转移到 $dp[d[choose[i]]][j]$；没有红包直接转移到 $dp[i+1][j]$。
- 最后看 $dp[n+1][j]$ 的最小值即可。


#### 1168C
- 容易发现，and 不为 0 即两个数某一位都是 1。
- 所以只需要取一个代表位，维护每个数之前第一个能到达的，第 $i$ 位为 $1$ 的数。
- 这个很好维护，枚举每一位，找到前一个有这一位的数，把能到达的第 $i$ 位为 1 的取个较大值。


#### 1234F
- 考虑这个翻转后的子串，假设现在取的是 $[l,r]$，那么如果你翻转的和 $[l,r]$ 不交或被 $[l,r]$ 包含是没有效果的，所以只会是左相交或右相交。
- 由于 $[l,r]$ 内顺序没有关系。左相交出现的字符是要翻转区间的一个前缀+当前区间的一个后缀，右相交出现的字符是当前区间的一个前缀+要翻转区间的一个后缀。
- 现在就变成取两个不相交的区间，要求不出现相同字符（内部和两个之间），显然这个不相交的条件没用，满足字符不同一定不相交。
- 把所有不出现相同字符的区间拿二进制数记录，现在就是找两个 and 为 $0$ 的数的非 $0$ 位数之和。
- 这个 and 为 $0$ 就很经典了，高维前缀和做一下，然后枚举 $x$，看 $all^x$ 的子集的最多 $1$ 的位数即可。


#### 799D
- 由于每个数每次最多*2，所以最多只需要34次就可以了。
- 乘的数显然越大越好，把 $a$ 的数从大到小排序。
- 记录用了 $i$ 次操作，一边边长为 $x$ 时，另一边边长最多为多少。枚举下一个给谁，转移即可。


#### 988F
- 显然每个点只有最轻的那把伞才有用。
- 设 $dp[i][j]$ 表示在 $i$ 拿第 $j$ 把伞的最小代价（$j=0$ 表示不拿）。考虑从 $i-1$ 走到 $i$。
- 可以直接撑着伞走到 $i$；如果 $i$ 不下雨，可以扔伞再走到 $i$；如果 $i-1$ 有其它伞，可以换伞然后走到 $i$。


#### 1140E
- 这个条件等价于不存在长度为 $3$ 的连续回文子串，即不存在 $a_{i-1}=a_{i+1}$。
- 那么不同奇偶性的就独立了，分开后就变成相邻数字不能相同。那么把连续的极长 $-1$ 段拿出来，那么这一段的方案数只和两边的数字是否相同和 $-1$ 段的长度有关。
- 先用 $(k-1)^l$ 计算出每个数和前一个数不相同的方案，再扣除最后一个 $-1$ 和下一个相同的方案（从 $l-1$ 转移）。


#### 1225E
- 考虑每次转向的时候，比如现在是往右，要变成往下，假设往下的箱子有 $x$ 个，能走到最多 $n-x$ 行。现在是往下的同理。
- 所以就变成给一行的连续的位置或一列连续的位置加，可以差分来做。


#### 981E
- 由于初始都是 $0$，所以任意 $i$ 能达到的值的并集就是所有可能的 $k$（因为可以只选达到这个最大值时选的包含 $i$ 的区间）。
- 加入一个数容易操作，但是删除一个数比较困难。考虑线段树分治，给区间里的位置都加入一个 $k$。
- 那么，对每个点维护一个bitset，初始从父亲继承，每次加入当前节点新加入的那些数。复杂度 $O(nq\log n/w)$。


#### 922E
- 容易想到记录到第 $i$ 棵树，买了 $j$ 只鸟，还有 $c$ 块钱是否可行。
- 可以发现把 $c$ 放到结果里也可行，即记录到第 $i$ 棵树，买了 $j$ 只鸟最多能剩下多少钱（上限你是知道的，$j\times B$）。
- 转移就枚举这棵树买了多少鸟，这样复杂度是 $O((\sum c_i)^2)$ 的。


#### 464C
- 把操作倒着过来做，处理出每个操作变成的 $\bmod 10^9+7$ 值和变成的位数。
- 然后把每个数字替换后的拼接起来，求出现在的 $\bmod 10^9+7$ 值和位数，相当于知道现在某个字符会变成什么。
- 最后再做 $s$，也替换后拼接起来，输出值即可。


#### 1249F
- 一个子树内选的点如果两两满足条件，那么对子树外有影响的只有选择的最浅的点的深度。
- 不过这样转移还要枚举两个子树的深度，不方便。不妨做个后缀最大值。
- 考虑枚举深度最浅的儿子和它的深度，其它的和它的深度之和不能小于 $k$，并且深度不能比它小。维护每个子树某个深度的 $dp$ 值和即可。


#### 570E
- 记录当前走到第 $i$ 步，正着在第 $a$ 行，倒着在第 $b$ 行的方案数。
- 转移就枚举正着的方向，倒着的方向，转移即可。


#### 489F
- 记录还需要多少列 $2$ 和多少列 $1$。
- 然后记录到哪一行，还有多少列 $1$，那么可以计算出有多少列 $2$，选一下放的列，转移即可。


#### 1227F1
- 设 $dp(i,j)$ 表示前 $i$ 题多得 $j$ 分的方案数，暴力转移即可。


#### 1579G
- 设 $dp[i][j]$ 表示当前在 $i$，离左端点距离为 $l$ 时，离右端点距离最小为多少。
- 一种是往左，减少 $j$（注意和 $0$ 取最大值），离右端点的距离增加。
- 一种是往右，增加 $j$，离右端点的距离减少（注意和 $0$ 取最大值）。


#### 1245F
- 容易发现条件等价于两个数 $and$ 起来为 $0$。
- 要求不能有某一位两个数都是 $1$，把 $l,r$ 用类似二维前缀和的方法拆开，两个数就只有上界了，数位 dp 即可。


#### 932D
- 这种加儿子的应该立刻想到倍增。
- 倍增合并两段的点权之和。由于新的点只会是叶节点，就可以在加点时倍增处理出该点向上 $2^i$ 的点和此时的点权之和。


#### 1066F
- 级别为 $i$ 的形成一个左右翻转的 $L$ 形。
- 没走完第 $i$ 层的关键点一定不会到 $i+1$ 层，同理你到 $i-1$ 层也不优。
- 你结束的时候一定在两端点，所以就记录 $dp[i][0/1]$ 分别表示在 $L$ 形最上端和最左端的答案。转移就从上一层的点过来绕这一层的关键点一圈。


#### 507D
- 倒着过来数位 dp，记录当前 $\bmod k$ 的值即可。


#### 1176F
- 每轮只有 $5$ 张牌是有可能使用的（最大的一张 $3$，最大的一张 $2$，前三大的 $1$）。
- 记录一下上一次暴击已经过去了多久，枚举这一次是怎么用的（3 or 1+2(2) or 1+1+1(1+1,1)），如果达到了暴击就把那一张双倍。 


#### 1105E
- 相邻两次修改 handle 之间，最多只有一个朋友会满足。
- **一些数只能选一个，即任意两个数不能同时选**。把这些朋友两两连边，求最大独立集。
- 可以折半，求出前 $m/2$ 个点，不和这边有冲突的情况下，另一边哪些点可以选；后 $m/2$ 个点搜出哪些是可以的，做高维前缀和即可。
- 不过也可以用牛逼 Bron–Kerbosch 算法。


#### 587B
- 设 $dp_{i,j}$ 表示考虑到第 $i$ 个块，选了第 $j$ 个数的方案数。
- 每个块只选一个数，所以可以把 $a$ 排序。
- 除了最后一个块，其它块每个都可以从之前的所有位置转移。最后一个块特殊考虑一下即可。


#### 1304F1
- 设 $dp(i,j)$ 表示第 $i$ 行从 $j$ 开始拍的动物数量的最大值。
- 转移和交的大小有关，分在左边分离，左相交，右相交，右边分离四种情况。
- 1,4 两种可以求前后缀最大值，2,3 可以滑动窗口转移。


#### 1621E
- 如果没有学生退学，你一定是把老师和学生平均值从大到小排序，一一对应。
- 如果现在平均值变大，那么要往左移，中间那些必须往右移，判断一下中间那些和当前的行不行，剩下的位置不变，也得判断行不行。
- 如果现在平均值变小，那么要往右移，中间那些必须往左移，判断一下中间那些和当前的行不行，剩下的位置不变，也得判断行不行。


#### 960E
- 考虑求出以边的一端为父亲，另一端子树有多少深度为奇数/偶数的点。这个用换根dp容易求。
- 那么另一个端点可以在其它点里随便选。


#### 743E
- 二分 $k$ 表示每个数出现了 $k$ 或 $k+1$ 次。
- 然后就可以 $dp$，记录二进制状态表示之前出现了哪些数，枚举当前数字，转移到当前数字出现 $k$ 次或出现 $k+1$ 次后的位置。


#### 313D
- $dp(i,j)$ 记录当前到 $i$，选了 $j$ 个的最小花费。
- 转移就枚举覆盖 $i..k-1$ 的区间（对于每个 $i$ 预处理代价最小的），转移到 $dp(k,j+(k-i))$。当然还可以不覆盖直接到 $dp(i+1,j)$。


#### 1551F
- 距离相同说明不存在三个点在一条链上。设两两距离为 $d$。
- 那么这三个点一定存在唯一中心点，使得三个点在它的不同子树，且深度都为 $d/2$。
- 其它点深度也得为 $d/2$，可以发现，如果有两个点在同一个子树，那么距离就不对了。
- 数据范围很小，枚举中心点，每个子树选至多一个深度为 $d/2$ 的即可。这个可以用dp解决。


#### 1197E
- dp记录最小值及方案数。
- 直接转移是平方的，但可以发现，一定是取 $out_j\leq in_i$ 的最小的若干个转移，求它们的方案数和。
- 你按照 $out$ 来排序，二分出这样的一个前缀，维护前缀最小值和最小值方案数即可。


#### 500E
- 设 $nxt_i$ 表示推到 $i$ 后最近一个推不倒的是哪个位置，$val_i$ 表示要推倒 $nxt_i$ 需要多少代价。
- 那么询问相当于从 $l$ 开始，一直加上经过的 $nxt$，直到 $nxt>r$。
- 直接倍增即可。


#### 757D
- $1..21$ 的二进制位数和 $>75$，所以最大的数字不能超过 $20$。
- 枚举当前到哪了，当前的数有几位，当前的二进制状态是什么，状态里加入当前数字转移即可。


#### 490F
- 平方其实很容易，直接换根即可。
- 这个状态是权值的话比较大，不妨反过来，记录选择 $x$ 点时两种序列结尾的最小/最大值。直接暴力转移另一边双指针还是平方的。
- 继续优化，长链剖分，不用双指针，用二分来求另一边的最大值，这样就做到了 $O(n \log n)$。


#### 1065D
- 容易想到直接建图。
- 需要注意，当前种类，匹配到第几个也是要记的。
- 建图就是一种是花 $(0,1)$ 的代价变棋子种类，一种是直接走，一种是换棋子，一种是匹配到下一种。


#### 283C
- 题目给的只能是若干个环或链，显然有环的话一定无解。
- 那么，你求出每条链可能的最小值，比它大的一定都能取到，且你可以给一个后缀+1，即总和加 $1,2,\cdots,len$ 都可以。
- 做个完全背包即可。


#### 514E
- 设 $dp_i$ 表示距离根恰好为 $i$ 的点数，那么 $dp_i=\sum_j dp_{i-j}\times cnt_j$。
- $d$ 只有 $100$，预处理 $100$ 以内的然后矩阵快速幂。


#### 1044C
- 可以发现求的是包含选出的 $k$ 边形的最小矩形的周长。
- 当 $k\leq 4$ 时，直接取最上/下/左/右的点即可。
- 当 $k=3$ 时，如果一个点提供两个方向的界，另外两个点分别提供一个方向的界，不妨把那两个提供一个方向的界的变成方向上的边界；如果两个点提供两个方向的界，那么另外的那个点可以变成某个方向的边界，此时就会有一个点只提供一个方向的界，把那个点再移到边界。现在就知道了一定有两个点在界上，且可以选界上任何一个点（因为只提供一个方向的界），所以你可以 $4\times 4\times n$ 枚举三个点。


#### 590D
- 如果知道了哪些要移到前 $k$ 个，那么最后它们的相对顺序不会改变。$p_i$ 移到第 $i$ 个位置的代价为 $p_i-i$。
- 设 $dp[i][j][s]$ 表示前 $i$ 个位置，选了 $j$ 个数，代价和为 $s$ 此时和最小为多少。
- 转移就分数字是否移动，不移动从 $dp[i-1][j][s]$ 转移，移动从 $dp[i-1][j-1][s-(i-j)]+a[i]$ 转移。


#### 111C
- $n\times m\leq 40$ 说明 $\min(n,m)\leq 6$。
- 不妨假设 $m\leq n$，状压 dp，记录当前行剩下的蜘蛛状态，下一行剩下的蜘蛛状态。
- 转移时枚举这一行放了哪些关键点，注意此时必须把上一行填满，再求出这一行剩下的蜘蛛和下一行剩下的蜘蛛。
- 复杂度是 $O(\max(n,m)\times 8^{\min(n,m)})$。


#### 56D
- **字符串汉明距离模板**。
- 设 $f[i][j]$ 表示 $s[1..i]$ 和 $t[1..j]$ 匹配的最小花费。
- f[i][j]=min(f[i-1][j]+1,f[i][j-1]+1,f[i-1][j-1]+(a[i]!=b[j]))


#### 855E
- 明显先变成 $f(r)-f(l-1)$ 然后状压记录之前位哪些数字出现了奇数次。
- 直接记忆化搜索+数位dp即可。


#### 1245E
- 不能一步到达的格子，每一面都有 $1/6$ 的概率，而抛到一个面就有走梯子和不走梯子两种，选期望小的，累加即可。
- 能一步到达的，可以手动计算，发现答案都是 $6$（以 $99$ 为例，$5/6$ 的概率不动，$1/6$ 的概率走到 $100$）。



#### 403D
- 给所有区间的长度增加 $1$，然后可以添加一个长度为 $1$ 的区间。
- 设 $dp_{i,j}$ 表示长度总和为 $i$，$j$ 个区间的方案数，转移就转移到 $dp_{i+j,j}$ 或 $dp_{i+j,j+1}$。
- 询问时枚举区间总长，取出 $k$ 个区间，剩下的组合数选一下即可。


#### 1089A
- 分情况，一种是两者进入加赛，一个 $+val$ 一个 $+val-2$，必须赢的得分 $>winscore$；另一种就是在 $winscore$ 直接赢了，另一个得分 $<winscore-1$。
- 直接 $dp$ 记录两个队各自得分总和（a,b），两者比分（x:y）。
- 暴力dp即可。


#### 489E
- 先二分，01分数规划。给每个边权减去二分的值。
- 然后你看最短路是否>0，如果满足就要增大，否则减小。
- 最后跑一次，记录每个点从哪里过来，输出。


#### 425C
- 最多拿到 $300000/1000=300$ 元钱。
- 设 $dp[i][j]$ 表示有 $i$ 元钱时，$b$ 串删除到了 $j$ 处时，$a$ 串删到的最小位置。
- 转移就是找 $b[j]$ 与 $dp[i-1][j-1]$ 后的第一个相同的数字匹配。


#### 1151F
- 设 $0$ 有 $x$ 个，最终状态要求前 $x$ 个都是 $0$。
- dp 可以记录前 $x$ 中现在有多少个 $0$（因为两部分内部的顺序是没有关系的）。
- 每次就是，要么交换两个内部的，不影响；要么交换两个之间的，交换左边 $0$ 右边 $1$ 那么 $x-1$，交换左边 $1$ 右边 $0$ 那么 $x+1$，其它不变。
- 发现转移和 $k$ 无关，直接矩乘即可。


#### 1172C1
- 枚举当前的权值。
- dp 记录到哪一步，被喜欢的数字 $w$ 之和，不被喜欢的数字 $w$ 之和时喜欢/不喜欢的期望权值。


#### 935E
- 建立表达式树，在树上 dp。
- 以 $p<m$ 为例，记录 $dp_{u,x}$ 表示 $u$ 子树选了 $x$ 个加号的最大最小贡献，转移是 $O(p^2)$ 的。
- $m\leq p$ 同理。


#### 629E
- 分类讨论。
- 如果两点不是祖孙关系，那么就是两个点子树连边。首先先加入所有方案的这条新加的边和路径上所有的边，剩下的就是那些点到 $u/v$ 的距离之和，dp 预处理出每个点子树到它的深度之和即可。
- 如果是祖孙关系，假设 $u$ 是 $v$ 祖先。还是差不多，还是新加的边和路径上的所有便都有，其它的边如果是 $v$ 的子树连出去的，直接计算方案数即可；如果是 $u$ 除了 $v$ 方向的子树，换根 dp，钦定 $u$ 为根（这样父亲方向就不影响了），再去掉 $v$ 向子树的影响计算一下就可以了。


#### 954F
- 没有障碍显然直接设第 $i$ 行第 $j$ 列，然后直接矩乘。
- 现在这样就直接分段，障碍物之间的矩乘加速即可。


#### 859D
- 显然是个二叉树的形式，设 $w(u,x)$ 表示 $u$ 的子树 $x$ 赢了的概率，$v(u,x,y)$ 表示 $u$ 这个点上如果 $x,y$ 比赛，下注 $x$ 的期望，设 $f(u,x)$ 表示 $u$ 这个点上下注 $x$ 总得分的期望。
- 枚举 $x$。算 $v$，从下一层的 $w$ 转移过来。算 $f$，上一轮压也压它，加上上一轮压另外一个 $y$ 的最大概率，再这一轮赢的概率 $f$。


#### 142C
- 这个只和前两行有关，记录一下，枚举这一行，再枚举放的方向。
- 范围很小，直接暴力，然后打出答案的表即可。


#### 294E
- 拆成两棵树后两树内部两两距离和不变，加上中间一条边的贡献。
- 假设连了两边 $u,v$，再加上两边点到 $u/v$ 的距离和。所以两边选的一定是重心，由于权值很小直接暴力计算贡献即可。


#### 509F
- 区间dp，记录一种树的方案数，一种分成若干个根从小到大的森林的方案数。
- 转移就枚举从哪里分开（树枚举第一个儿子，森林枚举第一棵树），然后从更小的转移。复杂度 $O(n^3)$。


#### 852E
- 就看选的根是不是叶子节点。
- 不是的话其它点随便选，叶子节点有唯一方案。
- 是的话也没啥区别，就是叶子节点少了一个。
- 计算一下叶子节点个数，快速幂即可。


#### 28C
- 这个最大的期望不好算，还是固定最大值比较好。
- 枚举所有数字都不超过这个最大值 $x$。
- 设 $dp[i][j]$ 表示前 $i$ 间洗漱室，有 $j$ 个学生，每个洗漱室最长队伍长度都不超过 $x$ 的概率。
- 转移就枚举这间洗漱室有多少人，组合数取一下是哪些人，就可以了。


#### 1575L
- **可以发现只和相邻的有贡献的有关。**
- 要移到的位置比原来数要小才可能有贡献，即 $a_i\leq i$。
- 考虑怎样相邻的 $i<j$ 能被同时保留且有贡献，那么首先得满足 $a_i<a_j$（有贡献的要递增），其次它们要到自己要到的位置删的数字个数也得满足条件，即 $i-a_i\leq j-a_j$（之前删的个数要满足）。
- 然后看看是否还要满足其它条件，发现不需要了，比如你要求 $i_1<i_2<\cdots<i_k$ 都有贡献，那么在相邻两个 $i,j$，删掉 $(j-a_j)-(i-a_i)$ 个，且由于 $a_i<a_j$ 所以删的数字个数一定不到 $j-i$。
- 发现 $a_i<a_j$ 和 $i-a_i\leq j-a_j$ 完全替代了 $i<j$，所以现在只有两个条件了（不满足 $a_i\leq i$ 可以直接扔掉），相当于求满足这个条件能选出的最多数字个数，是一个二元组的 LIS，计算即可。


#### 385D
- 状压dp，记录之前哪些选了，排成了连续的一段的最长长度。
- 转移就是找另外的灯从它之后开始覆盖，看最多能覆盖到哪，取最大转移。


#### 300D
- 当 $n$ 是奇数的时候，可以分成四个边长为 $(n-1)/2$ 的矩形。
- 算一下能分几层。设 $dp(i,j)$ 表示还能分 $i$ 层，分 $j$ 次的方案。
- 转移理论上是 $dp(i+1)$ 的四次，可以通过两次平方算出。注意还得加上不选的方案数（直接四次认为根节点选）。
- 平方可以暴力，复杂度是 $O(k^2\log n+q\log n)$。


#### 1252J
- 设 $dp(i,j)$ 表示前 $i$ 个位置覆盖了 $j$ 种 3，最多能覆盖多少种 2（之后可以替换成 1）。
- 那么剩下的都填 1，然后如果两个 1 比 2 优可以再尽量替换，然后如果一个 1 就比 2 优也可以再替换一个，剩下的直接空着。


#### 279D
- 设 $dp(i,s)$ 表示当前到第 $i$ 次操作，$a$ 中 $s$ 状态的数此时必须在序列中出现的答案。
- 枚举由哪两个加起来，把当前的扣掉，加入那两个数和 $i-1$ 转移过来。


#### 677E
- 以一般形为例，一定是找上下左右第一个 $0$，求出使得答案非 $0$ 的最大的 $d$。
- 这个权值可能过大，用经典取log来判断大小。
- 旋转形可以转坐标。


#### 49E
- 根据经典套路，最后缩成了一个不能再缩的字符串，那么其中的每个字符都对应原串的某个区间缩过来。
- 设 $p[i][j][c]$ 表示 $s[i..j]$ 能不能缩成字符 $c$，$q[i][j][c]$ 同理。这个可以通过枚举分界点和变化方式，$O(|\Sigma|n^4)$ 转移。
- 然后就是设 $f[i][j]$ 表示 $s[1..i]$ 和 $t[1..j]$ 匹配时最小的长度，转移还是枚举下一个字符和两个下一段的右端点，$O(|\Sigma|n^4)$ 转移。


#### 50D
- $r$ 的增大概率是单调不减的，可以二分答案。
- $r$ 固定后，摧毁每一个建筑物的概率也固定了。设 $dp[i][j]$ 为第 $i$ 次选时选了 $j$ 个的概率，直接根据概率，一种到 $j+1$，一种到 $j$。
- 最后和大小关系比较一下即可。


#### 111D
- 从左往右移动线，那么左端是个不降的函数，右端是个不升的函数。
- 要求这两个函数相等，说明这两个函数每个位置的值都相等。
- 也就是第一列和最后一列不同数字个数相同，此外每一列的数都得是第一列和最后一列数的子集。
- 所以中间方案数只和两边集合交集大小有关。枚举两边集合大小，再枚举两边相同的数字个数，组合数计算一下，需要提前预处理 $i$ 种数填 $n$ 个位置的方案数，这个容易 $dp$，枚举数字种类数，再扣除种类数不到的方案。


#### 903F
- $dp(i,sta)$，$sta$ 表示第 $i,i+1,i+2$ 列的状态，存最小代价。
- 看在哪一行放个 $x\times x$ 的正方形，转移到对应状态。注意放 
$4\times 4$ 的可以直接转移到 $i+1$ 列全 $0$。


#### 802K
- 和之前类似，你进入一个子树，一定是能访问多少就访问多少，不可能出去一次再进来，这样只会多浪费父亲和自己的经过次数。
- 记录一个要返回的，记录一个不要返回的。要返回的可以走 $k-1$ 个儿子都要返回，不要返回的可以多走一个不要返回的儿子。
- 不要返回的，选要返回的值尽量大的 $k-1$ 个儿子。
- 要返回的，在此基础上，返回的变成不返回的贡献是：它不返回-它返回+第 $k$ 大的返回。本身不返回的贡献是：不返回的贡献。取最大的加上即可。
- 注意特判儿子数量不足 $k$ 个。


#### 76F
- **可以发现只和相邻的事件的有关。**
- 那么相邻的事件 $(x,p),(y,q),p\leq q$，满足条件当且仅当 $|x-y|\leq (q-p)V$。
- 把绝对值拆了，变成 $x-y\leq (q-p)V,y-x\leq (q-p)V$，移项得 $x+pV\leq y+qV, -(x-pV)\leq -(y-qV)$。
- 两个式子加起来就得到了 $pV\leq qV$，所以不需要考虑 $p\leq q$ 的条件，直接 LIS 即可。


#### 71E
- 预处理每个子集和。
- 每次枚举子集，把子集给当前数。
- 因为总和固定，这个是 $O(3^n)$ 的（非 $O(n3^n)$）。


#### 39C
- 圆在同一直线上，所以可以把它看作若干区间。
- 设 $f(l,r)$ 表示 $l..r$ 区间能选多少。
- 转移一种是选左端点的区间，一种不选，直接跳过当前左端点。
- 注意选了左端点区间后只能在右端点后或左端点的区间内。


#### 254E
- $dp[i][j]$ 表示前 $i$ 天，昨天剩下 $j$ 个食物能得到的最大 rating。
- 保证自己的，然后尽量满足需求小的朋友。


#### 268D
- 记录 $dp[h][a][b][c][d]$ 为当前高度 $h$，四个杆子在它上面离它最近的距离分别为 $a,b,c,d$。
- 当 $\geq h$ 的时候赋成 $-1$。
- 直接做状态太多，但是你发现一定有一维只有 $0/-1$，就可以直接暴力了。


#### 309B
- 求出每个单词为开头，第一个不能放在同一行的单词的位置。这个可以用双指针。
- 那么可以跳 $r$ 次得到结果，因为形成了一棵树的形式，所以可以维护到根路径上点的栈，直接求出 $r$ 级祖先。


#### 316D1
- 你考虑变成的若干个排列环，你要在上面交换。
- 当环长 $>2$时，交换相邻的只能是 $1\rightarrow 2$ 换或者 $2\rightarrow 2$ 换，不相邻的只能是 $2,2$ 换。而当环长 $=2$ 时都合法。
- 由于环长 $=2$ 时才能两个都是 $1$，不妨猜测无论什么时刻都只能有最多两个 $1$。
- 你发现无论怎样换都满足这个条件，但是还得证明满足这个条件就行，这个容易，每次交换相邻 $1\rightarrow 2$ 即可。
- 那么可以对 $1$ dp，$2$ 随便插入即可。$1$ 的话就是考虑最后一个，要么单独成环，要么和前面某个成环，转移。
- 每个 $2$ 可以插在之前任意数后面。


#### 440D
- 容易想到树形 dp，每个子树选一些连上来，再记录是否出现过大小为 $k$ 的，这样比较麻烦。再想一想。
- 由于没有出现过大小为 $k$ 的条件的话直接所有放一个连通块即可，但是它有这个要求所以你选出某个大小为 $k$ 的之后，剩下的连通的一定放一个连通块（否则只会增加连通块间的边）。
- 现在就把划分连通块变成求一个大小为 $k$ 的连通块向外的边的数量的最小值，这个也可以树形 dp，而某个儿子不连边要把权值 +1，非根节点为根的连通块还要加上和父亲的边。


#### 873E
- 数据范围不大，考虑暴力再优化。
- 先把 $a$ 从大到小排序，那么就是把 $a$ 分成若干段区间，分别填 $1,2,3,-1$。枚举分界点，这样是 $O(n^3)$ 的。
- 通过 $cnt_x\leq cnt_y\times 2$ 的条件，可以算出 $3,-1$ 分界点可行的范围，在里面找 $d_3-c_{-1}$ 的最小值。你可以先枚举 $2,3$ 的分界点，预处理前缀的最小值，以快速计算。
- 时间复杂度 $O(n^2)$。


#### 316D2（*，同D1）
- 你考虑变成的若干个排列环，你要在上面交换。
- 当环长 $>2$时，交换相邻的只能是 $1\rightarrow 2$ 换或者 $2\rightarrow 2$ 换，不相邻的只能是 $2,2$ 换。而当环长 $=2$ 时都合法。
- 由于环长 $=2$ 时才能两个都是 $1$，不妨猜测无论什么时刻都只能有最多两个 $1$。
- 你发现无论怎样换都满足这个条件，但是还得证明满足这个条件就行，这个容易，每次交换相邻 $1\rightarrow 2$ 即可。
- 那么可以对 $1$ dp，$2$ 随便插入即可。$1$ 的话就是考虑最后一个，要么单独成环，要么和前面某个成环，转移。
- 每个 $2$ 可以插在之前任意数后面。


#### 518F
- 如果不折，那么是横着一条（起终点在左右边界，且不能在角落）或竖着一条（起终点在上下边界，且不能在角落）。
- 如果折一次，枚举转折点（不在边界上），再枚举起点终点在哪两个方向。
- 如果折两次，以起终点都在左右边界为例，枚举第二个折点：一段是先往上再往左/右，计算方案；另一段是直接往左/右。
- 写起来可能比较复杂。


#### 838E
- 设现在 $l,l+1,\cdots,r$ 的点已经通过一条路径连通了，且一端为 $l$ 另一端为 $r$ 的最长的路径长度。
- 那么就考虑 $l$ 的连边，如果 $l$ 连的不是 $l$ 或 $r$ 的下一个点，那么就会分出两部分，之间只能经过一边，显然不合法；如果 $l$ 不连，$r$ 也同理不能连不是 $l$ 或 $r$ 的下一个点，当不是所有点都经过时，$l,r$ 必须至少有一个点连边。
- 所以直接 dp，枚举当前 $l$ 往外连还是 $r$ 往外连，转移即可。在最外面枚举 $l..r$ 间的点数。


#### 45B
- 每个点向下一个点连边，形成若干个基环树。
- 每个点开始的时候指向自己，如果一个指向自己的点能在步数内走到，就把它指向它父亲，继续。
- 这样暴力复杂度太高，考虑用并查集维护，同时要维护到并查集根的步数。
- 不过要注意如果把整个环都走到了，需要标记一下，以后就不考虑环上的点和到环上了。


#### 1488E
- 对于偶回文串，你选的那些数字的 $(l,r)$ 必须是一个包含另一个的关系，即 $l_1<l_2<l_3<\cdots<l_k,r_k<\cdots<r_3<r_2<r_1$。
- 不妨再加入所有 $(x,x)$，就只需要满足上面的条件即可，按照 $(l,r)$ 二元组从小到大排序，然后LIS即可。


#### 774I
- 每次找到一个字符串，使得和 $s$ 当前没匹配的位置开始匹配的位数尽量多。
- 更新匹配到的位置，答案+1，直到 $s$ 匹配完。

