<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <atom:link href="https://newzone.top/rss.xml" rel="self" type="application/rss+xml"/>
    <title>LearnData-开源笔记</title>
    <link>https://newzone.top/</link>
    <description>开源工具、效率方法、心理学探索的自我提升笔记，记录并输出一切能让自己提升的知识。</description>
    <language>zh-CN</language>
    <pubDate>Sat, 27 Aug 2022 07:19:29 GMT</pubDate>
    <lastBuildDate>Sat, 27 Aug 2022 07:19:29 GMT</lastBuildDate>
    <generator>vuepress-plugin-feed2</generator>
    <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
    <category>CodeForces</category>
    <category>IOI2022</category>
    <category>NOIP2021</category>
    <category>UOJ</category>
    <item>
      <title>CF1188D</title>
      <link>https://newzone.top/_posts/CF1188D.html</link>
      <guid>https://newzone.top/_posts/CF1188D.html</guid>
      <source url="https://newzone.top/rss.xml">CF1188D</source>
      <description>
给定 $n$ 个数字 $a_1,a_2,\cdots,a_n$，每次操作可以给某个 $a_i$ 加上 $2$ 的非负整数次幂。
求最少的操作次数使得 $n$ 个数相等。
$1\leq n\leq 10^5,0\leq a_i\leq 10^{17}$

</description>
      <category>CodeForces</category>
      <pubDate>Wed, 14 Oct 2020 14:45:14 GMT</pubDate>
      <content:encoded><![CDATA[<ul>
<li>给定 $n$ 个数字 $a_1,a_2,\cdots,a_n$，每次操作可以给某个 $a_i$ 加上 $2$ 的非负整数次幂。</li>
<li>求最少的操作次数使得 $n$ 个数相等。</li>
<li>$1\leq n\leq 10^5,0\leq a_i\leq 10^{17}$</li>
</ul>

<h3 id="sol" tabindex="-1"> sol</h3>
<ul>
<li>
<p>不妨先将 $a$ 从小到大排序。</p>
</li>
<li>
<p>设最后每个数都等于 $a_n+x(x\geq 0)$。那么总代价为 $\sum\limits_{i=1}^n popcount(a_n+x-a_i)$。</p>
</li>
<li>
<p>现在要找一个 $x$ 使得答案最小。不妨先将 $a_i$ 变为原先的 $a_n-a_i$。</p>
</li>
<li>
<p>那么现在总代价为 $\sum\limits_{i=1}^n popcount(x+a_i)$。</p>
</li>
<li>
<p>从低到高考虑每一位，那么 $x+a_i$ 的第 $k$ 位是 $0/1$ 由以下三个条件决定：</p>
<ol>
<li>$x$ 的第 $k$ 位是 $0$ 还是 $1$</li>
<li>$a_i$ 的第 $k$ 位是 $0$ 还是 $1$</li>
<li>$x+a_i$ 的第 $k-1$ 位有没有向前进位</li>
</ol>
</li>
<li>
<p>暴力的做法是从低到高枚举每一位，用 $2^n$ 的状态记录每个数有没有进位，显然复杂度接受不了。</p>
</li>
<li>
<p>但是可以发现，由于每个 $a_i$ 加的都是 $x$，所以 $a_i$ 的后 $k-1$ 位越大，越可能向第 $k$ 位进位。</p>
</li>
<li>
<p>所以，“每个数有没有进位”的状态数只有 $O(n)$ 个，每个进位状态为后 $k-1$ 位从小到大排序后的一个后缀。</p>
</li>
<li>
<p>记 $f[k][i]$ 表示考虑了后 $k$ 位，后 $k$ 位最大的 $i$ 个数进位的最小代价。</p>
</li>
<li>
<p>如何转移？考虑当前这一位 $x$ 是 $0$ 还是 $1$。</p>
</li>
<li>
<p>0：</p>
<ul>
<li>对答案的贡献：“前一位没进位且第 $k$ 位为 $1$ 的数“的个数 + ”前一位进位且第 $k$ 位为 $0$ 的数“的个数（$x+a_i$ 在这一位为 $1$）；</li>
<li>进位的数量：&quot;前一位进位且第 $k$ 位为 $1$ 的数&quot;的个数。</li>
</ul>
</li>
<li>
<p>1：</p>
<ul>
<li>对答案的贡献：“前一位进位且第 $k$ 位为 $1$ 的数“的个数 + ”前一位没进位且第 $k$ 位为 $0$ 的数“的个数（$x+a_i$ 在这一位为 $1$）；</li>
<li>进位的数量：$n-$&quot;前一位没进位且第 $k$ 位为 $0$ 的数&quot;的个数。</li>
</ul>
</li>
<li>
<p>至于如何求这些“个数”，就记个前缀和，存下后 $k$ 位从小到大前 $i$ 个中没进位数的个数和进位的数的个数即可。</p>
</li>
<li>
<p>可以用类似于基数排序的方法优化每次的排序，时间复杂度 $O(n \log V)$，其中 $V=\max{a_i}$。</p>
</li>
</ul>
<div><pre><code><span><span>#</span><span>include</span><span>&lt;cstdio></span></span>
<span><span>#</span><span>include</span><span>&lt;algorithm></span></span>
<span>using</span> <span>namespace</span> std<span>;</span>
<span>typedef</span> <span>long</span> <span>long</span> ll<span>;</span>
<span>const</span> ll INF<span>=</span><span>1ll</span><span>&lt;&lt;</span><span>60</span><span>;</span>
<span>int</span> n<span>,</span>p<span>[</span><span>510000</span><span>]</span><span>,</span>sum<span>[</span><span>2</span><span>]</span><span>[</span><span>510000</span><span>]</span><span>;</span>
<span>int</span> tmp1<span>[</span><span>510000</span><span>]</span><span>,</span>tmp2<span>[</span><span>510000</span><span>]</span><span>;</span>
ll dp<span>[</span><span>60</span><span>]</span><span>[</span><span>510000</span><span>]</span><span>,</span>c1<span>,</span>c2<span>,</span>c3<span>,</span>p1<span>,</span>p2<span>,</span>m<span>;</span>
ll sta<span>,</span>a<span>[</span><span>510000</span><span>]</span><span>;</span>
<span>/*bool cmp(int x,int y){
	return (a[x]&amp;sta)&lt;(a[y]&amp;sta);
}*/</span>
<span>int</span> <span>main</span><span>(</span><span>)</span><span>{</span>
<span>//	freopen("equal.in","r",stdin);</span>
<span>//	freopen("equal.out","w",stdout);</span>
	<span>scanf</span><span>(</span><span>"%d"</span><span>,</span><span>&amp;</span>n<span>)</span><span>;</span>
	<span>for</span> <span>(</span><span>int</span> i<span>=</span><span>1</span><span>;</span>i<span>&lt;=</span>n<span>;</span>i<span>++</span><span>)</span> <span>scanf</span><span>(</span><span>"%lld"</span><span>,</span><span>&amp;</span>a<span>[</span>i<span>]</span><span>)</span><span>;</span>
	<span>sort</span><span>(</span>a<span>+</span><span>1</span><span>,</span>a<span>+</span>n<span>+</span><span>1</span><span>)</span><span>;</span>
	<span>for</span> <span>(</span><span>int</span> i<span>=</span><span>1</span><span>;</span>i<span>&lt;=</span>n<span>;</span>i<span>++</span><span>)</span> a<span>[</span>i<span>]</span><span>=</span>a<span>[</span>n<span>]</span><span>-</span>a<span>[</span>i<span>]</span><span>;</span>
	<span>for</span> <span>(</span><span>int</span> w<span>=</span><span>0</span><span>;</span>w<span>&lt;=</span><span>58</span><span>;</span>w<span>++</span><span>)</span>
		<span>for</span> <span>(</span><span>int</span> i<span>=</span><span>0</span><span>;</span>i<span>&lt;=</span>n<span>;</span>i<span>++</span><span>)</span>
			dp<span>[</span>w<span>]</span><span>[</span>i<span>]</span><span>=</span>INF<span>;</span>
	<span>for</span> <span>(</span><span>int</span> i<span>=</span><span>1</span><span>;</span>i<span>&lt;=</span>n<span>;</span>i<span>++</span><span>)</span> p<span>[</span>i<span>]</span><span>=</span>i<span>;</span>
	dp<span>[</span><span>0</span><span>]</span><span>[</span><span>0</span><span>]</span><span>=</span><span>0</span><span>;</span>
	<span>for</span> <span>(</span><span>int</span> w<span>=</span><span>0</span><span>;</span>w<span>&lt;</span><span>58</span><span>;</span>w<span>++</span><span>)</span><span>{</span>
		sta<span>=</span><span>(</span><span>1ll</span><span>&lt;&lt;</span>w<span>)</span><span>-</span><span>1</span><span>;</span>
<span>//		sort(p+1,p+n+1,cmp);</span>
		<span>for</span> <span>(</span><span>int</span> i<span>=</span><span>1</span><span>;</span>i<span>&lt;=</span>n<span>;</span>i<span>++</span><span>)</span><span>{</span>
			sum<span>[</span><span>0</span><span>]</span><span>[</span>i<span>]</span><span>=</span>sum<span>[</span><span>0</span><span>]</span><span>[</span>i<span>-</span><span>1</span><span>]</span><span>;</span>
			sum<span>[</span><span>1</span><span>]</span><span>[</span>i<span>]</span><span>=</span>sum<span>[</span><span>1</span><span>]</span><span>[</span>i<span>-</span><span>1</span><span>]</span><span>;</span>
			sum<span>[</span><span>(</span>a<span>[</span>p<span>[</span>i<span>]</span><span>]</span><span>>></span>w<span>)</span><span>&amp;</span><span>1</span><span>]</span><span>[</span>i<span>]</span><span>++</span><span>;</span>
		<span>}</span>
		<span>for</span> <span>(</span><span>int</span> i<span>=</span><span>0</span><span>;</span>i<span>&lt;=</span>n<span>;</span>i<span>++</span><span>)</span><span>{</span>
			<span>int</span> tmp<span>=</span><span>(</span>sum<span>[</span><span>0</span><span>]</span><span>[</span>n<span>]</span><span>-</span>sum<span>[</span><span>0</span><span>]</span><span>[</span>n<span>-</span>i<span>]</span><span>)</span><span>+</span>sum<span>[</span><span>1</span><span>]</span><span>[</span>n<span>-</span>i<span>]</span><span>;</span>
			<span>int</span> sta<span>=</span>sum<span>[</span><span>1</span><span>]</span><span>[</span>n<span>]</span><span>-</span>sum<span>[</span><span>1</span><span>]</span><span>[</span>n<span>-</span>i<span>]</span><span>;</span>
			dp<span>[</span>w<span>+</span><span>1</span><span>]</span><span>[</span>sta<span>]</span><span>=</span><span>min</span><span>(</span>dp<span>[</span>w<span>+</span><span>1</span><span>]</span><span>[</span>sta<span>]</span><span>,</span>dp<span>[</span>w<span>]</span><span>[</span>i<span>]</span><span>+</span>tmp<span>)</span><span>;</span>
		<span>}</span>
		<span>for</span> <span>(</span><span>int</span> i<span>=</span><span>0</span><span>;</span>i<span>&lt;=</span>n<span>;</span>i<span>++</span><span>)</span><span>{</span>
			<span>int</span> tmp<span>=</span><span>(</span>sum<span>[</span><span>1</span><span>]</span><span>[</span>n<span>]</span><span>-</span>sum<span>[</span><span>1</span><span>]</span><span>[</span>n<span>-</span>i<span>]</span><span>)</span><span>+</span>sum<span>[</span><span>0</span><span>]</span><span>[</span>n<span>-</span>i<span>]</span><span>;</span>
			<span>int</span> sta<span>=</span>n<span>-</span>sum<span>[</span><span>0</span><span>]</span><span>[</span>n<span>-</span>i<span>]</span><span>;</span>
			dp<span>[</span>w<span>+</span><span>1</span><span>]</span><span>[</span>sta<span>]</span><span>=</span><span>min</span><span>(</span>dp<span>[</span>w<span>+</span><span>1</span><span>]</span><span>[</span>sta<span>]</span><span>,</span>dp<span>[</span>w<span>]</span><span>[</span>i<span>]</span><span>+</span>tmp<span>)</span><span>;</span>
		<span>}</span>
		<span>int</span> cnt1<span>=</span><span>0</span><span>,</span>cnt2<span>=</span><span>0</span><span>;</span>
		<span>for</span> <span>(</span><span>int</span> i<span>=</span><span>1</span><span>;</span>i<span>&lt;=</span>n<span>;</span>i<span>++</span><span>)</span>
			<span>if</span> <span>(</span><span>(</span>a<span>[</span>p<span>[</span>i<span>]</span><span>]</span><span>>></span>w<span>)</span><span>&amp;</span><span>1</span><span>)</span> tmp1<span>[</span><span>++</span>cnt1<span>]</span><span>=</span>p<span>[</span>i<span>]</span><span>;</span>
			<span>else</span> tmp2<span>[</span><span>++</span>cnt2<span>]</span><span>=</span>p<span>[</span>i<span>]</span><span>;</span>
		<span>int</span> k<span>=</span><span>0</span><span>;</span>
		<span>for</span> <span>(</span><span>int</span> i<span>=</span><span>1</span><span>;</span>i<span>&lt;=</span>cnt2<span>;</span>i<span>++</span><span>)</span> p<span>[</span><span>++</span>k<span>]</span><span>=</span>tmp2<span>[</span>i<span>]</span><span>;</span>
		<span>for</span> <span>(</span><span>int</span> i<span>=</span><span>1</span><span>;</span>i<span>&lt;=</span>cnt1<span>;</span>i<span>++</span><span>)</span> p<span>[</span><span>++</span>k<span>]</span><span>=</span>tmp1<span>[</span>i<span>]</span><span>;</span>
	<span>}</span>
	<span>printf</span><span>(</span><span>"%lld\n"</span><span>,</span>dp<span>[</span><span>58</span><span>]</span><span>[</span><span>0</span><span>]</span><span>)</span><span>;</span>
	<span>return</span> <span>0</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>CF1204D</title>
      <link>https://newzone.top/_posts/CF1204D.html</link>
      <guid>https://newzone.top/_posts/CF1204D.html</guid>
      <source url="https://newzone.top/rss.xml">CF1204D</source>
      <description>
给定一个 01 串 $s$，要求你找到一个与 $s$ 长度相等的 01 串 $t$ 并满足以下条件：

对于任意的 $l,r(1\leq l\leq r\leq n)$，$s[l:r]$ 和 $t[l:r]$ 的最长不下降子序列长度相同；
$t$ 中 $0$ 的数量尽可能多。


有多解输出任意一种。$|S|\leq 10^5$。

</description>
      <category>CodeForces</category>
      <pubDate>Wed, 06 Oct 2021 10:21:35 GMT</pubDate>
      <content:encoded><![CDATA[<ul>
<li>给定一个 01 串 $s$，要求你找到一个与 $s$ 长度相等的 01 串 $t$ 并满足以下条件：
<ol>
<li>对于任意的 $l,r(1\leq l\leq r\leq n)$，$s[l:r]$ 和 $t[l:r]$ 的最长不下降子序列长度相同；</li>
<li>$t$ 中 $0$ 的数量尽可能多。</li>
</ol>
</li>
<li>有多解输出任意一种。$|S|\leq 10^5$。</li>
</ul>

<h3 id="sol" tabindex="-1"> sol</h3>
<ul>
<li>
<p>这个题非常有意思。容易想到按照一个顺序依次确定每个位置的值。</p>
</li>
<li>
<p>但是前面的位置确定了，当前位置的值不仅和之前的最长不下降子序列长度有关，还和 $1$ 的个数有关。</p>
</li>
<li>
<p>发现 <code>10</code> 是不能被其它等长的串所替换的，它的最长不下降子序列长度为 $1$，而其它等长的串都为 $2$。</p>
</li>
<li>
<p>有一个思路（猜测），就是把串中的 <code>10</code> 不断删除，直到不存在。但这样真的行吗？</p>
</li>
<li>
<p>删除某个 <code>10</code> 后对所有 $l,r$ 最长不下降子序列长度的影响：</p>
<ol>
<li>$l,r$ 完全包含被删除的 <code>10</code>，那么原先无论最长不下降子序列是怎么选的，都一定会选择 <code>10</code> 中的恰好一个数，现在它的长度必定减少 1；</li>
<li>$l,r$ 和 被删除的 <code>10</code> 无交，那么最长不下降子序列长度不影响；</li>
<li>$l,r$ 和 被删除的 <code>10</code> 有交但不包含，即 $l$ 或 $r$ 在 <code>10</code> 之间，如果是 $l$ 则原子序列一定会选择最左边的 $0$，如果是 $r$ 则原子序列一定会选择最右边的 $1$，删去后长度必定减少 1。</li>
</ol>
</li>
<li>
<p>删去后的问题，如果 $s'$ 和 $t'$ 满足条件，那么加回这个 <code>10</code> 后仍然满足条件。</p>
</li>
<li>
<p>所以可以一直删去 <code>10</code>，直到没有 <code>10</code>。考虑现在的串一定为 <code>00...011...1</code>，可以把所有数字都变成 $0$，所有 $l,r$ 最长不下降子序列长度不变。</p>
</li>
<li>
<p>具体实现可以从左到右扫描，维护一个栈记录之前还没被删去的 $1$ 的位置，如果当前为 $0$ 且栈不为空则可以和前面的一起删去，否则加入栈。最后栈中的 $1$ 即没有被删去的 $1$，都变为 $0$ 即可。</p>
</li>
</ul>
<div><pre><code><span><span>#</span><span>include</span><span>&lt;bits/stdc++.h></span></span>
<span>using</span> <span>namespace</span> std<span>;</span>
string s<span>;</span> <span>int</span> top<span>,</span>t<span>[</span><span>110000</span><span>]</span><span>;</span>
<span>int</span> <span>main</span><span>(</span><span>)</span><span>{</span>
	cin<span>>></span>s<span>;</span> <span>int</span> n<span>=</span>s<span>.</span><span>length</span><span>(</span><span>)</span><span>;</span>
	<span>for</span> <span>(</span><span>int</span> i<span>=</span><span>0</span><span>;</span>i<span>&lt;</span>n<span>;</span>i<span>++</span><span>)</span>
		<span>if</span> <span>(</span>s<span>[</span>i<span>]</span><span>==</span><span>'1'</span><span>)</span> t<span>[</span><span>++</span>top<span>]</span><span>=</span>i<span>;</span>
		<span>else</span> <span>if</span> <span>(</span>top<span>)</span> top<span>--</span><span>;</span>
	<span>while</span> <span>(</span>top<span>)</span> s<span>[</span>t<span>[</span>top<span>--</span><span>]</span><span>]</span><span>=</span><span>'0'</span><span>;</span>
	cout<span>&lt;&lt;</span>s<span>&lt;&lt;</span>endl<span>;</span>
	<span>return</span> <span>0</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>CF1365F</title>
      <link>https://newzone.top/_posts/CF1365F.html</link>
      <guid>https://newzone.top/_posts/CF1365F.html</guid>
      <source url="https://newzone.top/rss.xml">CF1365F</source>
      <description>
给定 $n$ 和数字串 $a_1,a_2,\cdots,a_n$，$b_1,b_2,\cdots,b_n$。
定义一次操作为：将一个等长且不相交的前缀和后缀对应位置交换。举例：${1,2,3,4,5,6}$ 交换长度为 $2$ 的前后缀变为 ${5,6,3,4,1,2}$。
可以对 $a$ 进行任意次操作，问是否能变成 $b$。多组数据。
$1\leq T\leq 500,1\leq n\leq 500,1\leq a_i,b_i\leq 10^9$。

</description>
      <category>CodeForces</category>
      <pubDate>Tue, 05 Oct 2021 22:53:35 GMT</pubDate>
      <content:encoded><![CDATA[<ul>
<li>给定 $n$ 和数字串 $a_1,a_2,\cdots,a_n$，$b_1,b_2,\cdots,b_n$。</li>
<li>定义一次操作为：将一个等长且不相交的前缀和后缀对应位置交换。举例：${1,2,3,4,5,6}$ 交换长度为 $2$ 的前后缀变为 ${5,6,3,4,1,2}$。</li>
<li>可以对 $a$ 进行任意次操作，问是否能变成 $b$。多组数据。</li>
<li>$1\leq T\leq 500,1\leq n\leq 500,1\leq a_i,b_i\leq 10^9$。</li>
</ul>

<h3 id="sol" tabindex="-1"> sol</h3>
<ul>
<li>一个显然的结论：如果 $n$ 为奇数，则两个串 $\frac {n+1}2$ 位置必须相同（因为不能翻转）。</li>
<li>我们称下标和为 $n+1$ 的数是对应的（换句话说，第 $i$ 个位置的数和第 $n-i+1$ 位置的数是对应的），那么可以发现，对应位置形成的无序对是永远不会改变的（对于左边的数 $i$ 移动到 $i+(n-k)$，对于右边的数 $n-i+1$ 移动到 $n-i+1-(n-k)$，它们之和依旧为 $n+1$）。</li>
<li>于是大胆猜测原问题等价于是否满足 $a,b$ 无序对相同。</li>
</ul>
<h4 id="证明" tabindex="-1"> 证明</h4>
<ul>
<li>首先，上述结论是必要的。</li>
<li>其次，若对于满足上述结论的 $a$，能构造出合法的操作序列，那么原问题和 $a$ 是否满足上述结论是等价的。接下来需要构造操作序列。</li>
<li>朴素的想法是从中间到两边依次确定，因为固定住中间不影响后续操作，且固定后不影响上述结论是否成立（删除了相同的无序对不影响结论）。</li>
<li>考虑现在固定 $a_i,a_{n-i+1}$，找相同的无序对 $a_j,a_{n-j+1}$ 移动过来。设 $a_i=a_j$，分情况讨论：
<ol>
<li>$j=n$，那么直接翻转长度为 $i$ 的前后缀，那么 $a_n$ 翻到 $a_i$，$a_1$ 翻到 $a_{n-i+1}$，满足条件；</li>
<li>$j=1$，那么直接翻转长度为 $1$ 的前后缀，就变成 1. 的情况了；</li>
<li>其它，那么翻转长度为 $j(n-j+1)$ 的前后缀，那么 $j$ 就变成 1./2. 的情况了。</li>
</ol>
</li>
<li>这样就变成规模更小的子问题了，所以证明了满足上述条件即成立。</li>
</ul>
<div><pre><code><span><span>#</span><span>include</span><span>&lt;bits/stdc++.h></span></span>
<span>using</span> <span>namespace</span> std<span>;</span>
<span>typedef</span> pair<span>&lt;</span><span>int</span><span>,</span><span>int</span><span>></span> pii<span>;</span>
<span>int</span> T<span>,</span>n<span>,</span>a<span>[</span><span>510</span><span>]</span><span>,</span>b<span>[</span><span>510</span><span>]</span><span>;</span>
pii x<span>[</span><span>510</span><span>]</span><span>,</span>y<span>[</span><span>510</span><span>]</span><span>;</span>
<span>bool</span> <span>check</span><span>(</span><span>)</span><span>{</span>
	<span>int</span> m<span>=</span><span>(</span>n<span>>></span><span>1</span><span>)</span><span>+</span><span>1</span><span>;</span>
	<span>if</span> <span>(</span><span>(</span>n<span>&amp;</span><span>1</span><span>)</span><span>&amp;&amp;</span>a<span>[</span>m<span>]</span><span>!=</span>b<span>[</span>m<span>]</span><span>)</span> <span>return</span> <span>false</span><span>;</span>
	<span>for</span> <span>(</span><span>int</span> i<span>=</span><span>1</span><span>;</span>i<span>&lt;</span>m<span>;</span>i<span>++</span><span>)</span><span>{</span>
		x<span>[</span>i<span>]</span><span>=</span><span>pii</span><span>(</span><span>min</span><span>(</span>a<span>[</span>i<span>]</span><span>,</span>a<span>[</span>n<span>-</span>i<span>+</span><span>1</span><span>]</span><span>)</span><span>,</span><span>max</span><span>(</span>a<span>[</span>i<span>]</span><span>,</span>a<span>[</span>n<span>-</span>i<span>+</span><span>1</span><span>]</span><span>)</span><span>)</span><span>;</span>
		y<span>[</span>i<span>]</span><span>=</span><span>pii</span><span>(</span><span>min</span><span>(</span>b<span>[</span>i<span>]</span><span>,</span>b<span>[</span>n<span>-</span>i<span>+</span><span>1</span><span>]</span><span>)</span><span>,</span><span>max</span><span>(</span>b<span>[</span>i<span>]</span><span>,</span>b<span>[</span>n<span>-</span>i<span>+</span><span>1</span><span>]</span><span>)</span><span>)</span><span>;</span>
	<span>}</span>
	<span>sort</span><span>(</span>x<span>+</span><span>1</span><span>,</span>x<span>+</span>m<span>)</span><span>;</span> <span>sort</span><span>(</span>y<span>+</span><span>1</span><span>,</span>y<span>+</span>m<span>)</span><span>;</span>
	<span>for</span> <span>(</span><span>int</span> i<span>=</span><span>1</span><span>;</span>i<span>&lt;</span>m<span>;</span>i<span>++</span><span>)</span>
		<span>if</span> <span>(</span>x<span>[</span>i<span>]</span><span>!=</span>y<span>[</span>i<span>]</span><span>)</span> <span>return</span> <span>false</span><span>;</span>
	<span>return</span> <span>true</span><span>;</span>
<span>}</span>
<span>int</span> <span>main</span><span>(</span><span>)</span><span>{</span>
	<span>scanf</span><span>(</span><span>"%d"</span><span>,</span><span>&amp;</span>T<span>)</span><span>;</span>
	<span>while</span> <span>(</span>T<span>--</span><span>)</span><span>{</span>
		<span>scanf</span><span>(</span><span>"%d"</span><span>,</span><span>&amp;</span>n<span>)</span><span>;</span>
		<span>for</span> <span>(</span><span>int</span> i<span>=</span><span>1</span><span>;</span>i<span>&lt;=</span>n<span>;</span>i<span>++</span><span>)</span> <span>scanf</span><span>(</span><span>"%d"</span><span>,</span><span>&amp;</span>a<span>[</span>i<span>]</span><span>)</span><span>;</span>
		<span>for</span> <span>(</span><span>int</span> i<span>=</span><span>1</span><span>;</span>i<span>&lt;=</span>n<span>;</span>i<span>++</span><span>)</span> <span>scanf</span><span>(</span><span>"%d"</span><span>,</span><span>&amp;</span>b<span>[</span>i<span>]</span><span>)</span><span>;</span>
		<span>if</span> <span>(</span><span>check</span><span>(</span><span>)</span><span>)</span> <span>puts</span><span>(</span><span>"Yes"</span><span>)</span><span>;</span>
		<span>else</span> <span>puts</span><span>(</span><span>"No"</span><span>)</span><span>;</span>
	<span>}</span>
	<span>return</span> <span>0</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>CF1603E</title>
      <link>https://newzone.top/_posts/CF1603E.html</link>
      <guid>https://newzone.top/_posts/CF1603E.html</guid>
      <source url="https://newzone.top/rss.xml">CF1603E</source>
      <description>
如果 $max(a_1,a_2,\cdots,a_m)\cdot min(a_1,a_2,\cdots,a_m)\geq a_1+a_2+\cdots+a_m$，则整数序列 $a_1,a_2,\cdots,a_m$ 被称为好的。
如果 $a$ 的每个非空子序列都是好的，则整数序列 $a_1,a_2,\cdots,a_n$ 被称为完美的。
给定两个整数 $n$ 和 $M$，$M$ 是素数。求完美序列 $a_1,a_2,\cdots,a_n$ 且每项满足 $1\leq a_i\leq n+1$ 的数量，对 $M$ 取模。
$1\leq n\leq 200,10^8\leq M\leq 10^9$。

</description>
      <category>CodeForces</category>
      <pubDate>Sun, 31 Oct 2021 15:58:16 GMT</pubDate>
      <content:encoded><![CDATA[<ul>
<li>如果 $max(a_1,a_2,\cdots,a_m)\cdot min(a_1,a_2,\cdots,a_m)\geq a_1+a_2+\cdots+a_m$，则整数序列 $a_1,a_2,\cdots,a_m$ 被称为好的。</li>
<li>如果 $a$ 的每个非空<strong>子序列</strong>都是好的，则整数序列 $a_1,a_2,\cdots,a_n$ 被称为完美的。</li>
<li>给定两个整数 $n$ 和 $M$，$M$ 是素数。求完美序列 $a_1,a_2,\cdots,a_n$ 且每项满足 $1\leq a_i\leq n+1$ 的数量，对 $M$ 取模。</li>
<li>$1\leq n\leq 200,10^8\leq M\leq 10^9$。</li>
</ul>

<h3 id="sol" tabindex="-1"> sol</h3>
<ul>
<li>可以发现 一个序列是完美的 等价于 将它从小到大排序后的序列是完美的（即顺序无关）。</li>
</ul>
<h4 id="判断一个从小到大的序列是否是完美的" tabindex="-1"> 判断一个从小到大的序列是否是完美的</h4>
<ul>
<li>
<p>以下的序列，$a$ 都是从小到大的序列。</p>
</li>
<li>
<p>发现这等价于这个序列的所有前缀都是好的。</p>
<ul>
<li>假设选出的子序列的最小/最大下标分别为 $l,r$，那么 $mul\geq a_1\cdot a_r\geq a_1+a_2+\cdots a_r\geq sum$。</li>
</ul>
</li>
<li>
<p>这还不够，我们再找一些条件。</p>
</li>
</ul>
<ol>
<li>$a_k\geq k$。
<ul>
<li>如果不满足，则 $a_1\cdot a_k&lt;a_1\cdots k&lt;a_1+a_2+\cdots a_r$ 矛盾。</li>
</ul>
</li>
<li>若存在 $a_k=k$，则 $a_1=a_2=\cdots=a_k=k$。
<ul>
<li>$a_1\cdot a_k=a_1\cdot k\geq a_1+a_2+\cdots a_r$，即 $(a_1-a_1)+(a_2-a_1)+\cdots+(a_k-a_1)\leq 0$，而 $a_i\geq a_1$，所以 $a_i=k$。</li>
<li>可以发现 $a_n=n$ 只有一种方案，否则 $a_n=n+1$。</li>
</ul>
</li>
<li>如果 $a_n=n+1,a_i\geq i+1$，那么整个序列是完美的 等价于 整个序列是好的。
<ul>
<li>整个序列是好的当且仅当 $(a_1-a_1)+(a_2-a_1)+\cdots+(a_n-a_1)\leq a_1$。</li>
<li>整个序列是完美的显然必须满足整个序列是好的。</li>
<li>考虑前缀 $1..k$，它是好的当且仅当 $(a_1-a_1)+(a_2-a_1)+\cdots+(a_k-a_1)\leq a_1\cdot (a_k-k)$，若满足 $(a_1-a_1)+(a_2-a_1)+\cdots+(a_n-a_1)\leq a_1$（整个序列是好的） 则一定满足上述条件，而每个前缀都是好的所以整个序列是完美的。</li>
</ul>
</li>
<li>如果 $a_n=n+1,a_i\geq i$，那么整个序列是完美的 等价于 满足条件 2，且整个序列是好的。
<ul>
<li>满足条件 2，假设 $a_1=a_2=\cdots=a_k=k$，对于长度不超过 $k$ 的前缀显然都是好的。</li>
<li>长度超过 $k$ 的前缀证明和 3 类似。</li>
</ul>
</li>
</ol>
<h4 id="从小到大的完美序列的方案数" tabindex="-1"> 从小到大的完美序列的方案数</h4>
<ul>
<li>
<p>固定 $a_1$ 的值：</p>
<ul>
<li>
<p>$a_1\leq a_2\leq \cdots \leq a_n$。</p>
</li>
<li>
<p>对于 $i\leq a_1$，$a_1\leq a_i\leq n+1$</p>
<ul>
<li>$a_2\cdots a_{i-1}$ 不能 $&lt;a_1$，否则就和单调性（从小到大）矛盾。</li>
<li>$a_{a_1}$ 可以是 $a_{a_1}$ 也可以是更大的数。</li>
<li>你也可以把这个条件当成：对于 $i\lt a_1$，$i+1\leq a_i\leq n+1$ 且 $a_1\leq a_{a_1}\leq n+1$，但是这个形式不便于之后的计算。</li>
</ul>
</li>
<li>
<p>对于 $i&gt;a_1$，$i+1\leq a_i\leq n+1$</p>
<ul>
<li>$a_i$ 不能取 $i$，否则就和 $a_1$ 的值矛盾（条件2）。</li>
</ul>
</li>
<li>
<p>$(a_1-a_1)+(a_2-a_1)+\cdots+(a_n-a_1)\leq a_1$。</p>
</li>
<li>
<p>设 $b_i=a_i-a_1$，那么：</p>
<ul>
<li>$b_1=0$</li>
<li>$b_1\leq b_2\leq \cdots \leq b_n$</li>
<li>$0\leq b_i\leq n+1-a_1$</li>
<li>$b_1+b_2+\cdots+b_n\leq a_1$</li>
<li>$b_n\geq n+1-a_1$，$b_{n-1}\geq n-a_1$，...，$b_{a_1+1}\geq 2$</li>
</ul>
</li>
<li>
<p>显然固定 $a_1$ 后，$b$ 和 $a$ 是一一对应的。</p>
</li>
</ul>
</li>
<li>
<p>由于需要满足 $b_n\geq n+1-a_1$，$b_{n-1}\geq n-a_1$，...，$b_{a_1+1}\geq 2$ 和 $b_1+b_2+\cdots+b_n\leq a_1$ 这两个条件，$a_1$ 大概只有 $O(\sqrt n)$ 种取值。</p>
</li>
<li>
<p>枚举发现 $n$ 取最大值 $200$ 时，$a_1\geq n-17$。</p>
</li>
</ul>
<h4 id="完美序列的方案数" tabindex="-1"> 完美序列的方案数</h4>
<ul>
<li>即上面的做法的 $b$ 顺序可以任意排列。</li>
<li>依旧固定 $a$ 的最小值 $x(x\geq n-17)$：
<ul>
<li>设 $b_i=a_i-x$，那么：
<ul>
<li>$\exists k,b_k=0$</li>
<li>$0\leq b_i\leq n+1-x$</li>
<li>$b_1+b_2+\cdots+b_n\leq x$</li>
<li>$\geq 1$ 个数 $\geq n+1-x$，$\geq 2$ 个数 $\geq n-x$，...，$\geq n-x$ 个数 $\geq 2$。
这等价于 $\leq x$ 个数 $\leq 1$，$\leq x+1$ 个数 $\leq 2$，...，$\leq n-1$ 个数 $\leq n-x$（再加个 $\leq n$ 个数 $\leq n+1-x$ 也不影响）。</li>
</ul>
</li>
<li>对 $b$ 计数，设 $dp[i][j][k]$ 表示考虑完值 $\leq i$ 的位置，共选了 $j(j\leq x+i-1)$ 个数，选的数之和为 $k$ 的方案数。转移枚举有 $t$ 个值为 $i$ 的位置，从 $\frac{dp[i-1][j-t][k-i*t]}{t!}$ 转移过来。除这个阶乘是因为组合数选位置，最后计算答案要乘上 $n!$。</li>
</ul>
</li>
<li>实现时可以使用记忆化，实际用到的状态并不多。理论时间复杂度为 $O(n^3\sqrt n\log n)$。</li>
</ul>
<div><pre><code><span><span>#</span><span>include</span><span>&lt;bits/stdc++.h></span></span>
<span>using</span> <span>namespace</span> std<span>;</span>
<span>typedef</span> <span>long</span> <span>long</span> ll<span>;</span>
<span>int</span> n<span>,</span>Mod<span>,</span>x<span>;</span>
ll fac<span>[</span><span>210</span><span>]</span><span>,</span>inv<span>[</span><span>210</span><span>]</span><span>;</span>
<span>int</span> dp<span>[</span><span>210</span><span>]</span><span>[</span><span>210</span><span>]</span><span>[</span><span>210</span><span>]</span><span>;</span>
<span>int</span> <span>solve</span><span>(</span><span>int</span> i<span>,</span><span>int</span> j<span>,</span><span>int</span> k<span>)</span><span>{</span>
	<span>if</span> <span>(</span><span>!</span>i<span>)</span> <span>return</span> <span>(</span>k<span>?</span><span>0</span><span>:</span><span>(</span><span>!</span>j<span>?</span><span>0</span><span>:</span>inv<span>[</span>j<span>]</span><span>)</span><span>)</span><span>;</span>
	<span>if</span> <span>(</span>j<span>></span>x<span>+</span>i<span>-</span><span>1</span><span>)</span> <span>return</span> <span>0</span><span>;</span>
	<span>if</span> <span>(</span><span>~</span>dp<span>[</span>i<span>]</span><span>[</span>j<span>]</span><span>[</span>k<span>]</span><span>)</span> <span>return</span> dp<span>[</span>i<span>]</span><span>[</span>j<span>]</span><span>[</span>k<span>]</span><span>;</span>
	<span>int</span> res<span>=</span><span>0</span><span>;</span>
	<span>for</span> <span>(</span><span>int</span> t<span>=</span><span>0</span><span>;</span>t<span>&lt;=</span>j<span>&amp;&amp;</span>i<span>*</span>t<span>&lt;=</span>k<span>;</span>t<span>++</span><span>)</span>
		res<span>=</span><span>(</span>res<span>+</span><span>solve</span><span>(</span>i<span>-</span><span>1</span><span>,</span>j<span>-</span>t<span>,</span>k<span>-</span>i<span>*</span>t<span>)</span><span>*</span>inv<span>[</span>t<span>]</span><span>)</span><span>%</span>Mod<span>;</span>
	dp<span>[</span>i<span>]</span><span>[</span>j<span>]</span><span>[</span>k<span>]</span><span>=</span>res<span>;</span> <span>return</span> res<span>;</span>
<span>}</span>
<span>int</span> <span>main</span><span>(</span><span>)</span><span>{</span>
	<span>scanf</span><span>(</span><span>"%d%d"</span><span>,</span><span>&amp;</span>n<span>,</span><span>&amp;</span>Mod<span>)</span><span>;</span>
	fac<span>[</span><span>0</span><span>]</span><span>=</span><span>1</span><span>;</span> <span>for</span> <span>(</span><span>int</span> i<span>=</span><span>1</span><span>;</span>i<span>&lt;=</span>n<span>;</span>i<span>++</span><span>)</span> fac<span>[</span>i<span>]</span><span>=</span>fac<span>[</span>i<span>-</span><span>1</span><span>]</span><span>*</span>i<span>%</span>Mod<span>;</span>
	inv<span>[</span><span>1</span><span>]</span><span>=</span><span>1</span><span>;</span> <span>for</span> <span>(</span><span>int</span> i<span>=</span><span>2</span><span>;</span>i<span>&lt;=</span>n<span>;</span>i<span>++</span><span>)</span> inv<span>[</span>i<span>]</span><span>=</span><span>(</span>Mod<span>-</span>Mod<span>/</span>i<span>)</span><span>*</span>inv<span>[</span>Mod<span>%</span>i<span>]</span><span>%</span>Mod<span>;</span>
	inv<span>[</span><span>0</span><span>]</span><span>=</span><span>1</span><span>;</span> <span>for</span> <span>(</span><span>int</span> i<span>=</span><span>1</span><span>;</span>i<span>&lt;=</span>n<span>;</span>i<span>++</span><span>)</span> inv<span>[</span>i<span>]</span><span>=</span>inv<span>[</span>i<span>-</span><span>1</span><span>]</span><span>*</span>inv<span>[</span>i<span>]</span><span>%</span>Mod<span>;</span>
	<span>int</span> ans<span>=</span><span>0</span><span>;</span>
	<span>for</span> <span>(</span>x<span>=</span><span>max</span><span>(</span><span>1</span><span>,</span>n<span>-</span><span>17</span><span>)</span><span>;</span>x<span>&lt;=</span>n<span>+</span><span>1</span><span>;</span>x<span>++</span><span>)</span><span>{</span>
		<span>memset</span><span>(</span>dp<span>,</span><span>-</span><span>1</span><span>,</span><span>sizeof</span><span>(</span>dp<span>)</span><span>)</span><span>;</span>
		<span>for</span> <span>(</span><span>int</span> k<span>=</span><span>0</span><span>;</span>k<span>&lt;=</span>x<span>;</span>k<span>++</span><span>)</span> ans<span>=</span><span>(</span>ans<span>+</span><span>solve</span><span>(</span>n<span>+</span><span>1</span><span>-</span>x<span>,</span>n<span>,</span>k<span>)</span><span>)</span><span>%</span>Mod<span>;</span>
	<span>}</span>
	<span>printf</span><span>(</span><span>"%lld\n"</span><span>,</span>ans<span>*</span>fac<span>[</span>n<span>]</span><span>%</span>Mod<span>)</span><span>;</span>
	<span>return</span> <span>0</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>CF555E</title>
      <link>https://newzone.top/_posts/CF555E.html</link>
      <guid>https://newzone.top/_posts/CF555E.html</guid>
      <source url="https://newzone.top/rss.xml">CF555E</source>
      <description>
给定一个 $n$ 个点 $m$ 条边的无向图。有 $q$ 个人，第 $i$ 个人要从 $s_i$ 到 $t_i$。
现在你要给无向图的每条边定向。问是否存在一种定向方法使得所有人都能够到达目的地。
$n,m,q\leq 2\times 10^5,u_i\neq v_i,s_i\neq t_i$

</description>
      <category>CodeForces</category>
      <pubDate>Thu, 24 Sep 2020 16:35:45 GMT</pubDate>
      <content:encoded><![CDATA[<ul>
<li>给定一个 $n$ 个点 $m$ 条边的无向图。有 $q$ 个人，第 $i$ 个人要从 $s_i$ 到 $t_i$。</li>
<li>现在你要给无向图的每条边定向。问是否存在一种定向方法使得所有人都能够到达目的地。</li>
<li>$n,m,q\leq 2\times 10^5,u_i\neq v_i,s_i\neq t_i$</li>
</ul>

<h3 id="sol" tabindex="-1"> sol</h3>
<h4 id="我的做法-186ms" tabindex="-1"> 我的做法（186ms）</h4>
<ul>
<li>
<p>可以发现，对于一个边双来说，一定存在一种定向方法，使得边数内两两点之间均可到达。</p>
</li>
<li>
<p>所以一个边双相当于一个点。那么我们缩点，把图变成一颗树。这样，$s$ 到 $t$ 只能走树上简单路径。</p>
</li>
<li>
<p>我们把 $s\rightarrow LCA$ 的路径打向上的标记，把 $LCA\rightarrow t$ 的路径打向下的标记。$LCA$ 可以通过倍增预处理。</p>
</li>
<li>
<p>只要没有一条边同时有两种标记，就是合法的。打标记使用树上差分实现。</p>
</li>
<li>
<p>时间复杂度：$ O(n+m+q\log n)$。</p>
</li>
</ul>
<h5 id="细节" tabindex="-1"> 细节</h5>
<ol>
<li>原图不保证连通，所以在缩点，预处理倍增，判断答案的时候要在每个连通块都做一次。</li>
<li>原图可能有重边，所以 $\rm tarjan$ 的时候要记上一条边的编号而不是父亲节点。</li>
</ol>
<div><pre><code><span>/*********************************************************************
 * Problem：CF555E
 * Author：hydd
 * Date：2020/8/30 - 2020/8/31
*********************************************************************/</span>
<span><span>#</span><span>include</span><span>&lt;cstdio></span></span>
<span><span>#</span><span>include</span><span>&lt;algorithm></span></span>
<span><span>#</span><span>include</span><span>&lt;vector></span></span>
<span>//#define File(x) freopen(x".in","r",stdin);freopen(x".out","w",stdout)</span>
<span>using</span> <span>namespace</span> std<span>;</span>
<span>const</span> <span>int</span> MAXN<span>=</span><span>210000</span><span>;</span>
<span>const</span> <span>int</span> MAXM<span>=</span><span>410000</span><span>;</span>
<span>int</span> n<span>,</span>m<span>,</span>q<span>,</span>u<span>[</span>MAXN<span>]</span><span>,</span>v<span>[</span>MAXN<span>]</span><span>;</span>
<span>int</span> top<span>,</span>st<span>[</span>MAXN<span>]</span><span>,</span>fr<span>[</span>MAXN<span>]</span><span>,</span>dep<span>[</span>MAXN<span>]</span><span>;</span>
<span>int</span> cnt2<span>,</span>fa<span>[</span>MAXN<span>]</span><span>[</span><span>19</span><span>]</span><span>;</span> <span>bool</span> vis<span>[</span>MAXN<span>]</span><span>;</span>
<span>int</span> cnt<span>,</span>num<span>[</span>MAXN<span>]</span><span>,</span>up<span>[</span>MAXN<span>]</span><span>,</span>dw<span>[</span>MAXN<span>]</span><span>;</span>
<span>int</span> dtime<span>,</span>dfn<span>[</span>MAXN<span>]</span><span>,</span>low<span>[</span>MAXN<span>]</span><span>;</span>
vector<span>&lt;</span><span>int</span><span>></span> vec<span>[</span>MAXN<span>]</span><span>;</span>
<span>int</span> edgenum<span>=</span><span>1</span><span>,</span>vet<span>[</span>MAXM<span>]</span><span>,</span>Next<span>[</span>MAXM<span>]</span><span>,</span>Head<span>[</span>MAXN<span>]</span><span>;</span>
<span>void</span> <span>addedge</span><span>(</span><span>int</span> u<span>,</span><span>int</span> v<span>)</span><span>{</span>
	vet<span>[</span><span>++</span>edgenum<span>]</span><span>=</span>v<span>;</span>
	Next<span>[</span>edgenum<span>]</span><span>=</span>Head<span>[</span>u<span>]</span><span>;</span>
	Head<span>[</span>u<span>]</span><span>=</span>edgenum<span>;</span>
<span>}</span>
<span>char</span> <span>Getchar</span><span>(</span><span>)</span><span>{</span>
	<span>static</span> <span>char</span> now<span>[</span><span>1</span><span>&lt;&lt;</span><span>20</span><span>]</span><span>,</span><span>*</span>S<span>,</span><span>*</span>T<span>;</span>
	<span>if</span> <span>(</span>T<span>==</span>S<span>)</span><span>{</span>
		T<span>=</span><span>(</span>S<span>=</span>now<span>)</span><span>+</span><span>fread</span><span>(</span>now<span>,</span><span>1</span><span>,</span><span>1</span><span>&lt;&lt;</span><span>20</span><span>,</span><span>stdin</span><span>)</span><span>;</span>
		<span>if</span> <span>(</span>T<span>==</span>S<span>)</span> <span>return</span> <span>EOF</span><span>;</span>
	<span>}</span>
	<span>return</span> <span>*</span>S<span>++</span><span>;</span>
<span>}</span>
<span>int</span> <span>read</span><span>(</span><span>)</span><span>{</span>
	<span>int</span> x<span>=</span><span>0</span><span>,</span>f<span>=</span><span>1</span><span>;</span>
	<span>char</span> ch<span>=</span><span>Getchar</span><span>(</span><span>)</span><span>;</span>
	<span>while</span> <span>(</span>ch<span>&lt;</span><span>'0'</span><span>||</span>ch<span>></span><span>'9'</span><span>)</span><span>{</span>
		<span>if</span> <span>(</span>ch<span>==</span><span>'-'</span><span>)</span> f<span>=</span><span>-</span><span>1</span><span>;</span>
		ch<span>=</span><span>Getchar</span><span>(</span><span>)</span><span>;</span>
	<span>}</span>
	<span>while</span> <span>(</span>ch<span>&lt;=</span><span>'9'</span><span>&amp;&amp;</span>ch<span>>=</span><span>'0'</span><span>)</span> x<span>=</span>x<span>*</span><span>10</span><span>+</span>ch<span>-</span><span>'0'</span><span>,</span>ch<span>=</span><span>Getchar</span><span>(</span><span>)</span><span>;</span>
	<span>return</span> x<span>*</span>f<span>;</span>
<span>}</span>
<span>void</span> <span>tarjan</span><span>(</span><span>int</span> u<span>,</span><span>int</span> le<span>)</span><span>{</span><span>//2.</span>
	dfn<span>[</span>u<span>]</span><span>=</span>low<span>[</span>u<span>]</span><span>=</span><span>++</span>dtime<span>;</span>
	st<span>[</span><span>++</span>top<span>]</span><span>=</span>u<span>;</span> <span>int</span> v<span>;</span>
	<span>for</span> <span>(</span><span>int</span> e<span>=</span>Head<span>[</span>u<span>]</span><span>;</span>e<span>;</span>e<span>=</span>Next<span>[</span>e<span>]</span><span>)</span><span>{</span>
		v<span>=</span>vet<span>[</span>e<span>]</span><span>;</span>
		<span>if</span> <span>(</span>e<span>==</span><span>(</span>le<span>^</span><span>1</span><span>)</span><span>)</span> <span>continue</span><span>;</span>
		<span>if</span> <span>(</span><span>!</span>dfn<span>[</span>v<span>]</span><span>)</span><span>{</span>
			<span>tarjan</span><span>(</span>v<span>,</span>e<span>)</span><span>;</span>
			low<span>[</span>u<span>]</span><span>=</span><span>min</span><span>(</span>low<span>[</span>u<span>]</span><span>,</span>low<span>[</span>v<span>]</span><span>)</span><span>;</span>
		<span>}</span> <span>else</span> low<span>[</span>u<span>]</span><span>=</span><span>min</span><span>(</span>low<span>[</span>u<span>]</span><span>,</span>dfn<span>[</span>v<span>]</span><span>)</span><span>;</span>
	<span>}</span>
	<span>if</span> <span>(</span>dfn<span>[</span>u<span>]</span><span>==</span>low<span>[</span>u<span>]</span><span>)</span><span>{</span>
		cnt<span>++</span><span>;</span>
		<span>while</span> <span>(</span>st<span>[</span>top<span>]</span><span>!=</span>u<span>)</span><span>{</span> num<span>[</span>st<span>[</span>top<span>]</span><span>]</span><span>=</span>cnt<span>;</span> top<span>--</span><span>;</span><span>}</span>
		num<span>[</span>st<span>[</span>top<span>]</span><span>]</span><span>=</span>cnt<span>;</span> top<span>--</span><span>;</span>
	<span>}</span>
<span>}</span>
<span>void</span> <span>dfs</span><span>(</span><span>int</span> u<span>,</span><span>int</span> f<span>)</span><span>{</span>
	fr<span>[</span>u<span>]</span><span>=</span>cnt2<span>;</span> dep<span>[</span>u<span>]</span><span>=</span>dep<span>[</span>f<span>]</span><span>+</span><span>1</span><span>;</span> fa<span>[</span>u<span>]</span><span>[</span><span>0</span><span>]</span><span>=</span>f<span>;</span>
	<span>for</span> <span>(</span><span>int</span> i<span>=</span><span>1</span><span>;</span><span>(</span><span>1</span><span>&lt;&lt;</span>i<span>)</span><span>&lt;</span>dep<span>[</span>u<span>]</span><span>;</span>i<span>++</span><span>)</span> fa<span>[</span>u<span>]</span><span>[</span>i<span>]</span><span>=</span>fa<span>[</span>fa<span>[</span>u<span>]</span><span>[</span>i<span>-</span><span>1</span><span>]</span><span>]</span><span>[</span>i<span>-</span><span>1</span><span>]</span><span>;</span>
	<span>for</span> <span>(</span><span>int</span> v<span>:</span>vec<span>[</span>u<span>]</span><span>)</span><span>{</span>
		<span>if</span> <span>(</span>v<span>==</span>f<span>)</span> <span>continue</span><span>;</span>
		<span>dfs</span><span>(</span>v<span>,</span>u<span>)</span><span>;</span>
	<span>}</span>
<span>}</span>
<span>void</span> <span>dfs2</span><span>(</span><span>int</span> u<span>,</span><span>int</span> f<span>)</span><span>{</span>
	vis<span>[</span>u<span>]</span><span>=</span><span>true</span><span>;</span>
	<span>for</span> <span>(</span><span>int</span> v<span>:</span>vec<span>[</span>u<span>]</span><span>)</span><span>{</span>
		<span>if</span> <span>(</span>v<span>==</span>f<span>)</span> <span>continue</span><span>;</span>
		<span>dfs2</span><span>(</span>v<span>,</span>u<span>)</span><span>;</span>
		up<span>[</span>u<span>]</span><span>+=</span>up<span>[</span>v<span>]</span><span>;</span> dw<span>[</span>u<span>]</span><span>+=</span>dw<span>[</span>v<span>]</span><span>;</span>
	<span>}</span>
<span>}</span>
<span>int</span> <span>LCA</span><span>(</span><span>int</span> x<span>,</span><span>int</span> y<span>)</span><span>{</span>
	<span>if</span> <span>(</span>dep<span>[</span>x<span>]</span><span>&lt;</span>dep<span>[</span>y<span>]</span><span>)</span> <span>swap</span><span>(</span>x<span>,</span>y<span>)</span><span>;</span>
	<span>int</span> d<span>=</span>dep<span>[</span>x<span>]</span><span>-</span>dep<span>[</span>y<span>]</span><span>;</span>
	<span>for</span> <span>(</span><span>int</span> i<span>=</span><span>0</span><span>;</span>i<span>&lt;=</span><span>18</span><span>;</span>i<span>++</span><span>)</span>
		<span>if</span> <span>(</span>d<span>&amp;</span><span>(</span><span>1</span><span>&lt;&lt;</span>i<span>)</span><span>)</span> x<span>=</span>fa<span>[</span>x<span>]</span><span>[</span>i<span>]</span><span>;</span>
	<span>if</span> <span>(</span>x<span>==</span>y<span>)</span> <span>return</span> x<span>;</span>
	<span>for</span> <span>(</span><span>int</span> i<span>=</span><span>18</span><span>;</span>i<span>>=</span><span>0</span><span>;</span>i<span>--</span><span>)</span>
		<span>if</span> <span>(</span>fa<span>[</span>x<span>]</span><span>[</span>i<span>]</span><span>!=</span>fa<span>[</span>y<span>]</span><span>[</span>i<span>]</span><span>)</span><span>{</span>
			x<span>=</span>fa<span>[</span>x<span>]</span><span>[</span>i<span>]</span><span>;</span>
			y<span>=</span>fa<span>[</span>y<span>]</span><span>[</span>i<span>]</span><span>;</span>
		<span>}</span>
	<span>return</span> fa<span>[</span>x<span>]</span><span>[</span><span>0</span><span>]</span><span>;</span>
<span>}</span>
<span>bool</span> <span>check</span><span>(</span><span>)</span><span>{</span>
	<span>int</span> s<span>,</span>t<span>;</span>
	<span>while</span> <span>(</span>q<span>--</span><span>)</span><span>{</span>
		s<span>=</span><span>read</span><span>(</span><span>)</span><span>;</span> t<span>=</span><span>read</span><span>(</span><span>)</span><span>;</span>
		s<span>=</span>num<span>[</span>s<span>]</span><span>;</span> t<span>=</span>num<span>[</span>t<span>]</span><span>;</span>
		<span>if</span> <span>(</span>fr<span>[</span>s<span>]</span><span>!=</span>fr<span>[</span>t<span>]</span><span>)</span> <span>return</span> <span>false</span><span>;</span>
		<span>int</span> w<span>=</span><span>LCA</span><span>(</span>s<span>,</span>t<span>)</span><span>;</span>
		up<span>[</span>s<span>]</span><span>++</span><span>;</span> up<span>[</span>w<span>]</span><span>--</span><span>;</span>
		dw<span>[</span>t<span>]</span><span>++</span><span>;</span> dw<span>[</span>w<span>]</span><span>--</span><span>;</span>
	<span>}</span>
	<span>for</span> <span>(</span><span>int</span> i<span>=</span><span>1</span><span>;</span>i<span>&lt;=</span>n<span>;</span>i<span>++</span><span>)</span>
		<span>if</span> <span>(</span><span>!</span>vis<span>[</span>i<span>]</span><span>)</span> <span>dfs2</span><span>(</span>i<span>,</span><span>0</span><span>)</span><span>;</span><span>//1.</span>
	<span>for</span> <span>(</span><span>int</span> i<span>=</span><span>1</span><span>;</span>i<span>&lt;=</span>cnt<span>;</span>i<span>++</span><span>)</span>
		<span>if</span> <span>(</span>up<span>[</span>i<span>]</span><span>&amp;&amp;</span>dw<span>[</span>i<span>]</span><span>)</span> <span>return</span> <span>false</span><span>;</span>
	<span>return</span> <span>true</span><span>;</span>
<span>}</span>
<span>int</span> <span>main</span><span>(</span><span>)</span><span>{</span>
	n<span>=</span><span>read</span><span>(</span><span>)</span><span>;</span> m<span>=</span><span>read</span><span>(</span><span>)</span><span>;</span> q<span>=</span><span>read</span><span>(</span><span>)</span><span>;</span>
	edgenum<span>=</span><span>1</span><span>;</span>
	<span>for</span> <span>(</span><span>int</span> i<span>=</span><span>1</span><span>;</span>i<span>&lt;=</span>m<span>;</span>i<span>++</span><span>)</span><span>{</span>
		u<span>[</span>i<span>]</span><span>=</span><span>read</span><span>(</span><span>)</span><span>;</span> v<span>[</span>i<span>]</span><span>=</span><span>read</span><span>(</span><span>)</span><span>;</span>
		<span>addedge</span><span>(</span>u<span>[</span>i<span>]</span><span>,</span>v<span>[</span>i<span>]</span><span>)</span><span>;</span> <span>addedge</span><span>(</span>v<span>[</span>i<span>]</span><span>,</span>u<span>[</span>i<span>]</span><span>)</span><span>;</span>
	<span>}</span>
	<span>for</span> <span>(</span><span>int</span> i<span>=</span><span>1</span><span>;</span>i<span>&lt;=</span>n<span>;</span>i<span>++</span><span>)</span>
		<span>if</span> <span>(</span><span>!</span>dfn<span>[</span>i<span>]</span><span>)</span> <span>tarjan</span><span>(</span>i<span>,</span><span>0</span><span>)</span><span>;</span><span>//1.</span>
	<span>int</span> x<span>,</span>y<span>;</span>
	<span>for</span> <span>(</span><span>int</span> i<span>=</span><span>1</span><span>;</span>i<span>&lt;=</span>m<span>;</span>i<span>++</span><span>)</span><span>{</span>
		x<span>=</span>num<span>[</span>u<span>[</span>i<span>]</span><span>]</span><span>;</span> y<span>=</span>num<span>[</span>v<span>[</span>i<span>]</span><span>]</span><span>;</span>
		<span>if</span> <span>(</span>x<span>==</span>y<span>)</span> <span>continue</span><span>;</span>
		vec<span>[</span>x<span>]</span><span>.</span><span>push_back</span><span>(</span>y<span>)</span><span>;</span>
		vec<span>[</span>y<span>]</span><span>.</span><span>push_back</span><span>(</span>x<span>)</span><span>;</span>
	<span>}</span>
	<span>for</span> <span>(</span><span>int</span> i<span>=</span><span>1</span><span>;</span>i<span>&lt;=</span>cnt<span>;</span>i<span>++</span><span>)</span>
		<span>if</span> <span>(</span><span>!</span>fr<span>[</span>i<span>]</span><span>)</span><span>{</span> cnt2<span>++</span><span>;</span> <span>dfs</span><span>(</span>i<span>,</span><span>0</span><span>)</span><span>;</span><span>}</span><span>//1.</span>
	<span>if</span> <span>(</span><span>check</span><span>(</span><span>)</span><span>)</span> <span>puts</span><span>(</span><span>"Yes"</span><span>)</span><span>;</span>
	<span>else</span> <span>puts</span><span>(</span><span>"No"</span><span>)</span><span>;</span>
	<span>return</span> <span>0</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>可以使用 $\rm tarjan$ 求 $LCA$ 得到更优的时间复杂度 $O(n+m+q)$。</p>
]]></content:encoded>
    </item>
    <item>
      <title>IOI2022 部分题解</title>
      <link>https://newzone.top/_posts/IOI2022.html</link>
      <guid>https://newzone.top/_posts/IOI2022.html</guid>
      <source url="https://newzone.top/rss.xml">IOI2022 部分题解</source>
      <category>IOI2022</category>
      <pubDate>Sat, 27 Aug 2022 13:54:17 GMT</pubDate>
      <content:encoded><![CDATA[<p>Day2 T3 <a href="https://qoj.ac/contest/987/problem/4566" target="_blank" rel="noopener noreferrer">Thousands Islands</a> 待填。</p>
<h3 id="catfish-farm" tabindex="-1"> <a href="https://qoj.ac/contest/986/problem/4561" target="_blank" rel="noopener noreferrer">Catfish Farm</a></h3>
<p>第 $i$ 列哪些鱼被抓住，只和第 $i$ 列堤的高度，以及 $i-1/i+1$ 列中较高堤的高度有关。</p>
<p>容易想到按列 dp，这样第 $i$ 列就有两种情况，较高的列是 $i-1/i+1$。</p>
<p>这个较高没有必要，仅仅多加了限制，所以可以每个 $i$ 自由选择 $i-1/i+1$，这样如果选的不是较高的答案只会更小。</p>
<p>我开始想的是，对于选择 $i-1$ 的，记录第 $i$ 列的高度；对于选择 $i+1$ 的，记录这列抓的鱼最高的高度。这样状态就表示算完了前 $i$ 列的答案，当前是选择 $i-1/i+1$。</p>
<p>其实不用这样，<strong>题目要求我们每一列选择一个堤的高度，就按照题目来，状态改为表示固定完了前 $i$ 列堤的高度</strong>，当前是选择 $i-1/i+1$。选择 $i+1$ 的答案在 $i+1$ 时再计算。</p>
<p>具体来说，记 $dp(i,j,0/1)$ 表示前 $i$ 列，堤恰好不覆盖这一列从下往上第 $j$ 条鱼，当前选择 $i+1/i-1$（当前列贡献 未计算/已计算）。对于前一列选当前列/这一列选前一列的，要算上增加的贡献。</p>
<p>https://qoj.ac/submission/44615</p>
<h3 id="prisoner-challenge" tabindex="-1"> <a href="https://qoj.ac/contest/986/problem/4562" target="_blank" rel="noopener noreferrer">Prisoner Challenge</a></h3>
<p>比较大小，容易想到在二进制下<strong>按位比较</strong>。$x$ 需要记录当前存的是第几位，当前位为 $\empty/A$ 的当前位的值是多少。</p>
<p>每次，如果当前记录的是 $A$，就拿 $B$ 这一位比较，如果相同跳到下一位，否则返回；记录的是 $\empty$，就把 $A$ 这一位记录进去。</p>
<p>这样次数太多（大概是 $3\log n$），但是用 $B$ 比较完相同后，你其实可以知道 $B$ 下一位的信息，把 $B$ 下一位信息存进去。可以发现，比较是按照位数 $B,A,B,A$ 交替，不需要记录里面存的是 $A/B$，现在只需要记录位数和当前位的值，大概是 $2\log n$。</p>
<p>一种思路是换进制，$k$ 进制应该是 $k\lceil\log_k n\rceil$，但还是不能通过。</p>
<p><strong>二分和从高到低贪心填是几乎等价的。按照同样思路，可以改为每次把值域范围分成 $k$ 份，看是否在同一个值域区间</strong>，次数是 $f(n)=f(\lceil \frac n k\rceil)+k$，没区别。</p>
<p>题目保证了两个数不同，故如果当前数为 $1$ 或 $n$ 就直接返回，把剩下的范围再分成 $k$ 份，也就是 $f(n)=f(\lceil \frac {n-2} k\rceil)+k$。</p>
<p>把这个式子拿去 $dp$，对于不同的 $n$，$k$ 不固定，$f(n)=\min_k f(\lceil \frac {n-2} k\rceil)+k$，这样算出来 $f(5000)$ 恰好为 $20$。就按照 dp 出的方案选 $k$ 即可。</p>
<p>https://qoj.ac/submission/45397</p>
<h3 id="radio-towers" tabindex="-1"> <a href="https://qoj.ac/contest/986/problem/4563" target="_blank" rel="noopener noreferrer">Radio Towers</a></h3>
<p>先考虑固定 $D$，对于选择的两个信号塔 $i,j$，中间要存在一个塔 $k$，$H_k\geq \max(H_i,H_j)+D$。</p>
<p>可以发现只有相邻的两个选择的信号塔才需要判断。</p>
<p>对每个 $i$，<strong>找到左右第一个 $k$，满足 $H_k\geq H_i+D$，分别记作 $L_i,R_i$。</strong></p>
<p>$i,j$ 之间要有满足条件的塔，就要求 $R_i\leq L_j$（$i,j$ 中较大的对应的位置一定满足 $k$ 的条件），<strong>也就是区间 $[L_i,R_i)$ 两两不交。</strong></p>
<p>同理易证区间<strong>只会有包含和不交两种情况</strong>（$D\geq 0$），对于两个位置 $i,j$，不妨假设 $H_i\geq H_j$，若 $R_i&gt;L_j$，则区间 $[L_j,R_j)$ 都不满足条件，即 $R_i\geq R_j$。</p>
<p>不考虑询问的区间限制，$D$ 增加时，$L$ 只可能减小，$R$ 只可能增大，且根据证明，只有 $H$ 大的包含 $H$ 小的，故只会一些不是包含关系的区间变成了包含关系。</p>
<p>按照 $D$ 从小到大，每次把所有包含其它区间的区间全部删去（维护 $i$ 对应区间包含相邻某个的最小时刻），剩下的区间个数就是当前 $D$ 能选的数量。</p>
<p>有询问给定的区间限制 $l,r$ 时，把当前 $D$ 所有剩下的 $i$ 在 $[l,r]$ 内的个数求出来，但这样可能两边各少 $0/1$ 个区间（一个 $i$ 在 $[l,r]$ 内的，包含了一个在 $[l,r]$ 外的被删除了，实际上这个 $i$ 可以选）。</p>
<p>如果求出来的个数不为 $0$，看其中最小的 $L$ 和最大的 $R$，看 $[l,L),(R,r]$ 内是否还能选。要求区间内 $x&lt;y,H_x-H_y$（或 $H_y-H_x$）的最大值，类似于 $ST$ 表的方法预处理即可。</p>
<p>https://qoj.ac/submission/45344</p>
<h3 id="digital-circuit" tabindex="-1"> <a href="https://qoj.ac/contest/987/problem/4564" target="_blank" rel="noopener noreferrer">Digital Circuit</a></h3>
<p>必须有一个叶子节点到根一路都是黑色，但是直接计数会<strong>算重</strong>。</p>
<p><strong>要每一种方案对应唯一的叶子节点（相当于添加了限制条件）。</strong></p>
<p>树的形态固定，由于根节点为黑色，说明儿子里至少有 $p$（参数）个是黑色，那么选择其中的第 $p$ 个黑色儿子，往下走。</p>
<p>最终会走到一个叶子节点，则设这种方案对应这个叶子节点。</p>
<p>现在考虑每个叶子节点 $x$，算对应到它的方案的数量。首先它到根的都必须是黑色，<strong>此外其它点的参数毫无关系，因为固定其它点的参数后其它点的颜色固定后，要求对应到的是 $x$，则 $x$ 到根路径的所有的参数是唯一确定的。</strong></p>
<p>对每个叶子节点预处理出到根路径外的点的参数选择的方案数。线段树支持区间取反操作，维护所有黑色叶子节点的方案数之和即可。</p>
<p>https://qoj.ac/submission/45436</p>
<h3 id="rarest-insects" tabindex="-1"> <a href="https://qoj.ac/contest/987/problem/4565" target="_blank" rel="noopener noreferrer">Rarest Insects</a></h3>
<p>把不同的数放在不同的列，这个东西很像一个柱形图（？）</p>
<p>一种思路是每次删掉一行（删掉所有出现过的数各一次，需保证数量始终为 $1$），次数是行数（最多数出现次数）$\times n$。</p>
<p>另一种思路是每次删掉一列（删掉某种数的所有出现，需保证数量每次必须加 $1$），次数是列数（数字种数）$\times n$。</p>
<p>两种各做 $\sqrt n$ 次后一定能删完（数字总数为 $n$）。这样是 $O(n\sqrt n)$ 次。没什么优化空间。</p>
<p>第一种思路其实可以扩展成每次删掉 $r$ 行，需保证数量始终不超过 $r$ 即可。</p>
<p>求出数字种类数 $c$。考虑二分答案（上界 $\frac nc$），用第一种思路来 check 当前答案 $mid$，是 $O(n\log n)$ 次。</p>
<p>这个可以继续优化，如果 check 成功了（加入了 $mid\times c$ 个数），已经加入的数之后就不需要加了；如果 check 失败了，未加入的数之后也不可能加。</p>
<p>这样每次数量接近减半（有个上取整），次数共 $2n$ 左右。再加上外面求种类数的 $n$，总次数 $3n$ 左右。</p>
<p>这样一交得了 99.89 分，再加点优化，比如已经达到 $mid\times c$ 之后的就不需要尝试加入了，再 shuffle 一下序列防止被卡，就通过了。</p>
<p>不知道有没有不用随机化严格在 $3n$ 内的做法？</p>
<p>https://qoj.ac/submission/45454</p>
]]></content:encoded>
    </item>
    <item>
      <title>NOIP2021 方差</title>
      <link>https://newzone.top/_posts/NOIP21T3.html</link>
      <guid>https://newzone.top/_posts/NOIP21T3.html</guid>
      <source url="https://newzone.top/rss.xml">NOIP2021 方差</source>
      <category>NOIP2021</category>
      <pubDate>Sun, 21 Nov 2021 13:06:35 GMT</pubDate>
      <content:encoded><![CDATA[<p>$$
\begin{align*}
n\overline{a}&amp;=\sum_{i=1}^na_i\
\
n^2D
&amp;=n\sum_{i=1}^n(a_i-\overline{a})^2\
&amp;=n\sum_{i=1}^n a_i^2-2n\overline{a}\sum_{i=1}^n a_i+n^2\overline{a}^2\
&amp;=n\sum_{i=1}^n a_i^2-2(\sum_{i=1}^n a_i)^2+(\sum_{i=1}^n a_i)^2\
&amp;=n\sum_{i=1}^n a_i^2-(\sum_{i=1}^n a_i)^2\
\end{align*}
$$</p>
<p>观察题目中的式子，$a'<em>i\leftarrow a</em>{i-1}+a_{i+1}-a_i$，根据 CF1110E 的套路，可以差分，令 $d_i=a_{i+1}-a_i(1\leq i\lt n)$，一次操作 $(2\leq i\lt n)$ 即：</p>
<p>$$
d'<em>{i-1}=a'</em>{i}-a'<em>{i-1}=(a</em>{i-1}+a_{i+1}-a_i)-a_{i-1}=a_{i+1}-a_i=d_i\
d'<em>i=a'</em>{i+1}-a'<em>{i}=a</em>{i+1}-(a_{i-1}+a_{i+1}-a_i)=a_i-a_{i-1}=d_{i-1}
$$</p>
<p>相当于交换 $d_{i-1},d_i(2\leq i\lt n)$，故 $d$ 可以通过若干次操作，变为任意 $d$ 的排列。</p>
<p>由于 $a_1$ 不变，那么 $a$ 和 $d$ 是一一对应的。现在要求一个 $d$ 的排列使得 $n^2D$ 最小，继续推式子：
$$
\begin{align*}
n^2D
&amp;=n\sum_{i=1}^n a_i^2-(\sum_{i=1}^n a_i)^2\
&amp;=n\sum_{i=1}^n a_i^2-\sum_{i=1}^n\sum_{j=1}^na_ia_j\
&amp;=\frac{1}{2}(n\sum_{i=1}^n a_i^2-2\sum_{i=1}^n\sum_{j=1}^na_ia_j+n\sum_{j=1}^n a_j^2)\
&amp;=\frac{1}{2}(\sum_{i=1}^n\sum_{j=1}^n(a_i-a_j)^2)\
&amp;=\sum_{i=1}^{n-1}\sum_{j=i}^{n-1}(a_{j+1}-a_i)^2\
&amp;=\sum_{i=1}^{n-1}\sum_{j=i}^{n-1}(d_i+d_{i+1}+\cdots+d_j)^2\
\end{align*}
$$
$n^2D$ 取最小值时，$d$ 一定是先递减后递增的。</p>
<p>考虑在分界位置（即递减到递增）从小到大往两边加数，由于
$$
\begin{align*}
n^2D
&amp;=n\sum_{i=1}^n a_i^2-(\sum_{i=1}^n a_i)^2\
\end{align*}
$$
维护 $dp[k][s]$ 表示当前已经加入了 $k$ 个数，现在的 $a$ 之和为 $s$ 的最小 $\displaystyle \sum_{i=1}^n a_i^2$。</p>
<p>初始 $dp[1][s]=0$。</p>
<p>转移时考虑加到左边还是右边：</p>
<ul>
<li>左边：原来是 $a_1,a_2,\cdots,a_k$，现在变为 $d,a_1+d,a_2+d,\cdots,a_k+d$，新增的贡献为</li>
</ul>
<p>$$
\begin{align*}
\Delta
&amp;=d^2+\sum_{i=1}^k (d+a_i)^2-\sum_{i=1}^k a_i^2\
&amp;=(k+1)d^2+2d\sum_{i=1}^ka_i\
&amp;=(k+1)d^2+2ds\
\end{align*}
$$</p>
<ul>
<li>右边：原来是 $a_1,a_2,\cdots,a_k$，现在变为 $a_1,a_2,\cdots,a_k,a_k+d$，新增的贡献为
$$
\begin{align*}
\Delta
&amp;=(a_k+d)^2\
\end{align*}
$$
其实可以发现 $a_k$ 是固定的，为之前所有的 $d$ 之和，不需要再记录。</li>
</ul>
<p>答案为 $\displaystyle \min_s{n\times dp[n][s]-s^2}$。</p>
<p>分析一下时间复杂度，第一维是 $O(n)$ 的，第二维是 $O(nV)$ 的，转移 $O(1)$。</p>
<p>但是可以发现 $d$ 为 $0$ 的转移可以忽略，第一维是 $O(\min(n,V))$ 的，总复杂度为 $O(nV^2)$，可以通过。</p>
<div><pre><code><span><span>#</span><span>include</span><span>&lt;bits/stdc++.h></span></span>
<span>using</span> <span>namespace</span> std<span>;</span>
<span>typedef</span> <span>long</span> <span>long</span> ll<span>;</span>
<span>const</span> ll INF<span>=</span><span>1ll</span><span>&lt;&lt;</span><span>60</span><span>;</span>
<span>int</span> n<span>,</span>a<span>[</span><span>11000</span><span>]</span><span>,</span>d<span>[</span><span>11000</span><span>]</span><span>;</span> ll dp<span>[</span><span>510000</span><span>]</span><span>;</span>
ll <span>sqr</span><span>(</span>ll x<span>)</span><span>{</span> <span>return</span> x<span>*</span>x<span>;</span><span>}</span>
<span>int</span> <span>main</span><span>(</span><span>)</span><span>{</span>
	<span>scanf</span><span>(</span><span>"%d"</span><span>,</span><span>&amp;</span>n<span>)</span><span>;</span>
	<span>for</span> <span>(</span><span>int</span> i<span>=</span><span>1</span><span>;</span>i<span>&lt;=</span>n<span>;</span>i<span>++</span><span>)</span> <span>scanf</span><span>(</span><span>"%d"</span><span>,</span><span>&amp;</span>a<span>[</span>i<span>]</span><span>)</span><span>;</span>
	<span>for</span> <span>(</span><span>int</span> i<span>=</span><span>1</span><span>;</span>i<span>&lt;</span>n<span>;</span>i<span>++</span><span>)</span> d<span>[</span>i<span>]</span><span>=</span>a<span>[</span>i<span>+</span><span>1</span><span>]</span><span>-</span>a<span>[</span>i<span>]</span><span>;</span>
	<span>sort</span><span>(</span>d<span>+</span><span>1</span><span>,</span>d<span>+</span>n<span>)</span><span>;</span>
	
	<span>for</span> <span>(</span><span>int</span> i<span>=</span><span>0</span><span>;</span>i<span>&lt;=</span><span>500000</span><span>;</span>i<span>++</span><span>)</span> dp<span>[</span>i<span>]</span><span>=</span>INF<span>;</span>
	dp<span>[</span><span>0</span><span>]</span><span>=</span><span>0</span><span>;</span> <span>int</span> lim<span>=</span><span>0</span><span>,</span>sum<span>=</span><span>0</span><span>;</span>
	<span>for</span> <span>(</span><span>int</span> i<span>=</span><span>1</span><span>;</span>i<span>&lt;</span>n<span>;</span>i<span>++</span><span>)</span><span>{</span>
		<span>if</span> <span>(</span><span>!</span>d<span>[</span>i<span>]</span><span>)</span> <span>continue</span><span>;</span>
		<span>for</span> <span>(</span><span>int</span> s<span>=</span>lim<span>;</span>s<span>>=</span><span>0</span><span>;</span>s<span>--</span><span>)</span><span>{</span>
			<span>if</span> <span>(</span>dp<span>[</span>s<span>]</span><span>==</span>INF<span>)</span> <span>continue</span><span>;</span>
			dp<span>[</span>s<span>+</span>sum<span>+</span>d<span>[</span>i<span>]</span><span>]</span><span>=</span><span>min</span><span>(</span>dp<span>[</span>s<span>+</span>sum<span>+</span>d<span>[</span>i<span>]</span><span>]</span><span>,</span>dp<span>[</span>s<span>]</span><span>+</span><span>sqr</span><span>(</span>sum<span>+</span>d<span>[</span>i<span>]</span><span>)</span><span>)</span><span>;</span>
			dp<span>[</span>s<span>+</span>i<span>*</span>d<span>[</span>i<span>]</span><span>]</span><span>=</span><span>min</span><span>(</span>dp<span>[</span>s<span>+</span>i<span>*</span>d<span>[</span>i<span>]</span><span>]</span><span>,</span>dp<span>[</span>s<span>]</span><span>+</span><span>2</span><span>*</span>s<span>*</span>d<span>[</span>i<span>]</span><span>+</span>i<span>*</span><span>sqr</span><span>(</span>d<span>[</span>i<span>]</span><span>)</span><span>)</span><span>;</span>
			dp<span>[</span>s<span>]</span><span>=</span>INF<span>;</span>
		<span>}</span>
		lim<span>+=</span>i<span>*</span>d<span>[</span>i<span>]</span><span>;</span> sum<span>+=</span>d<span>[</span>i<span>]</span><span>;</span>
	<span>}</span>
	ll ans<span>=</span>INF<span>;</span>
	<span>for</span> <span>(</span><span>int</span> i<span>=</span><span>0</span><span>;</span>i<span>&lt;=</span>lim<span>;</span>i<span>++</span><span>)</span>
		<span>if</span> <span>(</span>dp<span>[</span>i<span>]</span><span>!=</span>INF<span>)</span> ans<span>=</span><span>min</span><span>(</span>ans<span>,</span>n<span>*</span>dp<span>[</span>i<span>]</span><span>-</span><span>1ll</span><span>*</span>i<span>*</span>i<span>)</span><span>;</span>
	<span>printf</span><span>(</span><span>"%lld\n"</span><span>,</span>ans<span>)</span><span>;</span>
	<span>return</span> <span>0</span><span>;</span>
<span>}</span>

</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>UOJ681</title>
      <link>https://newzone.top/_posts/UOJ681.html</link>
      <guid>https://newzone.top/_posts/UOJ681.html</guid>
      <source url="https://newzone.top/rss.xml">UOJ681</source>
      <description>
给定 $n$ 个数字 $a_1,a_2,\cdots,a_n$。
$m$ 次询问，每次询问给定 $x$，求 $\oplus_{i=1}^n (a_i+x)$ 的值。
强制在线。
$1\leq n,m\leq 2.5\times 10^5,0\leq a_i,x\lt 2^{60}$。

</description>
      <category>UOJ</category>
      <pubDate>Sun, 03 Oct 2021 21:13:35 GMT</pubDate>
      <content:encoded><![CDATA[<ul>
<li>给定 $n$ 个数字 $a_1,a_2,\cdots,a_n$。</li>
<li>$m$ 次询问，每次询问给定 $x$，求 $\oplus_{i=1}^n (a_i+x)$ 的值。</li>
<li>强制在线。</li>
<li>$1\leq n,m\leq 2.5\times 10^5,0\leq a_i,x\lt 2^{60}$。</li>
</ul>

<h3 id="sol" tabindex="-1"> sol</h3>
<ul>
<li>
<p>由于每个 $a_i$ 加的都是 $x$，所以向第 $w$ 位进位的一定是后 $w-1$ 位 $a_i$ 最大的若干个数。</p>
</li>
<li>
<p>从低到高考虑每一位。讨论 $x$ 当前这一位是 $0$ 还是 $1$。</p>
</li>
<li>
<p>如果当前位为 0：</p>
<ul>
<li>$a_i+x$ 当前位为 $1$ 的数量：进位为 $0$ 且 $x$ 当前位为 $1$ 的数量 + 进位为 $1$ 且 $x$ 当前位为 $0$ 的数量；</li>
<li>$a_i+x$ 向前进位的数量：进位为 $1$ 且 $x$ 当前位为 $1$ 的数量。</li>
</ul>
</li>
<li>
<p>如果当前位为 1：</p>
<ul>
<li>$a_i+x$ 当前位为 $1$ 的数量：进位为 $1$ 且 $x$ 当前位为 $1$ 的数量 + 进位为 $0$ 且 $x$ 当前位为 $0$ 的数量；</li>
<li>$a_i+x$ 没向前进位的数量：进位为 $0$ 且 $x$ 当前位为 $0$ 的数量，向前进位的数量用 $n$ 减去即可。</li>
</ul>
</li>
<li>
<p>记 $sum[0/1][w][i]$ 为考虑后 $w-1$ 位有 $i$ 个数进位，第 $i$ 位没进位/进位的数的个数。</p>
</li>
<li>
<p>可以用基数排序优化每次的排序。</p>
</li>
</ul>
<div><pre><code><span><span>#</span><span>include</span><span>&lt;bits/stdc++.h></span></span>
<span>using</span> <span>namespace</span> std<span>;</span>
<span>typedef</span> <span>long</span> <span>long</span> ll<span>;</span>
<span>const</span> ll INF<span>=</span><span>1ll</span><span>&lt;&lt;</span><span>60</span><span>;</span>
<span>int</span> n<span>,</span>m<span>,</span>t<span>,</span>sum<span>[</span><span>2</span><span>]</span><span>[</span><span>64</span><span>]</span><span>[</span><span>260000</span><span>]</span><span>,</span>tmp<span>[</span><span>2</span><span>]</span><span>[</span><span>260000</span><span>]</span><span>,</span>p<span>[</span><span>260000</span><span>]</span><span>;</span>
ll ans<span>,</span>v<span>,</span>a<span>[</span><span>260000</span><span>]</span><span>;</span>
<span>int</span> <span>main</span><span>(</span><span>)</span><span>{</span>
	<span>scanf</span><span>(</span><span>"%d%d%d"</span><span>,</span><span>&amp;</span>n<span>,</span><span>&amp;</span>m<span>,</span><span>&amp;</span>t<span>)</span><span>;</span>
	<span>for</span> <span>(</span><span>int</span> i<span>=</span><span>1</span><span>;</span>i<span>&lt;=</span>n<span>;</span>i<span>++</span><span>)</span> <span>scanf</span><span>(</span><span>"%lld"</span><span>,</span><span>&amp;</span>a<span>[</span>i<span>]</span><span>)</span><span>,</span>p<span>[</span>i<span>]</span><span>=</span>i<span>;</span>
	<span>for</span> <span>(</span><span>int</span> w<span>=</span><span>0</span><span>;</span>w<span>&lt;</span><span>62</span><span>;</span>w<span>++</span><span>)</span><span>{</span>
		tmp<span>[</span><span>0</span><span>]</span><span>[</span><span>0</span><span>]</span><span>=</span><span>0</span><span>;</span> tmp<span>[</span><span>1</span><span>]</span><span>[</span><span>0</span><span>]</span><span>=</span><span>0</span><span>;</span>
		<span>for</span> <span>(</span><span>int</span> i<span>=</span><span>1</span><span>;</span>i<span>&lt;=</span>n<span>;</span>i<span>++</span><span>)</span><span>{</span>
			<span>int</span> x<span>=</span><span>(</span>a<span>[</span>p<span>[</span>i<span>]</span><span>]</span><span>>></span>w<span>)</span><span>&amp;</span><span>1</span><span>;</span> tmp<span>[</span>x<span>]</span><span>[</span><span>++</span>tmp<span>[</span>x<span>]</span><span>[</span><span>0</span><span>]</span><span>]</span><span>=</span>p<span>[</span>i<span>]</span><span>;</span>
			sum<span>[</span><span>0</span><span>]</span><span>[</span>w<span>]</span><span>[</span>i<span>]</span><span>=</span>tmp<span>[</span><span>0</span><span>]</span><span>[</span><span>0</span><span>]</span><span>;</span> sum<span>[</span><span>1</span><span>]</span><span>[</span>w<span>]</span><span>[</span>i<span>]</span><span>=</span>tmp<span>[</span><span>1</span><span>]</span><span>[</span><span>0</span><span>]</span><span>;</span>
		<span>}</span>
		<span>for</span> <span>(</span><span>int</span> i<span>=</span><span>1</span><span>;</span>i<span>&lt;=</span>tmp<span>[</span><span>0</span><span>]</span><span>[</span><span>0</span><span>]</span><span>;</span>i<span>++</span><span>)</span> p<span>[</span>i<span>]</span><span>=</span>tmp<span>[</span><span>0</span><span>]</span><span>[</span>i<span>]</span><span>;</span>
		<span>for</span> <span>(</span><span>int</span> i<span>=</span><span>1</span><span>;</span>i<span>&lt;=</span>tmp<span>[</span><span>1</span><span>]</span><span>[</span><span>0</span><span>]</span><span>;</span>i<span>++</span><span>)</span> p<span>[</span>i<span>+</span>tmp<span>[</span><span>0</span><span>]</span><span>[</span><span>0</span><span>]</span><span>]</span><span>=</span>tmp<span>[</span><span>1</span><span>]</span><span>[</span>i<span>]</span><span>;</span>
	<span>}</span>
	<span>for</span> <span>(</span><span>int</span> i<span>=</span><span>1</span><span>;</span>i<span>&lt;=</span>m<span>;</span>i<span>++</span><span>)</span><span>{</span>
		<span>scanf</span><span>(</span><span>"%lld"</span><span>,</span><span>&amp;</span>v<span>)</span><span>;</span> v<span>^=</span><span>(</span>t<span>*</span><span>(</span>ans<span>>></span><span>20</span><span>)</span><span>)</span><span>;</span>
		<span>int</span> x<span>=</span><span>0</span><span>;</span> ans<span>=</span><span>0</span><span>;</span>
		<span>for</span> <span>(</span><span>int</span> w<span>=</span><span>0</span><span>;</span>w<span>&lt;</span><span>62</span><span>;</span>w<span>++</span><span>)</span>
			<span>if</span> <span>(</span><span>(</span>v<span>>></span>w<span>)</span><span>&amp;</span><span>1</span><span>)</span><span>{</span>
				ans<span>^=</span><span>(</span><span>(</span><span>(</span>sum<span>[</span><span>1</span><span>]</span><span>[</span>w<span>]</span><span>[</span>n<span>]</span><span>-</span>sum<span>[</span><span>1</span><span>]</span><span>[</span>w<span>]</span><span>[</span>n<span>-</span>x<span>]</span><span>)</span><span>+</span>sum<span>[</span><span>0</span><span>]</span><span>[</span>w<span>]</span><span>[</span>n<span>-</span>x<span>]</span><span>)</span><span>&amp;</span><span>1ll</span><span>)</span><span>&lt;&lt;</span>w<span>;</span>
				x<span>=</span>n<span>-</span>sum<span>[</span><span>0</span><span>]</span><span>[</span>w<span>]</span><span>[</span>n<span>-</span>x<span>]</span><span>;</span>
			<span>}</span> <span>else</span><span>{</span>
				ans<span>^=</span><span>(</span><span>(</span><span>(</span>sum<span>[</span><span>0</span><span>]</span><span>[</span>w<span>]</span><span>[</span>n<span>]</span><span>-</span>sum<span>[</span><span>0</span><span>]</span><span>[</span>w<span>]</span><span>[</span>n<span>-</span>x<span>]</span><span>)</span><span>+</span>sum<span>[</span><span>1</span><span>]</span><span>[</span>w<span>]</span><span>[</span>n<span>-</span>x<span>]</span><span>)</span><span>&amp;</span><span>1ll</span><span>)</span><span>&lt;&lt;</span>w<span>;</span>
				x<span>=</span>sum<span>[</span><span>1</span><span>]</span><span>[</span>w<span>]</span><span>[</span>n<span>]</span><span>-</span>sum<span>[</span><span>1</span><span>]</span><span>[</span>w<span>]</span><span>[</span>n<span>-</span>x<span>]</span><span>;</span>
			<span>}</span>
		<span>printf</span><span>(</span><span>"%lld\n"</span><span>,</span>ans<span>)</span><span>;</span>
	<span>}</span>
	<span>return</span> <span>0</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>UOJ682</title>
      <link>https://newzone.top/_posts/UOJ682.html</link>
      <guid>https://newzone.top/_posts/UOJ682.html</guid>
      <source url="https://newzone.top/rss.xml">UOJ682</source>
      <description>
给定 $n$ 和序列 $a_1,a_2,\cdots,a_n$，$b_1,b_2,\cdots b_n$。
定义一个区间 $[l,r]$ 的权值为：对于所有满足 $p_i\in {a_i,b_i}$，$\oplus_{i=l}^r p_i$ 的序列 $p_1,p_2,\cdots p_n$ 的最大值。
求左右端点满足 $1\leq l\leq r\leq n$ 的区间中，第 $k$ 小的权值是多少（可重）。
$1\leq n\leq 10^5,0\leq a_i,b_i\lt 2^{30},1\leq k\leq \frac{n(n+1)}2$。

</description>
      <category>UOJ</category>
      <pubDate>Tue, 05 Oct 2021 22:01:02 GMT</pubDate>
      <content:encoded><![CDATA[<ul>
<li>给定 $n$ 和序列 $a_1,a_2,\cdots,a_n$，$b_1,b_2,\cdots b_n$。</li>
<li>定义一个区间 $[l,r]$ 的权值为：对于所有满足 $p_i\in {a_i,b_i}$，$\oplus_{i=l}^r p_i$ 的序列 $p_1,p_2,\cdots p_n$ 的最大值。</li>
<li>求左右端点满足 $1\leq l\leq r\leq n$ 的区间中，第 $k$ 小的权值是多少（可重）。</li>
<li>$1\leq n\leq 10^5,0\leq a_i,b_i\lt 2^{30},1\leq k\leq \frac{n(n+1)}2$。</li>
</ul>

<h3 id="sol" tabindex="-1"> sol</h3>
<h4 id="初步思考" tabindex="-1"> 初步思考</h4>
<ul>
<li>这种题目比较容易想到线性基。</li>
<li>但是线性基是其中每个数都可以选或不选，而这题是类似于连续区间二选一。</li>
<li>线性基就不能做了吗？当然不是，假设刚开始全部选 $a$，那么选择一些位置把它变成 $b$ 这种类型就是线性基能做的了。</li>
</ul>
<h4 id="问题转化" tabindex="-1"> 问题转化</h4>
<ul>
<li>记 $c_i=a_i\oplus b_i,s_i=\oplus_{j=1}^i a_j$，区间 $[l,r]$ 的权值转化为：$s_r\oplus s_{l-1}$ 再异或上若干个 $c_i$ 的最大值。</li>
<li>线性基求和 $x$ 异或的最大值的方法为：从高到低枚举每一位，若这一位 $x$ 为 $0$，则异或上线性基上这一位的数。</li>
<li>设 $f(x,T)=\max_{y\in T}(x\oplus y)$，其中 $x$ 是一个数，$T$ 是一个线性基。</li>
<li>暴力做法：固定左端点 $l$，移动右端点 $r$ 时维护线性基 $T$，求出每个区间的权值 $f(s_r\oplus s_{l-1},T)$，最后求第 $k$ 小值。</li>
</ul>
<h4 id="继续思考" tabindex="-1"> 继续思考</h4>
<ul>
<li>
<p>考虑优化暴力做法。固定左端点，由于线性基维数不超过 $m$，故不同的右端点本质不同的线性基至多有 $m+1$ 种（即维数分别为 $0,1,\cdots m$）。移动右端点时，线性基维数可能增加 $1$，也有可能不增加。</p>
</li>
<li>
<p>考虑改为：对于右端点 $r$，维护所有左端点为 $1,2,\cdots,r$ 的线性基。右端点从 $r-1$ 移动到 $r$ 时，一定是一个后缀 $p,p+1,\cdots,r$ 的线性基维数 $+1$，可以直接暴力更新，复杂度 $O(nm^2)$。</p>
</li>
<li>
<p>现在求的 $f(s_r\oplus s_{l-1},T_{l,r})$ 和 $l,r$ 都有关，虽然在移动右端点时维护出了不同的 $T$，但是带入无法解决。</p>
</li>
<li>
<p>设 $g(x,T)=\min_{y\in T}(x\oplus y)$，由于 $f$ 相当于 $x$ 某位为 $1$ 就异或那一位的线性基上的值，$g$ 相当于 $x$ 某位为 $0$ 就异或那一位的线性基上的值，那么 $f(s_r\oplus s_{l-1},T_{l,r})$ 等于 $f(s_r,T_{l,r})\oplus g(s_{l-1},T_{l,r})$。</p>
</li>
<li>
<p>现在 $T_{l,r}$ 可以增量维护，和右端点移动无关的 $f(s_r\oplus s_{l-1},T_{l,r})$ 就能维护了，而和右端点移动有关的 $g(s_r,T_{l,r})\oplus g(s_{l-1},T_{l,r})$ 由于本质不同的只有最多 $m$ 个，所以可以每次暴力重新求。</p>
</li>
</ul>
<h4 id="上述实现" tabindex="-1"> 上述实现</h4>
<ul>
<li>
<p>$lv[x][l]$ 表示基大小为 $x$，左端点为 $l$ 时代入 $s[l-1]$ 的最小值。</p>
</li>
<li>
<p>$rv[x][r]$ 表示基大小为 $x$，右端点为 $r$ 时代入 $s[r]$ 的最大值。</p>
</li>
<li>
<p>$lp[x][r]/rp[x][r]$ 表示基大小为 $x$，右端点为 $r$ 时左端点合法区间的左右端点。</p>
</li>
<li>
<p>具体来说，$lv$ 可以通过暴力往左枚举左端点，加入当前数扩大线性基，直到发现当前左端点当前数不能扩大线性基就停止。$rv/lp/rp$ 可以维护满足 $i..r$ 基大小为 $x$ 的最大的 $r$，在这些位置加入当前数扩大线性基合并。</p>
</li>
</ul>
<h4 id="求解答案" tabindex="-1"> 求解答案</h4>
<ul>
<li>二进制从高到低确定每一位，假设当前确定到从高到低第 $w$ 位。</li>
<li>枚举基大小，对于不同的右端点，求出合法左端点区间中，$g$ 和当前右端点 $f$ 值前 $w$ 位相同的数的数量，具体实现使用 <code>two-pointers</code>。</li>
<li>求和后和 $k$ 比较，如果 $&lt;k$，说明答案这位为 $1$，将 $k$ 减去当前数量，并将所有 $f$ 的这一位异或（即之后要找这一位不同的）。</li>
</ul>
<div><pre><code><span>//40pts</span>
<span><span>#</span><span>include</span><span>&lt;bits/stdc++.h></span></span>
<span>using</span> <span>namespace</span> std<span>;</span>
<span>typedef</span> <span>long</span> <span>long</span> ll<span>;</span>
<span>const</span> <span>int</span> m<span>=</span><span>30</span><span>;</span>
<span>int</span> n<span>,</span>a<span>[</span><span>110000</span><span>]</span><span>,</span>b<span>[</span><span>110000</span><span>]</span><span>,</span>c<span>[</span><span>110000</span><span>]</span><span>,</span>s<span>[</span><span>110000</span><span>]</span><span>;</span> ll k<span>;</span>
<span>int</span> lv<span>[</span><span>32</span><span>]</span><span>[</span><span>110000</span><span>]</span><span>,</span>rv<span>[</span><span>32</span><span>]</span><span>[</span><span>110000</span><span>]</span><span>,</span>lp<span>[</span><span>32</span><span>]</span><span>[</span><span>110000</span><span>]</span><span>,</span>rp<span>[</span><span>32</span><span>]</span><span>[</span><span>110000</span><span>]</span><span>,</span>v<span>[</span><span>32</span><span>]</span><span>[</span><span>110000</span><span>]</span><span>;</span>
unordered_map<span>&lt;</span><span>int</span><span>,</span><span>int</span><span>></span> mp<span>;</span>
<span>struct</span> <span>Basis</span><span>{</span>
	<span>int</span> tot<span>,</span>v<span>[</span><span>32</span><span>]</span><span>;</span>
	<span>Basis</span><span>(</span><span>)</span><span>{</span> tot<span>=</span><span>0</span><span>;</span> <span>memset</span><span>(</span>v<span>,</span><span>0</span><span>,</span><span>sizeof</span><span>(</span>v<span>)</span><span>)</span><span>;</span><span>}</span>
	<span>bool</span> <span>ins</span><span>(</span><span>int</span> x<span>)</span><span>{</span>
		<span>for</span> <span>(</span><span>int</span> i<span>=</span>m<span>-</span><span>1</span><span>;</span>i<span>>=</span><span>0</span><span>;</span>i<span>--</span><span>)</span>
			<span>if</span> <span>(</span><span>(</span>x<span>>></span>i<span>)</span><span>&amp;</span><span>1</span><span>)</span> x<span>^=</span>v<span>[</span>i<span>]</span><span>;</span>
		<span>for</span> <span>(</span><span>int</span> i<span>=</span>m<span>-</span><span>1</span><span>;</span>i<span>>=</span><span>0</span><span>;</span>i<span>--</span><span>)</span>
			<span>if</span> <span>(</span><span>(</span>x<span>>></span>i<span>)</span><span>&amp;</span><span>1</span><span>)</span><span>{</span>
				v<span>[</span>i<span>]</span><span>=</span>x<span>;</span> tot<span>++</span><span>;</span>
				<span>for</span> <span>(</span><span>int</span> j<span>=</span>m<span>-</span><span>1</span><span>;</span>j<span>></span>i<span>;</span>j<span>--</span><span>)</span>
					<span>if</span> <span>(</span><span>(</span>v<span>[</span>j<span>]</span><span>>></span>i<span>)</span><span>&amp;</span><span>1</span><span>)</span> v<span>[</span>j<span>]</span><span>^=</span>x<span>;</span>
				<span>return</span> <span>true</span><span>;</span>
			<span>}</span>
		<span>return</span> <span>false</span><span>;</span>
	<span>}</span>
	<span>int</span> <span>querymax</span><span>(</span><span>int</span> x<span>)</span><span>{</span>
		<span>for</span> <span>(</span><span>int</span> i<span>=</span>m<span>-</span><span>1</span><span>;</span>i<span>>=</span><span>0</span><span>;</span>i<span>--</span><span>)</span>
			<span>if</span> <span>(</span><span>!</span><span>(</span><span>(</span>x<span>>></span>i<span>)</span><span>&amp;</span><span>1</span><span>)</span><span>)</span> x<span>^=</span>v<span>[</span>i<span>]</span><span>;</span>
		<span>return</span> x<span>;</span>
	<span>}</span>
	<span>int</span> <span>querymin</span><span>(</span><span>int</span> x<span>)</span><span>{</span>
		<span>for</span> <span>(</span><span>int</span> i<span>=</span>m<span>-</span><span>1</span><span>;</span>i<span>>=</span><span>0</span><span>;</span>i<span>--</span><span>)</span>
			<span>if</span> <span>(</span><span>(</span>x<span>>></span>i<span>)</span><span>&amp;</span><span>1</span><span>)</span> x<span>^=</span>v<span>[</span>i<span>]</span><span>;</span>
		<span>return</span> x<span>;</span>
	<span>}</span>
<span>}</span> A<span>[</span><span>110000</span><span>]</span><span>,</span>B<span>[</span><span>110000</span><span>]</span><span>;</span>
vector<span>&lt;</span><span>int</span><span>></span> p<span>,</span>q<span>;</span>
<span>void</span> <span>upd</span><span>(</span><span>int</span> i<span>)</span><span>{</span>
	A<span>[</span>i<span>]</span><span>.</span><span>ins</span><span>(</span>c<span>[</span>i<span>]</span><span>)</span><span>;</span> <span>for</span> <span>(</span><span>int</span> x<span>:</span>p<span>)</span> A<span>[</span>x<span>]</span><span>.</span><span>ins</span><span>(</span>c<span>[</span>i<span>]</span><span>)</span><span>;</span>
	q<span>=</span>p<span>;</span> p<span>.</span><span>clear</span><span>(</span><span>)</span><span>;</span> p<span>.</span><span>push_back</span><span>(</span>i<span>)</span><span>;</span>
	<span>for</span> <span>(</span><span>int</span> x<span>:</span>q<span>)</span>
		<span>if</span> <span>(</span>A<span>[</span>x<span>]</span><span>.</span>tot<span>></span>A<span>[</span>p<span>.</span><span>back</span><span>(</span><span>)</span><span>]</span><span>.</span>tot<span>)</span> p<span>.</span><span>push_back</span><span>(</span>x<span>)</span><span>;</span>
<span>}</span>
<span>int</span> <span>main</span><span>(</span><span>)</span><span>{</span>
	<span>scanf</span><span>(</span><span>"%d%lld"</span><span>,</span><span>&amp;</span>n<span>,</span><span>&amp;</span>k<span>)</span><span>;</span>
	<span>for</span> <span>(</span><span>int</span> i<span>=</span><span>1</span><span>;</span>i<span>&lt;=</span>n<span>;</span>i<span>++</span><span>)</span><span>{</span>
		<span>scanf</span><span>(</span><span>"%d"</span><span>,</span><span>&amp;</span>a<span>[</span>i<span>]</span><span>)</span><span>;</span>
		s<span>[</span>i<span>]</span><span>=</span>s<span>[</span>i<span>-</span><span>1</span><span>]</span><span>^</span>a<span>[</span>i<span>]</span><span>;</span>
	<span>}</span>
	<span>for</span> <span>(</span><span>int</span> i<span>=</span><span>1</span><span>;</span>i<span>&lt;=</span>n<span>;</span>i<span>++</span><span>)</span><span>{</span>
		<span>scanf</span><span>(</span><span>"%d"</span><span>,</span><span>&amp;</span>b<span>[</span>i<span>]</span><span>)</span><span>;</span>
		c<span>[</span>i<span>]</span><span>=</span>a<span>[</span>i<span>]</span><span>^</span>b<span>[</span>i<span>]</span><span>;</span>
	<span>}</span>
	<span>for</span> <span>(</span><span>int</span> i<span>=</span><span>1</span><span>;</span>i<span>&lt;=</span>n<span>;</span>i<span>++</span><span>)</span><span>{</span>
		<span>for</span> <span>(</span><span>int</span> j<span>=</span>i<span>;</span>j<span>>=</span><span>1</span><span>&amp;&amp;</span><span>(</span>B<span>[</span>j<span>]</span><span>.</span><span>ins</span><span>(</span>c<span>[</span>i<span>]</span><span>)</span><span>||</span>i<span>==</span>j<span>)</span><span>;</span>j<span>--</span><span>)</span>
			lv<span>[</span>B<span>[</span>j<span>]</span><span>.</span>tot<span>]</span><span>[</span>j<span>]</span><span>=</span>B<span>[</span>j<span>]</span><span>.</span><span>querymin</span><span>(</span>s<span>[</span>j<span>-</span><span>1</span><span>]</span><span>)</span><span>;</span>
		<span>upd</span><span>(</span>i<span>)</span><span>;</span>
		<span>for</span> <span>(</span><span>int</span> j<span>=</span><span>0</span><span>;</span>j<span>&lt;</span><span>(</span><span>int</span><span>)</span>p<span>.</span><span>size</span><span>(</span><span>)</span><span>;</span>j<span>++</span><span>)</span><span>{</span>
			rv<span>[</span>A<span>[</span>p<span>[</span>j<span>]</span><span>]</span><span>.</span>tot<span>]</span><span>[</span>i<span>]</span><span>=</span>A<span>[</span>p<span>[</span>j<span>]</span><span>]</span><span>.</span><span>querymax</span><span>(</span>s<span>[</span>i<span>]</span><span>)</span><span>;</span>
			lp<span>[</span>A<span>[</span>p<span>[</span>j<span>]</span><span>]</span><span>.</span>tot<span>]</span><span>[</span>i<span>]</span><span>=</span><span>(</span>j<span>+</span><span>1</span><span>&lt;</span><span>(</span><span>int</span><span>)</span>p<span>.</span><span>size</span><span>(</span><span>)</span><span>?</span>p<span>[</span>j<span>+</span><span>1</span><span>]</span><span>+</span><span>1</span><span>:</span><span>1</span><span>)</span><span>;</span> rp<span>[</span>A<span>[</span>p<span>[</span>j<span>]</span><span>]</span><span>.</span>tot<span>]</span><span>[</span>i<span>]</span><span>=</span>p<span>[</span>j<span>]</span><span>;</span>
		<span>}</span>
	<span>}</span>
	<span>int</span> ans<span>=</span><span>0</span><span>;</span>
	<span>for</span> <span>(</span><span>int</span> i<span>=</span>m<span>-</span><span>1</span><span>;</span>i<span>>=</span><span>0</span><span>;</span>i<span>--</span><span>)</span><span>{</span>
		<span>for</span> <span>(</span><span>int</span> j<span>=</span><span>0</span><span>;</span>j<span>&lt;=</span>m<span>;</span>j<span>++</span><span>)</span>
			<span>for</span> <span>(</span><span>int</span> k<span>=</span><span>1</span><span>;</span>k<span>&lt;=</span>n<span>;</span>k<span>++</span><span>)</span>
				v<span>[</span>j<span>]</span><span>[</span>k<span>]</span><span>=</span><span>(</span><span>(</span>v<span>[</span>j<span>]</span><span>[</span>k<span>]</span><span>&lt;&lt;</span><span>1</span><span>)</span><span>|</span><span>(</span>rv<span>[</span>j<span>]</span><span>[</span>k<span>]</span><span>>></span>i<span>&amp;</span><span>1</span><span>)</span><span>)</span><span>;</span>
		ll tot<span>=</span><span>0</span><span>;</span>
		<span>for</span> <span>(</span><span>int</span> j<span>=</span><span>0</span><span>;</span>j<span>&lt;=</span>m<span>;</span>j<span>++</span><span>)</span><span>{</span>
			mp<span>.</span><span>clear</span><span>(</span><span>)</span><span>;</span> <span>int</span> l<span>=</span><span>1</span><span>,</span>r<span>=</span><span>0</span><span>;</span>
			<span>for</span> <span>(</span><span>int</span> k<span>=</span><span>1</span><span>;</span>k<span>&lt;=</span>n<span>;</span>k<span>++</span><span>)</span><span>{</span>
				<span>if</span> <span>(</span><span>!</span>lp<span>[</span>j<span>]</span><span>[</span>k<span>]</span><span>)</span> <span>continue</span><span>;</span>
				<span>while</span> <span>(</span>l<span>&lt;</span>lp<span>[</span>j<span>]</span><span>[</span>k<span>]</span><span>)</span> mp<span>[</span>lv<span>[</span>j<span>]</span><span>[</span>l<span>++</span><span>]</span><span>>></span>i<span>]</span><span>--</span><span>;</span>
				<span>while</span> <span>(</span>r<span>&lt;</span>rp<span>[</span>j<span>]</span><span>[</span>k<span>]</span><span>)</span> mp<span>[</span>lv<span>[</span>j<span>]</span><span>[</span><span>++</span>r<span>]</span><span>>></span>i<span>]</span><span>++</span><span>;</span>
				tot<span>+=</span>mp<span>[</span>v<span>[</span>j<span>]</span><span>[</span>k<span>]</span><span>]</span><span>;</span>
			<span>}</span>
		<span>}</span>
		<span>int</span> c<span>=</span><span>(</span>tot<span>&lt;</span>k<span>)</span><span>;</span> <span>if</span> <span>(</span>c<span>)</span> k<span>-=</span>tot<span>;</span>
		<span>for</span> <span>(</span><span>int</span> j<span>=</span><span>0</span><span>;</span>j<span>&lt;=</span>m<span>;</span>j<span>++</span><span>)</span>
			<span>for</span> <span>(</span><span>int</span> k<span>=</span><span>1</span><span>;</span>k<span>&lt;=</span>n<span>;</span>k<span>++</span><span>)</span>
				v<span>[</span>j<span>]</span><span>[</span>k<span>]</span><span>^=</span>c<span>;</span>
		ans<span>=</span><span>(</span>ans<span>&lt;&lt;</span><span>1</span><span>|</span>c<span>)</span><span>;</span>
	<span>}</span>
	<span>printf</span><span>(</span><span>"%d\n"</span><span>,</span>ans<span>)</span><span>;</span>
	<span>return</span> <span>0</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><ul>
<li>发现 TLE 了，因为直接这样子做常数非常大，因为求相同的数的数量时，$f/g$ 值可能很大，需要使用 $map/unordered_map$ 或 手写哈希表 等数据结构。</li>
<li>怎么办呢，可以发现，这一位做完后，前几位再也不会修改了，所以可以将前几位重标号，这样就可以通过此题，时间复杂度 $O(nm^2)$。</li>
</ul>
<div><pre><code><span>//Accepted</span>
<span><span>#</span><span>include</span><span>&lt;bits/stdc++.h></span></span>
<span>using</span> <span>namespace</span> std<span>;</span>
<span>typedef</span> <span>long</span> <span>long</span> ll<span>;</span>
<span>const</span> <span>int</span> m<span>=</span><span>30</span><span>;</span>
<span>int</span> n<span>,</span>c<span>[</span><span>110000</span><span>]</span><span>,</span>s<span>[</span><span>110000</span><span>]</span><span>,</span>mp<span>[</span><span>4100000</span><span>]</span><span>,</span>num<span>[</span><span>4100000</span><span>]</span><span>,</span>val<span>[</span><span>4100000</span><span>]</span><span>;</span> ll k<span>;</span>
<span>int</span> lv<span>[</span><span>32</span><span>]</span><span>[</span><span>110000</span><span>]</span><span>,</span>rv<span>[</span><span>32</span><span>]</span><span>[</span><span>110000</span><span>]</span><span>,</span>lp<span>[</span><span>32</span><span>]</span><span>[</span><span>110000</span><span>]</span><span>,</span>rp<span>[</span><span>32</span><span>]</span><span>[</span><span>110000</span><span>]</span><span>,</span>u<span>[</span><span>32</span><span>]</span><span>[</span><span>110000</span><span>]</span><span>,</span>v<span>[</span><span>32</span><span>]</span><span>[</span><span>110000</span><span>]</span><span>;</span>
<span>struct</span> <span>Basis</span><span>{</span>
	<span>int</span> tot<span>,</span>v<span>[</span><span>32</span><span>]</span><span>;</span>
	<span>Basis</span><span>(</span><span>)</span><span>{</span> tot<span>=</span><span>0</span><span>;</span> <span>memset</span><span>(</span>v<span>,</span><span>0</span><span>,</span><span>sizeof</span><span>(</span>v<span>)</span><span>)</span><span>;</span><span>}</span>
	<span>bool</span> <span>ins</span><span>(</span><span>int</span> x<span>)</span><span>{</span>
		<span>for</span> <span>(</span><span>int</span> i<span>=</span>m<span>-</span><span>1</span><span>;</span>i<span>>=</span><span>0</span><span>;</span>i<span>--</span><span>)</span>
			<span>if</span> <span>(</span><span>(</span>x<span>>></span>i<span>)</span><span>&amp;</span><span>1</span><span>)</span> x<span>^=</span>v<span>[</span>i<span>]</span><span>;</span>
		<span>for</span> <span>(</span><span>int</span> i<span>=</span>m<span>-</span><span>1</span><span>;</span>i<span>>=</span><span>0</span><span>;</span>i<span>--</span><span>)</span>
			<span>if</span> <span>(</span><span>(</span>x<span>>></span>i<span>)</span><span>&amp;</span><span>1</span><span>)</span><span>{</span>
				v<span>[</span>i<span>]</span><span>=</span>x<span>;</span> tot<span>++</span><span>;</span>
				<span>for</span> <span>(</span><span>int</span> j<span>=</span>m<span>-</span><span>1</span><span>;</span>j<span>></span>i<span>;</span>j<span>--</span><span>)</span>
					<span>if</span> <span>(</span><span>(</span>v<span>[</span>j<span>]</span><span>>></span>i<span>)</span><span>&amp;</span><span>1</span><span>)</span> v<span>[</span>j<span>]</span><span>^=</span>x<span>;</span>
				<span>return</span> <span>true</span><span>;</span>
			<span>}</span>
		<span>return</span> <span>false</span><span>;</span>
	<span>}</span>
	<span>int</span> <span>querymax</span><span>(</span><span>int</span> x<span>)</span><span>{</span>
		<span>for</span> <span>(</span><span>int</span> i<span>=</span>m<span>-</span><span>1</span><span>;</span>i<span>>=</span><span>0</span><span>;</span>i<span>--</span><span>)</span>
			<span>if</span> <span>(</span><span>!</span><span>(</span><span>(</span>x<span>>></span>i<span>)</span><span>&amp;</span><span>1</span><span>)</span><span>)</span> x<span>^=</span>v<span>[</span>i<span>]</span><span>;</span>
		<span>return</span> x<span>;</span>
	<span>}</span>
	<span>int</span> <span>querymin</span><span>(</span><span>int</span> x<span>)</span><span>{</span>
		<span>for</span> <span>(</span><span>int</span> i<span>=</span>m<span>-</span><span>1</span><span>;</span>i<span>>=</span><span>0</span><span>;</span>i<span>--</span><span>)</span>
			<span>if</span> <span>(</span><span>(</span>x<span>>></span>i<span>)</span><span>&amp;</span><span>1</span><span>)</span> x<span>^=</span>v<span>[</span>i<span>]</span><span>;</span>
		<span>return</span> x<span>;</span>
	<span>}</span>
<span>}</span> A<span>[</span><span>110000</span><span>]</span><span>,</span>B<span>[</span><span>110000</span><span>]</span><span>;</span>
vector<span>&lt;</span><span>int</span><span>></span> p<span>,</span>q<span>;</span>
<span>void</span> <span>upd</span><span>(</span><span>int</span> i<span>)</span><span>{</span>
	A<span>[</span>i<span>]</span><span>.</span><span>ins</span><span>(</span>c<span>[</span>i<span>]</span><span>)</span><span>;</span> <span>for</span> <span>(</span><span>int</span> x<span>:</span>p<span>)</span> A<span>[</span>x<span>]</span><span>.</span><span>ins</span><span>(</span>c<span>[</span>i<span>]</span><span>)</span><span>;</span>
	q<span>=</span>p<span>;</span> p<span>.</span><span>clear</span><span>(</span><span>)</span><span>;</span> p<span>.</span><span>push_back</span><span>(</span>i<span>)</span><span>;</span>
	<span>for</span> <span>(</span><span>int</span> x<span>:</span>q<span>)</span>
		<span>if</span> <span>(</span>A<span>[</span>x<span>]</span><span>.</span>tot<span>></span>A<span>[</span>p<span>.</span><span>back</span><span>(</span><span>)</span><span>]</span><span>.</span>tot<span>)</span> p<span>.</span><span>push_back</span><span>(</span>x<span>)</span><span>;</span>
<span>}</span>
<span>int</span> <span>main</span><span>(</span><span>)</span><span>{</span>
	<span>scanf</span><span>(</span><span>"%d%lld"</span><span>,</span><span>&amp;</span>n<span>,</span><span>&amp;</span>k<span>)</span><span>;</span>
	<span>for</span> <span>(</span><span>int</span> i<span>=</span><span>1</span><span>;</span>i<span>&lt;=</span>n<span>;</span>i<span>++</span><span>)</span> <span>scanf</span><span>(</span><span>"%d"</span><span>,</span><span>&amp;</span>s<span>[</span>i<span>]</span><span>)</span><span>;</span>
	<span>for</span> <span>(</span><span>int</span> i<span>=</span><span>1</span><span>;</span>i<span>&lt;=</span>n<span>;</span>i<span>++</span><span>)</span><span>{</span>
		<span>scanf</span><span>(</span><span>"%d"</span><span>,</span><span>&amp;</span>c<span>[</span>i<span>]</span><span>)</span><span>;</span>
		c<span>[</span>i<span>]</span><span>^=</span>s<span>[</span>i<span>]</span><span>;</span> s<span>[</span>i<span>]</span><span>^=</span>s<span>[</span>i<span>-</span><span>1</span><span>]</span><span>;</span>
	<span>}</span>
	<span>for</span> <span>(</span><span>int</span> i<span>=</span><span>1</span><span>;</span>i<span>&lt;=</span>n<span>;</span>i<span>++</span><span>)</span><span>{</span>
		<span>for</span> <span>(</span><span>int</span> j<span>=</span>i<span>;</span>j<span>>=</span><span>1</span><span>&amp;&amp;</span><span>(</span>B<span>[</span>j<span>]</span><span>.</span><span>ins</span><span>(</span>c<span>[</span>i<span>]</span><span>)</span><span>||</span>i<span>==</span>j<span>)</span><span>;</span>j<span>--</span><span>)</span>
			lv<span>[</span>B<span>[</span>j<span>]</span><span>.</span>tot<span>]</span><span>[</span>j<span>]</span><span>=</span>B<span>[</span>j<span>]</span><span>.</span><span>querymin</span><span>(</span>s<span>[</span>j<span>-</span><span>1</span><span>]</span><span>)</span><span>;</span>
		<span>upd</span><span>(</span>i<span>)</span><span>;</span>
		<span>for</span> <span>(</span><span>int</span> j<span>=</span><span>0</span><span>;</span>j<span>&lt;</span><span>(</span><span>int</span><span>)</span>p<span>.</span><span>size</span><span>(</span><span>)</span><span>;</span>j<span>++</span><span>)</span><span>{</span>
			rv<span>[</span>A<span>[</span>p<span>[</span>j<span>]</span><span>]</span><span>.</span>tot<span>]</span><span>[</span>i<span>]</span><span>=</span>A<span>[</span>p<span>[</span>j<span>]</span><span>]</span><span>.</span><span>querymax</span><span>(</span>s<span>[</span>i<span>]</span><span>)</span><span>;</span>
			lp<span>[</span>A<span>[</span>p<span>[</span>j<span>]</span><span>]</span><span>.</span>tot<span>]</span><span>[</span>i<span>]</span><span>=</span><span>(</span>j<span>+</span><span>1</span><span>&lt;</span><span>(</span><span>int</span><span>)</span>p<span>.</span><span>size</span><span>(</span><span>)</span><span>?</span>p<span>[</span>j<span>+</span><span>1</span><span>]</span><span>+</span><span>1</span><span>:</span><span>1</span><span>)</span><span>;</span> rp<span>[</span>A<span>[</span>p<span>[</span>j<span>]</span><span>]</span><span>.</span>tot<span>]</span><span>[</span>i<span>]</span><span>=</span>p<span>[</span>j<span>]</span><span>;</span>
		<span>}</span>
	<span>}</span>
	<span>int</span> ans<span>=</span><span>0</span><span>;</span>
	<span>for</span> <span>(</span><span>int</span> i<span>=</span>m<span>-</span><span>1</span><span>;</span>i<span>>=</span><span>0</span><span>;</span>i<span>--</span><span>)</span><span>{</span>
		<span>for</span> <span>(</span><span>int</span> j<span>=</span><span>0</span><span>;</span>j<span>&lt;=</span>m<span>;</span>j<span>++</span><span>)</span>
			<span>for</span> <span>(</span><span>int</span> k<span>=</span><span>1</span><span>;</span>k<span>&lt;=</span>n<span>;</span>k<span>++</span><span>)</span><span>{</span>
				v<span>[</span>j<span>]</span><span>[</span>k<span>]</span><span>=</span><span>(</span><span>(</span>v<span>[</span>j<span>]</span><span>[</span>k<span>]</span><span>&lt;&lt;</span><span>1</span><span>)</span><span>|</span><span>(</span>rv<span>[</span>j<span>]</span><span>[</span>k<span>]</span><span>>></span>i<span>&amp;</span><span>1</span><span>)</span><span>)</span><span>;</span>
				u<span>[</span>j<span>]</span><span>[</span>k<span>]</span><span>=</span><span>(</span><span>(</span>u<span>[</span>j<span>]</span><span>[</span>k<span>]</span><span>&lt;&lt;</span><span>1</span><span>)</span><span>|</span><span>(</span>lv<span>[</span>j<span>]</span><span>[</span>k<span>]</span><span>>></span>i<span>&amp;</span><span>1</span><span>)</span><span>)</span><span>;</span>
			<span>}</span>
		ll tot<span>=</span><span>0</span><span>;</span>
		<span>for</span> <span>(</span><span>int</span> j<span>=</span><span>0</span><span>;</span>j<span>&lt;=</span>m<span>;</span>j<span>++</span><span>)</span><span>{</span>
			<span>int</span> l<span>=</span><span>1</span><span>,</span>r<span>=</span><span>0</span><span>;</span>
			<span>for</span> <span>(</span><span>int</span> k<span>=</span><span>1</span><span>;</span>k<span>&lt;=</span>n<span>;</span>k<span>++</span><span>)</span><span>{</span>
				<span>if</span> <span>(</span><span>!</span>lp<span>[</span>j<span>]</span><span>[</span>k<span>]</span><span>)</span> <span>continue</span><span>;</span>
				<span>while</span> <span>(</span>l<span>&lt;</span>lp<span>[</span>j<span>]</span><span>[</span>k<span>]</span><span>)</span> mp<span>[</span>u<span>[</span>j<span>]</span><span>[</span>l<span>++</span><span>]</span><span>]</span><span>--</span><span>;</span>
				<span>while</span> <span>(</span>r<span>&lt;</span>rp<span>[</span>j<span>]</span><span>[</span>k<span>]</span><span>)</span> mp<span>[</span>u<span>[</span>j<span>]</span><span>[</span><span>++</span>r<span>]</span><span>]</span><span>++</span><span>;</span>
				tot<span>+=</span>mp<span>[</span>v<span>[</span>j<span>]</span><span>[</span>k<span>]</span><span>]</span><span>;</span>
			<span>}</span>
			<span>for</span> <span>(</span><span>int</span> k<span>=</span>l<span>;</span>k<span>&lt;=</span>r<span>;</span>k<span>++</span><span>)</span> mp<span>[</span>u<span>[</span>j<span>]</span><span>[</span>k<span>]</span><span>]</span><span>=</span><span>0</span><span>;</span>
		<span>}</span>
		<span>int</span> c<span>=</span><span>(</span>tot<span>&lt;</span>k<span>)</span><span>;</span> <span>if</span> <span>(</span>c<span>)</span> k<span>-=</span>tot<span>;</span>
		
		<span>int</span> now<span>=</span><span>0</span><span>;</span>
		<span>for</span> <span>(</span><span>int</span> j<span>=</span><span>0</span><span>;</span>j<span>&lt;=</span>m<span>;</span>j<span>++</span><span>)</span>
			<span>for</span> <span>(</span><span>int</span> k<span>=</span><span>1</span><span>;</span>k<span>&lt;=</span>n<span>;</span>k<span>++</span><span>)</span><span>{</span>
				v<span>[</span>j<span>]</span><span>[</span>k<span>]</span><span>^=</span>c<span>;</span>
				<span>if</span> <span>(</span><span>!</span>num<span>[</span>v<span>[</span>j<span>]</span><span>[</span>k<span>]</span><span>]</span><span>)</span> now<span>++</span><span>,</span>num<span>[</span>v<span>[</span>j<span>]</span><span>[</span>k<span>]</span><span>]</span><span>=</span>now<span>,</span>val<span>[</span>now<span>]</span><span>=</span>v<span>[</span>j<span>]</span><span>[</span>k<span>]</span><span>;</span>
				v<span>[</span>j<span>]</span><span>[</span>k<span>]</span><span>=</span>num<span>[</span>v<span>[</span>j<span>]</span><span>[</span>k<span>]</span><span>]</span><span>;</span>
			<span>}</span>
		<span>for</span> <span>(</span><span>int</span> j<span>=</span><span>0</span><span>;</span>j<span>&lt;=</span>m<span>;</span>j<span>++</span><span>)</span>
			<span>for</span> <span>(</span><span>int</span> k<span>=</span><span>1</span><span>;</span>k<span>&lt;=</span>n<span>;</span>k<span>++</span><span>)</span>
				<span>if</span> <span>(</span>num<span>[</span>u<span>[</span>j<span>]</span><span>[</span>k<span>]</span><span>]</span><span>)</span> u<span>[</span>j<span>]</span><span>[</span>k<span>]</span><span>=</span>num<span>[</span>u<span>[</span>j<span>]</span><span>[</span>k<span>]</span><span>]</span><span>;</span>
				<span>else</span> u<span>[</span>j<span>]</span><span>[</span>k<span>]</span><span>=</span><span>0</span><span>;</span>
		<span>while</span> <span>(</span>now<span>)</span> num<span>[</span>val<span>[</span>now<span>--</span><span>]</span><span>]</span><span>=</span><span>0</span><span>;</span>
		ans<span>=</span><span>(</span>ans<span>&lt;&lt;</span><span>1</span><span>|</span>c<span>)</span><span>;</span>
	<span>}</span>
	<span>printf</span><span>(</span><span>"%d\n"</span><span>,</span>ans<span>)</span><span>;</span>
	<span>return</span> <span>0</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div>]]></content:encoded>
    </item>
  </channel>
</rss>